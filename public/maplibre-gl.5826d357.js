// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"8MOcE":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "1d3be7485826d357";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"5AnAU":[function(require,module,exports) {
/* MapLibre GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/LICENSE.txt */ (function(global, factory) {
    module.exports = factory();
})(this, function() {
    "use strict";
    /* eslint-disable */ var shared, worker, maplibregl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) shared = chunk;
        else if (!worker) worker = chunk;
        else {
            var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
            var sharedChunk = {};
            shared(sharedChunk);
            maplibregl = chunk(sharedChunk);
            if (typeof window !== "undefined") maplibregl.workerUrl = window.URL.createObjectURL(new Blob([
                workerBundleString
            ], {
                type: "text/javascript"
            }));
        }
    }
    define([
        "exports"
    ], function(t1) {
        "use strict";
        var e1 = r;
        function r(t1, e1, r, n) {
            this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e1, this.by = 3 * (n - e1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e1, this.p2x = r, this.p2y = n;
        }
        function n(t1, r, n, i) {
            const a = new e1(t1, r, n, i);
            return function(t1) {
                return a.solve(t1);
            };
        }
        r.prototype = {
            sampleCurveX: function(t1) {
                return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
            },
            sampleCurveY: function(t1) {
                return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
            },
            sampleCurveDerivativeX: function(t1) {
                return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
            },
            solveCurveX: function(t1, e1) {
                if (void 0 === e1 && (e1 = 1e-6), t1 < 0) return 0;
                if (t1 > 1) return 1;
                for(var r = t1, n = 0; n < 8; n++){
                    var i = this.sampleCurveX(r) - t1;
                    if (Math.abs(i) < e1) return r;
                    var a = this.sampleCurveDerivativeX(r);
                    if (Math.abs(a) < 1e-6) break;
                    r -= i / a;
                }
                var s = 0, o = 1;
                for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e1)); n++)t1 > i ? s = r : o = r, r = .5 * (o - s) + s;
                return r;
            },
            solve: function(t1, e1) {
                return this.sampleCurveY(this.solveCurveX(t1, e1));
            }
        };
        const i = n(.25, .1, .25, 1);
        function a(t1, e1, r) {
            return Math.min(r, Math.max(e1, t1));
        }
        function s(t1, e1, r) {
            const n = r - e1, i = ((t1 - e1) % n + n) % n + e1;
            return i === e1 ? r : i;
        }
        function o(t1, ...e1) {
            for (const r of e1)for(const e1 in r)t1[e1] = r[e1];
            return t1;
        }
        let l = 1;
        function u(t1, e1) {
            t1.forEach((t1)=>{
                e1[t1] && (e1[t1] = e1[t1].bind(e1));
            });
        }
        function c(t1, e1, r) {
            const n = {};
            for(const i in t1)n[i] = e1.call(r || this, t1[i], i, t1);
            return n;
        }
        function h(t1, e1, r) {
            const n = {};
            for(const i in t1)e1.call(r || this, t1[i], i, t1) && (n[i] = t1[i]);
            return n;
        }
        function p(t1) {
            return Array.isArray(t1) ? t1.map(p) : "object" == typeof t1 && t1 ? c(t1, p) : t1;
        }
        const f = {};
        function d(t1) {
            f[t1] || ("undefined" != typeof console && console.warn(t1), f[t1] = !0);
        }
        function y(t1, e1, r) {
            return (r.y - t1.y) * (e1.x - t1.x) > (e1.y - t1.y) * (r.x - t1.x);
        }
        function m(t1) {
            let e1 = 0;
            for(let r, n, i = 0, a = t1.length, s = a - 1; i < a; s = i++)r = t1[i], n = t1[s], e1 += (n.x - r.x) * (r.y + n.y);
            return e1;
        }
        function g() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function x(t1) {
            const e1 = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const a = n || i;
                return e1[r] = !a || a.toLowerCase(), "";
            }), e1["max-age"]) {
                const t1 = parseInt(e1["max-age"], 10);
                isNaN(t1) ? delete e1["max-age"] : e1["max-age"] = t1;
            }
            return e1;
        }
        let v, b, w = null;
        function _(t1) {
            if (null == w) {
                const e1 = t1.navigator ? t1.navigator.userAgent : null;
                w = !!t1.safari || !(!e1 || !(/\b(iPad|iPhone|iPod)\b/.test(e1) || e1.match("Safari") && !e1.match("Chrome")));
            }
            return w;
        }
        function A(t1) {
            return "undefined" != typeof ImageBitmap && t1 instanceof ImageBitmap;
        }
        const k = {
            now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
            frame (t1) {
                const e1 = requestAnimationFrame(t1);
                return {
                    cancel: ()=>cancelAnimationFrame(e1)
                };
            },
            getImageData (t1, e1 = 0) {
                const r = window.document.createElement("canvas"), n = r.getContext("2d");
                if (!n) throw new Error("failed to create canvas 2d context");
                return r.width = t1.width, r.height = t1.height, n.drawImage(t1, 0, 0, t1.width, t1.height), n.getImageData(-e1, -e1, t1.width + 2 * e1, t1.height + 2 * e1);
            },
            resolveURL: (t1)=>(v || (v = document.createElement("a")), v.href = t1, v.href),
            hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion () {
                return !!matchMedia && (null == b && (b = matchMedia("(prefers-reduced-motion: reduce)")), b.matches);
            }
        };
        var S = I;
        function I(t1, e1) {
            this.x = t1, this.y = e1;
        }
        I.prototype = {
            clone: function() {
                return new I(this.x, this.y);
            },
            add: function(t1) {
                return this.clone()._add(t1);
            },
            sub: function(t1) {
                return this.clone()._sub(t1);
            },
            multByPoint: function(t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint: function(t1) {
                return this.clone()._divByPoint(t1);
            },
            mult: function(t1) {
                return this.clone()._mult(t1);
            },
            div: function(t1) {
                return this.clone()._div(t1);
            },
            rotate: function(t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround: function(t1, e1) {
                return this.clone()._rotateAround(t1, e1);
            },
            matMult: function(t1) {
                return this.clone()._matMult(t1);
            },
            unit: function() {
                return this.clone()._unit();
            },
            perp: function() {
                return this.clone()._perp();
            },
            round: function() {
                return this.clone()._round();
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function(t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist: function(t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr: function(t1) {
                var e1 = t1.x - this.x, r = t1.y - this.y;
                return e1 * e1 + r * r;
            },
            angle: function() {
                return Math.atan2(this.y, this.x);
            },
            angleTo: function(t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith: function(t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep: function(t1, e1) {
                return Math.atan2(this.x * e1 - this.y * t1, this.x * t1 + this.y * e1);
            },
            _matMult: function(t1) {
                var e1 = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e1, this;
            },
            _add: function(t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub: function(t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult: function(t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div: function(t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint: function(t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint: function(t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit: function() {
                return this._div(this.mag()), this;
            },
            _perp: function() {
                var t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate: function(t1) {
                var e1 = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e1 * this.y;
                return this.x = e1 * this.x - r * this.y, this.y = n, this;
            },
            _rotateAround: function(t1, e1) {
                var r = Math.cos(t1), n = Math.sin(t1), i = e1.y + n * (this.x - e1.x) + r * (this.y - e1.y);
                return this.x = e1.x + r * (this.x - e1.x) - n * (this.y - e1.y), this.y = i, this;
            },
            _round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
        }, I.convert = function(t1) {
            return t1 instanceof I ? t1 : Array.isArray(t1) ? new I(t1[0], t1[1]) : t1;
        };
        const M = {
            MAX_PARALLEL_IMAGE_REQUESTS: 16,
            REGISTERED_PROTOCOLS: {}
        }, z = "mapbox-tiles";
        let B, C, P = 500, V = 50;
        function E() {
            "undefined" == typeof caches || B || (B = caches.open(z));
        }
        let F = 1 / 0;
        const T = {
            supported: !1,
            testSupport: function(t1) {
                !$ && D && (R ? O(t1) : L = t1);
            }
        };
        let L, D, $ = !1, R = !1;
        function O(t1) {
            const e1 = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e1);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, D), t1.isContextLost()) return;
                T.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e1), $ = !0;
        }
        "undefined" != typeof document && (D = document.createElement("img"), D.onload = function() {
            L && O(L), L = null, R = !0;
        }, D.onerror = function() {
            $ = !0, L = null;
        }, D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const U = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image"
        };
        "function" == typeof Object.freeze && Object.freeze(U);
        class q extends Error {
            constructor(t1, e1, r, n){
                super(`AJAXError: ${e1} (${t1}): ${r}`), this.status = t1, this.statusText = e1, this.url = r, this.body = n;
            }
        }
        const j = g() ? ()=>self.worker && self.worker.referrer : ()=>("blob:" === window.location.protocol ? window.parent : window).location.href;
        function N(t1, e1) {
            const r = new AbortController, n = new Request(t1.url, {
                method: t1.method || "GET",
                body: t1.body,
                credentials: t1.credentials,
                headers: t1.headers,
                referrer: j(),
                signal: r.signal
            });
            let i = !1, a = !1;
            "json" === t1.type && n.headers.set("Accept", "application/json");
            return ((r, s, o)=>{
                if (a) return;
                const l = Date.now();
                fetch(n).then((r)=>r.ok ? ((r, s, o)=>{
                        ("arrayBuffer" === t1.type ? r.arrayBuffer() : "json" === t1.type ? r.json() : r.text()).then((t1)=>{
                            a || (s && o && function(t1, e1, r) {
                                if (E(), !B) return;
                                const n = {
                                    status: e1.status,
                                    statusText: e1.statusText,
                                    headers: new Headers
                                };
                                e1.headers.forEach((t1, e1)=>n.headers.set(e1, t1));
                                const i = x(e1.headers.get("Cache-Control") || "");
                                i["no-store"] || (i["max-age"] && n.headers.set("Expires", new Date(r + 1e3 * i["max-age"]).toUTCString()), new Date(n.headers.get("Expires")).getTime() - r < 42e4 || function(t1, e1) {
                                    if (void 0 === C) try {
                                        new Response(new ReadableStream), C = !0;
                                    } catch (t1) {
                                        C = !1;
                                    }
                                    C ? e1(t1.body) : t1.blob().then(e1);
                                }(e1, (e1)=>{
                                    const r = new Response(e1, n);
                                    E(), B && B.then((e1)=>e1.put(function(t1) {
                                            const e1 = t1.indexOf("?");
                                            return e1 < 0 ? t1 : t1.slice(0, e1);
                                        }(t1.url), r)).catch((t1)=>d(t1.message));
                                }));
                            }(n, s, o), i = !0, e1(null, t1, r.headers.get("Cache-Control"), r.headers.get("Expires")));
                        }).catch((t1)=>{
                            a || e1(new Error(t1.message));
                        });
                    })(r, null, l) : r.blob().then((n)=>e1(new q(r.status, r.statusText, t1.url, n)))).catch((t1)=>{
                    20 !== t1.code && e1(new Error(t1.message));
                });
            })(), {
                cancel: ()=>{
                    a = !0, i || r.abort();
                }
            };
        }
        const Z = function(t1, e1) {
            if (/:\/\//.test(t1.url) && !/^https?:|^file:/.test(t1.url)) {
                if (g() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t1, e1);
                if (!g()) {
                    const r = t1.url.substring(0, t1.url.indexOf("://"));
                    return (M.REGISTERED_PROTOCOLS[r] || N)(t1, e1);
                }
            }
            if (!(/^file:/.test(r = t1.url) || /^file:/.test(j()) && !/^\w+:/.test(r))) {
                if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return N(t1, e1);
                if (g() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t1, e1, void 0, !0);
            }
            var r;
            return function(t1, e1) {
                const r = new XMLHttpRequest;
                r.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (r.responseType = "arraybuffer");
                for(const e1 in t1.headers)r.setRequestHeader(e1, t1.headers[e1]);
                return "json" === t1.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t1.credentials, r.onerror = ()=>{
                    e1(new Error(r.statusText));
                }, r.onload = ()=>{
                    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
                        let n = r.response;
                        if ("json" === t1.type) try {
                            n = JSON.parse(r.response);
                        } catch (t1) {
                            return e1(t1);
                        }
                        e1(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));
                    } else {
                        const n = new Blob([
                            r.response
                        ], {
                            type: r.getResponseHeader("Content-Type")
                        });
                        e1(new q(r.status, r.statusText, t1.url, n));
                    }
                }, r.send(t1.body), {
                    cancel: ()=>r.abort()
                };
            }(t1, e1);
        }, K = function(t1, e1) {
            return Z(o(t1, {
                type: "arrayBuffer"
            }), e1);
        };
        function G(t1) {
            const e1 = window.document.createElement("a");
            return e1.href = t1, e1.protocol === window.document.location.protocol && e1.host === window.document.location.host;
        }
        const J = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let X, Y;
        X = [], Y = 0;
        const H = function(t1, e1) {
            if (T.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), Y >= M.MAX_PARALLEL_IMAGE_REQUESTS) {
                const r = {
                    requestParameters: t1,
                    callback: e1,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return X.push(r), r;
            }
            Y++;
            let r = !1;
            const n = ()=>{
                if (!r) for(r = !0, Y--; X.length && Y < M.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = X.shift(), { requestParameters: e1, callback: r, cancelled: n } = t1;
                    n || (t1.cancel = H(e1, r).cancel);
                }
            }, i = K(t1, (t1, r, i, a)=>{
                n(), t1 ? e1(t1) : r && function(t1, e1) {
                    "function" == typeof createImageBitmap ? function(t1, e1) {
                        const r = new Blob([
                            new Uint8Array(t1)
                        ], {
                            type: "image/png"
                        });
                        createImageBitmap(r).then((t1)=>{
                            e1(null, t1);
                        }).catch((t1)=>{
                            e1(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                        });
                    }(t1, e1) : function(t1, e1) {
                        const r = new Image;
                        r.onload = ()=>{
                            e1(null, r), URL.revokeObjectURL(r.src), r.onload = null, window.requestAnimationFrame(()=>{
                                r.src = J;
                            });
                        }, r.onerror = ()=>e1(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                        const n = new Blob([
                            new Uint8Array(t1)
                        ], {
                            type: "image/png"
                        });
                        r.src = t1.byteLength ? URL.createObjectURL(n) : J;
                    }(t1, e1);
                }(r, (t1, r)=>{
                    null != t1 ? e1(t1) : null != r && e1(null, r, {
                        cacheControl: i,
                        expires: a
                    });
                });
            });
            return {
                cancel: ()=>{
                    i.cancel(), n();
                }
            };
        };
        function W(t1, e1, r) {
            r[t1] && -1 !== r[t1].indexOf(e1) || (r[t1] = r[t1] || [], r[t1].push(e1));
        }
        function Q(t1, e1, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e1);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class tt {
            constructor(t1, e1 = {}){
                o(this, e1), this.type = t1;
            }
        }
        class et extends tt {
            constructor(t1, e1 = {}){
                super("error", o({
                    error: t1
                }, e1));
            }
        }
        class rt {
            on(t1, e1) {
                return this._listeners = this._listeners || {}, W(t1, e1, this._listeners), this;
            }
            off(t1, e1) {
                return Q(t1, e1, this._listeners), Q(t1, e1, this._oneTimeListeners), this;
            }
            once(t1, e1) {
                return this._oneTimeListeners = this._oneTimeListeners || {}, W(t1, e1, this._oneTimeListeners), this;
            }
            fire(t1, e1) {
                "string" == typeof t1 && (t1 = new tt(t1, e1 || {}));
                const r = t1.type;
                if (this.listens(r)) {
                    t1.target = this;
                    const e1 = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
                    for (const r of e1)r.call(this, t1);
                    const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
                    for (const e1 of n)Q(r, e1, this._oneTimeListeners), e1.call(this, t1);
                    const i = this._eventedParent;
                    i && (o(t1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t1));
                } else t1 instanceof et && console.error(t1.error);
                return this;
            }
            listens(t1) {
                return this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1);
            }
            setEventedParent(t1, e1) {
                return this._eventedParent = t1, this._eventedParentData = e1, this;
            }
        }
        var nt = {
            $version: 8,
            $root: {
                version: {
                    required: !0,
                    type: "enum",
                    values: [
                        8
                    ]
                },
                name: {
                    type: "string"
                },
                metadata: {
                    type: "*"
                },
                center: {
                    type: "array",
                    value: "number"
                },
                zoom: {
                    type: "number"
                },
                bearing: {
                    type: "number",
                    default: 0,
                    period: 360,
                    units: "degrees"
                },
                pitch: {
                    type: "number",
                    default: 0,
                    units: "degrees"
                },
                light: {
                    type: "light"
                },
                terrain: {
                    type: "terrain"
                },
                sources: {
                    required: !0,
                    type: "sources"
                },
                sprite: {
                    type: "string"
                },
                glyphs: {
                    type: "string"
                },
                transition: {
                    type: "transition"
                },
                layers: {
                    required: !0,
                    type: "array",
                    value: "layer"
                }
            },
            sources: {
                "*": {
                    type: "source"
                }
            },
            source: [
                "source_vector",
                "source_raster",
                "source_raster_dem",
                "source_geojson",
                "source_video",
                "source_image"
            ],
            source_vector: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        vector: {}
                    }
                },
                url: {
                    type: "string"
                },
                tiles: {
                    type: "array",
                    value: "string"
                },
                bounds: {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [
                        -180,
                        -85.051129,
                        180,
                        85.051129
                    ]
                },
                scheme: {
                    type: "enum",
                    values: {
                        xyz: {},
                        tms: {}
                    },
                    default: "xyz"
                },
                minzoom: {
                    type: "number",
                    default: 0
                },
                maxzoom: {
                    type: "number",
                    default: 22
                },
                attribution: {
                    type: "string"
                },
                promoteId: {
                    type: "promoteId"
                },
                volatile: {
                    type: "boolean",
                    default: !1
                },
                "*": {
                    type: "*"
                }
            },
            source_raster: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        raster: {}
                    }
                },
                url: {
                    type: "string"
                },
                tiles: {
                    type: "array",
                    value: "string"
                },
                bounds: {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [
                        -180,
                        -85.051129,
                        180,
                        85.051129
                    ]
                },
                minzoom: {
                    type: "number",
                    default: 0
                },
                maxzoom: {
                    type: "number",
                    default: 22
                },
                tileSize: {
                    type: "number",
                    default: 512,
                    units: "pixels"
                },
                scheme: {
                    type: "enum",
                    values: {
                        xyz: {},
                        tms: {}
                    },
                    default: "xyz"
                },
                attribution: {
                    type: "string"
                },
                volatile: {
                    type: "boolean",
                    default: !1
                },
                "*": {
                    type: "*"
                }
            },
            source_raster_dem: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        "raster-dem": {}
                    }
                },
                url: {
                    type: "string"
                },
                tiles: {
                    type: "array",
                    value: "string"
                },
                bounds: {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [
                        -180,
                        -85.051129,
                        180,
                        85.051129
                    ]
                },
                minzoom: {
                    type: "number",
                    default: 0
                },
                maxzoom: {
                    type: "number",
                    default: 22
                },
                tileSize: {
                    type: "number",
                    default: 512,
                    units: "pixels"
                },
                attribution: {
                    type: "string"
                },
                encoding: {
                    type: "enum",
                    values: {
                        terrarium: {},
                        mapbox: {}
                    },
                    default: "mapbox"
                },
                volatile: {
                    type: "boolean",
                    default: !1
                },
                "*": {
                    type: "*"
                }
            },
            source_geojson: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        geojson: {}
                    }
                },
                data: {
                    type: "*"
                },
                maxzoom: {
                    type: "number",
                    default: 18
                },
                attribution: {
                    type: "string"
                },
                buffer: {
                    type: "number",
                    default: 128,
                    maximum: 512,
                    minimum: 0
                },
                filter: {
                    type: "*"
                },
                tolerance: {
                    type: "number",
                    default: .375
                },
                cluster: {
                    type: "boolean",
                    default: !1
                },
                clusterRadius: {
                    type: "number",
                    default: 50,
                    minimum: 0
                },
                clusterMaxZoom: {
                    type: "number"
                },
                clusterMinPoints: {
                    type: "number"
                },
                clusterProperties: {
                    type: "*"
                },
                lineMetrics: {
                    type: "boolean",
                    default: !1
                },
                generateId: {
                    type: "boolean",
                    default: !1
                },
                promoteId: {
                    type: "promoteId"
                }
            },
            source_video: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        video: {}
                    }
                },
                urls: {
                    required: !0,
                    type: "array",
                    value: "string"
                },
                coordinates: {
                    required: !0,
                    type: "array",
                    length: 4,
                    value: {
                        type: "array",
                        length: 2,
                        value: "number"
                    }
                }
            },
            source_image: {
                type: {
                    required: !0,
                    type: "enum",
                    values: {
                        image: {}
                    }
                },
                url: {
                    required: !0,
                    type: "string"
                },
                coordinates: {
                    required: !0,
                    type: "array",
                    length: 4,
                    value: {
                        type: "array",
                        length: 2,
                        value: "number"
                    }
                }
            },
            layer: {
                id: {
                    type: "string",
                    required: !0
                },
                type: {
                    type: "enum",
                    values: {
                        fill: {},
                        line: {},
                        symbol: {},
                        circle: {},
                        heatmap: {},
                        "fill-extrusion": {},
                        raster: {},
                        hillshade: {},
                        background: {}
                    },
                    required: !0
                },
                metadata: {
                    type: "*"
                },
                source: {
                    type: "string"
                },
                "source-layer": {
                    type: "string"
                },
                minzoom: {
                    type: "number",
                    minimum: 0,
                    maximum: 24
                },
                maxzoom: {
                    type: "number",
                    minimum: 0,
                    maximum: 24
                },
                filter: {
                    type: "filter"
                },
                layout: {
                    type: "layout"
                },
                paint: {
                    type: "paint"
                }
            },
            layout: [
                "layout_fill",
                "layout_line",
                "layout_circle",
                "layout_heatmap",
                "layout_fill-extrusion",
                "layout_symbol",
                "layout_raster",
                "layout_hillshade",
                "layout_background"
            ],
            layout_background: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_fill: {
                "fill-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_circle: {
                "circle-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_heatmap: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            "layout_fill-extrusion": {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_line: {
                "line-cap": {
                    type: "enum",
                    values: {
                        butt: {},
                        round: {},
                        square: {}
                    },
                    default: "butt",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "line-join": {
                    type: "enum",
                    values: {
                        bevel: {},
                        round: {},
                        miter: {}
                    },
                    default: "miter",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-miter-limit": {
                    type: "number",
                    default: 2,
                    requires: [
                        {
                            "line-join": "miter"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "line-round-limit": {
                    type: "number",
                    default: 1.05,
                    requires: [
                        {
                            "line-join": "round"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "line-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_symbol: {
                "symbol-placement": {
                    type: "enum",
                    values: {
                        point: {},
                        line: {},
                        "line-center": {}
                    },
                    default: "point",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "symbol-spacing": {
                    type: "number",
                    default: 250,
                    minimum: 1,
                    units: "pixels",
                    requires: [
                        {
                            "symbol-placement": "line"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "symbol-avoid-edges": {
                    type: "boolean",
                    default: !1,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "symbol-sort-key": {
                    type: "number",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "symbol-z-order": {
                    type: "enum",
                    values: {
                        auto: {},
                        "viewport-y": {},
                        source: {}
                    },
                    default: "auto",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-allow-overlap": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "icon-image",
                        {
                            "!": "icon-overlap"
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-overlap": {
                    type: "enum",
                    values: {
                        never: {},
                        always: {},
                        cooperative: {}
                    },
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-ignore-placement": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-optional": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "icon-image",
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-rotation-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        auto: {}
                    },
                    default: "auto",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-size": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    units: "factor of the original icon size",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-text-fit": {
                    type: "enum",
                    values: {
                        none: {},
                        width: {},
                        height: {},
                        both: {}
                    },
                    default: "none",
                    requires: [
                        "icon-image",
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-text-fit-padding": {
                    type: "array",
                    value: "number",
                    length: 4,
                    default: [
                        0,
                        0,
                        0,
                        0
                    ],
                    units: "pixels",
                    requires: [
                        "icon-image",
                        "text-field",
                        {
                            "icon-text-fit": [
                                "both",
                                "width",
                                "height"
                            ]
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-image": {
                    type: "resolvedImage",
                    tokens: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-rotate": {
                    type: "number",
                    default: 0,
                    period: 360,
                    units: "degrees",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-padding": {
                    type: "padding",
                    default: [
                        2
                    ],
                    units: "pixels",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-keep-upright": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "icon-image",
                        {
                            "icon-rotation-alignment": "map"
                        },
                        {
                            "symbol-placement": [
                                "line",
                                "line-center"
                            ]
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-offset": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-anchor": {
                    type: "enum",
                    values: {
                        center: {},
                        left: {},
                        right: {},
                        top: {},
                        bottom: {},
                        "top-left": {},
                        "top-right": {},
                        "bottom-left": {},
                        "bottom-right": {}
                    },
                    default: "center",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-pitch-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        auto: {}
                    },
                    default: "auto",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-pitch-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        auto: {}
                    },
                    default: "auto",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-rotation-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {},
                        "viewport-glyph": {},
                        auto: {}
                    },
                    default: "auto",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-field": {
                    type: "formatted",
                    default: "",
                    tokens: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-font": {
                    type: "array",
                    value: "string",
                    default: [
                        "Open Sans Regular",
                        "Arial Unicode MS Regular"
                    ],
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-size": {
                    type: "number",
                    default: 16,
                    minimum: 0,
                    units: "pixels",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-max-width": {
                    type: "number",
                    default: 10,
                    minimum: 0,
                    units: "ems",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-line-height": {
                    type: "number",
                    default: 1.2,
                    units: "ems",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-letter-spacing": {
                    type: "number",
                    default: 0,
                    units: "ems",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-justify": {
                    type: "enum",
                    values: {
                        auto: {},
                        left: {},
                        center: {},
                        right: {}
                    },
                    default: "center",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-radial-offset": {
                    type: "number",
                    units: "ems",
                    default: 0,
                    requires: [
                        "text-field"
                    ],
                    "property-type": "data-driven",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    }
                },
                "text-variable-anchor": {
                    type: "array",
                    value: "enum",
                    values: {
                        center: {},
                        left: {},
                        right: {},
                        top: {},
                        bottom: {},
                        "top-left": {},
                        "top-right": {},
                        "bottom-left": {},
                        "bottom-right": {}
                    },
                    requires: [
                        "text-field",
                        {
                            "symbol-placement": [
                                "point"
                            ]
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-anchor": {
                    type: "enum",
                    values: {
                        center: {},
                        left: {},
                        right: {},
                        top: {},
                        bottom: {},
                        "top-left": {},
                        "top-right": {},
                        "bottom-left": {},
                        "bottom-right": {}
                    },
                    default: "center",
                    requires: [
                        "text-field",
                        {
                            "!": "text-variable-anchor"
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-max-angle": {
                    type: "number",
                    default: 45,
                    units: "degrees",
                    requires: [
                        "text-field",
                        {
                            "symbol-placement": [
                                "line",
                                "line-center"
                            ]
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-writing-mode": {
                    type: "array",
                    value: "enum",
                    values: {
                        horizontal: {},
                        vertical: {}
                    },
                    requires: [
                        "text-field",
                        {
                            "symbol-placement": [
                                "point"
                            ]
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-rotate": {
                    type: "number",
                    default: 0,
                    period: 360,
                    units: "degrees",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-padding": {
                    type: "number",
                    default: 2,
                    minimum: 0,
                    units: "pixels",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-keep-upright": {
                    type: "boolean",
                    default: !0,
                    requires: [
                        "text-field",
                        {
                            "text-rotation-alignment": "map"
                        },
                        {
                            "symbol-placement": [
                                "line",
                                "line-center"
                            ]
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-transform": {
                    type: "enum",
                    values: {
                        none: {},
                        uppercase: {},
                        lowercase: {}
                    },
                    default: "none",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-offset": {
                    type: "array",
                    value: "number",
                    units: "ems",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    requires: [
                        "text-field",
                        {
                            "!": "text-radial-offset"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-allow-overlap": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "text-field",
                        {
                            "!": "text-overlap"
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-overlap": {
                    type: "enum",
                    values: {
                        never: {},
                        always: {},
                        cooperative: {}
                    },
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-ignore-placement": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-optional": {
                    type: "boolean",
                    default: !1,
                    requires: [
                        "text-field",
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_raster: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            layout_hillshade: {
                visibility: {
                    type: "enum",
                    values: {
                        visible: {},
                        none: {}
                    },
                    default: "visible",
                    "property-type": "constant"
                }
            },
            filter: {
                type: "array",
                value: "*"
            },
            filter_operator: {
                type: "enum",
                values: {
                    "==": {},
                    "!=": {},
                    ">": {},
                    ">=": {},
                    "<": {},
                    "<=": {},
                    in: {},
                    "!in": {},
                    all: {},
                    any: {},
                    none: {},
                    has: {},
                    "!has": {},
                    within: {}
                }
            },
            geometry_type: {
                type: "enum",
                values: {
                    Point: {},
                    LineString: {},
                    Polygon: {}
                }
            },
            function: {
                expression: {
                    type: "expression"
                },
                stops: {
                    type: "array",
                    value: "function_stop"
                },
                base: {
                    type: "number",
                    default: 1,
                    minimum: 0
                },
                property: {
                    type: "string",
                    default: "$zoom"
                },
                type: {
                    type: "enum",
                    values: {
                        identity: {},
                        exponential: {},
                        interval: {},
                        categorical: {}
                    },
                    default: "exponential"
                },
                colorSpace: {
                    type: "enum",
                    values: {
                        rgb: {},
                        lab: {},
                        hcl: {}
                    },
                    default: "rgb"
                },
                default: {
                    type: "*",
                    required: !1
                }
            },
            function_stop: {
                type: "array",
                minimum: 0,
                maximum: 24,
                value: [
                    "number",
                    "color"
                ],
                length: 2
            },
            expression: {
                type: "array",
                value: "*",
                minimum: 1
            },
            light: {
                anchor: {
                    type: "enum",
                    default: "viewport",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    "property-type": "data-constant",
                    transition: !1,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    }
                },
                position: {
                    type: "array",
                    default: [
                        1.15,
                        210,
                        30
                    ],
                    length: 3,
                    value: "number",
                    "property-type": "data-constant",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    }
                },
                color: {
                    type: "color",
                    "property-type": "data-constant",
                    default: "#ffffff",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    transition: !0
                },
                intensity: {
                    type: "number",
                    "property-type": "data-constant",
                    default: .5,
                    minimum: 0,
                    maximum: 1,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    transition: !0
                }
            },
            terrain: {
                source: {
                    type: "string",
                    required: !0
                },
                exaggeration: {
                    type: "number",
                    minimum: 0,
                    default: 1
                },
                elevationOffset: {
                    type: "number",
                    default: 450
                }
            },
            paint: [
                "paint_fill",
                "paint_line",
                "paint_circle",
                "paint_heatmap",
                "paint_fill-extrusion",
                "paint_symbol",
                "paint_raster",
                "paint_hillshade",
                "paint_background"
            ],
            paint_fill: {
                "fill-antialias": {
                    type: "boolean",
                    default: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "fill-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "fill-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [
                        {
                            "!": "fill-pattern"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "fill-outline-color": {
                    type: "color",
                    transition: !0,
                    requires: [
                        {
                            "!": "fill-pattern"
                        },
                        {
                            "fill-antialias": !0
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "fill-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "fill-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: [
                        "fill-translate"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "fill-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "cross-faded-data-driven"
                }
            },
            "paint_fill-extrusion": {
                "fill-extrusion-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "fill-extrusion-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [
                        {
                            "!": "fill-extrusion-pattern"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "fill-extrusion-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "fill-extrusion-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: [
                        "fill-extrusion-translate"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "fill-extrusion-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "cross-faded-data-driven"
                },
                "fill-extrusion-height": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    units: "meters",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "fill-extrusion-base": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    units: "meters",
                    transition: !0,
                    requires: [
                        "fill-extrusion-height"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "fill-extrusion-vertical-gradient": {
                    type: "boolean",
                    default: !0,
                    transition: !1,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_line: {
                "line-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [
                        {
                            "!": "line-pattern"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "line-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: [
                        "line-translate"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "line-width": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-gap-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-offset": {
                    type: "number",
                    default: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-blur": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "line-dasharray": {
                    type: "array",
                    value: "number",
                    minimum: 0,
                    transition: !0,
                    units: "line widths",
                    requires: [
                        {
                            "!": "line-pattern"
                        }
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "cross-faded"
                },
                "line-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "cross-faded-data-driven"
                },
                "line-gradient": {
                    type: "color",
                    transition: !1,
                    requires: [
                        {
                            "!": "line-dasharray"
                        },
                        {
                            "!": "line-pattern"
                        },
                        {
                            source: "geojson",
                            has: {
                                lineMetrics: !0
                            }
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "line-progress"
                        ]
                    },
                    "property-type": "color-ramp"
                }
            },
            paint_circle: {
                "circle-radius": {
                    type: "number",
                    default: 5,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "circle-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "circle-blur": {
                    type: "number",
                    default: 0,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "circle-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "circle-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "circle-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: [
                        "circle-translate"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "circle-pitch-scale": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "circle-pitch-alignment": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "viewport",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "circle-stroke-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "circle-stroke-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "circle-stroke-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                }
            },
            paint_heatmap: {
                "heatmap-radius": {
                    type: "number",
                    default: 30,
                    minimum: 1,
                    transition: !0,
                    units: "pixels",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "heatmap-weight": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "heatmap-intensity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "heatmap-color": {
                    type: "color",
                    default: [
                        "interpolate",
                        [
                            "linear"
                        ],
                        [
                            "heatmap-density"
                        ],
                        0,
                        "rgba(0, 0, 255, 0)",
                        .1,
                        "royalblue",
                        .3,
                        "cyan",
                        .5,
                        "lime",
                        .7,
                        "yellow",
                        1,
                        "red"
                    ],
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "heatmap-density"
                        ]
                    },
                    "property-type": "color-ramp"
                },
                "heatmap-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_symbol: {
                "icon-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-halo-color": {
                    type: "color",
                    default: "rgba(0, 0, 0, 0)",
                    transition: !0,
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-halo-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-halo-blur": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "icon-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    transition: !0,
                    units: "pixels",
                    requires: [
                        "icon-image"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "icon-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: [
                        "icon-image",
                        "icon-translate"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    overridable: !0,
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-halo-color": {
                    type: "color",
                    default: "rgba(0, 0, 0, 0)",
                    transition: !0,
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-halo-width": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-halo-blur": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    transition: !0,
                    units: "pixels",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom",
                            "feature",
                            "feature-state"
                        ]
                    },
                    "property-type": "data-driven"
                },
                "text-translate": {
                    type: "array",
                    value: "number",
                    length: 2,
                    default: [
                        0,
                        0
                    ],
                    transition: !0,
                    units: "pixels",
                    requires: [
                        "text-field"
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "text-translate-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "map",
                    requires: [
                        "text-field",
                        "text-translate"
                    ],
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_raster: {
                "raster-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-hue-rotate": {
                    type: "number",
                    default: 0,
                    period: 360,
                    transition: !0,
                    units: "degrees",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-brightness-min": {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-brightness-max": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-saturation": {
                    type: "number",
                    default: 0,
                    minimum: -1,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-contrast": {
                    type: "number",
                    default: 0,
                    minimum: -1,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-resampling": {
                    type: "enum",
                    values: {
                        linear: {},
                        nearest: {}
                    },
                    default: "linear",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "raster-fade-duration": {
                    type: "number",
                    default: 300,
                    minimum: 0,
                    transition: !1,
                    units: "milliseconds",
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_hillshade: {
                "hillshade-illumination-direction": {
                    type: "number",
                    default: 335,
                    minimum: 0,
                    maximum: 359,
                    transition: !1,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-illumination-anchor": {
                    type: "enum",
                    values: {
                        map: {},
                        viewport: {}
                    },
                    default: "viewport",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-exaggeration": {
                    type: "number",
                    default: .5,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-shadow-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-highlight-color": {
                    type: "color",
                    default: "#FFFFFF",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "hillshade-accent-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                }
            },
            paint_background: {
                "background-color": {
                    type: "color",
                    default: "#000000",
                    transition: !0,
                    requires: [
                        {
                            "!": "background-pattern"
                        }
                    ],
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                },
                "background-pattern": {
                    type: "resolvedImage",
                    transition: !0,
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "cross-faded"
                },
                "background-opacity": {
                    type: "number",
                    default: 1,
                    minimum: 0,
                    maximum: 1,
                    transition: !0,
                    expression: {
                        interpolated: !0,
                        parameters: [
                            "zoom"
                        ]
                    },
                    "property-type": "data-constant"
                }
            },
            transition: {
                duration: {
                    type: "number",
                    default: 300,
                    minimum: 0,
                    units: "milliseconds"
                },
                delay: {
                    type: "number",
                    default: 0,
                    minimum: 0,
                    units: "milliseconds"
                }
            },
            "property-type": {
                "data-driven": {
                    type: "property-type"
                },
                "cross-faded": {
                    type: "property-type"
                },
                "cross-faded-data-driven": {
                    type: "property-type"
                },
                "color-ramp": {
                    type: "property-type"
                },
                "data-constant": {
                    type: "property-type"
                },
                constant: {
                    type: "property-type"
                }
            },
            promoteId: {
                "*": {
                    type: "string"
                }
            }
        };
        class it {
            constructor(t1, e1, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e1 && e1.__line__ && (this.line = e1.__line__);
            }
        }
        function at(t1) {
            const e1 = t1.value;
            return e1 ? [
                new it(t1.key, e1, "constants have been deprecated as of v8")
            ] : [];
        }
        function st(t1, ...e1) {
            for (const r of e1)for(const e1 in r)t1[e1] = r[e1];
            return t1;
        }
        function ot(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function lt(t1) {
            if (Array.isArray(t1)) return t1.map(lt);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e1 = {};
                for(const r in t1)e1[r] = lt(t1[r]);
                return e1;
            }
            return ot(t1);
        }
        class ut extends Error {
            constructor(t1, e1){
                super(e1), this.message = e1, this.key = t1;
            }
        }
        class ct {
            constructor(t1, e1 = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e1)this.bindings[t1] = r;
            }
            concat(t1) {
                return new ct(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        const ht = {
            kind: "null"
        }, pt = {
            kind: "number"
        }, ft = {
            kind: "string"
        }, dt = {
            kind: "boolean"
        }, yt = {
            kind: "color"
        }, mt = {
            kind: "object"
        }, gt = {
            kind: "value"
        }, xt = {
            kind: "collator"
        }, vt = {
            kind: "formatted"
        }, bt = {
            kind: "padding"
        }, wt = {
            kind: "resolvedImage"
        };
        function _t(t1, e1) {
            return {
                kind: "array",
                itemType: t1,
                N: e1
            };
        }
        function At(t1) {
            if ("array" === t1.kind) {
                const e1 = At(t1.itemType);
                return "number" == typeof t1.N ? `array<${e1}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e1}>`;
            }
            return t1.kind;
        }
        const kt = [
            ht,
            pt,
            ft,
            dt,
            yt,
            vt,
            mt,
            _t(gt),
            bt,
            wt
        ];
        function St(t1, e1) {
            if ("error" === e1.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e1.kind && (0 === e1.N && "value" === e1.itemType.kind || !St(t1.itemType, e1.itemType)) && ("number" != typeof t1.N || t1.N === e1.N)) return null;
            } else {
                if (t1.kind === e1.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of kt)if (!St(t1, e1)) return null;
                }
            }
            return `Expected ${At(t1)} but found ${At(e1)} instead.`;
        }
        function It(t1, e1) {
            return e1.some((e1)=>e1.kind === t1.kind);
        }
        function Mt(t1, e1) {
            return e1.some((e1)=>"null" === e1 ? null === t1 : "array" === e1 ? Array.isArray(t1) : "object" === e1 ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e1 === typeof t1);
        }
        var zt, Bt = {
            transparent: [
                0,
                0,
                0,
                0
            ],
            aliceblue: [
                240,
                248,
                255,
                1
            ],
            antiquewhite: [
                250,
                235,
                215,
                1
            ],
            aqua: [
                0,
                255,
                255,
                1
            ],
            aquamarine: [
                127,
                255,
                212,
                1
            ],
            azure: [
                240,
                255,
                255,
                1
            ],
            beige: [
                245,
                245,
                220,
                1
            ],
            bisque: [
                255,
                228,
                196,
                1
            ],
            black: [
                0,
                0,
                0,
                1
            ],
            blanchedalmond: [
                255,
                235,
                205,
                1
            ],
            blue: [
                0,
                0,
                255,
                1
            ],
            blueviolet: [
                138,
                43,
                226,
                1
            ],
            brown: [
                165,
                42,
                42,
                1
            ],
            burlywood: [
                222,
                184,
                135,
                1
            ],
            cadetblue: [
                95,
                158,
                160,
                1
            ],
            chartreuse: [
                127,
                255,
                0,
                1
            ],
            chocolate: [
                210,
                105,
                30,
                1
            ],
            coral: [
                255,
                127,
                80,
                1
            ],
            cornflowerblue: [
                100,
                149,
                237,
                1
            ],
            cornsilk: [
                255,
                248,
                220,
                1
            ],
            crimson: [
                220,
                20,
                60,
                1
            ],
            cyan: [
                0,
                255,
                255,
                1
            ],
            darkblue: [
                0,
                0,
                139,
                1
            ],
            darkcyan: [
                0,
                139,
                139,
                1
            ],
            darkgoldenrod: [
                184,
                134,
                11,
                1
            ],
            darkgray: [
                169,
                169,
                169,
                1
            ],
            darkgreen: [
                0,
                100,
                0,
                1
            ],
            darkgrey: [
                169,
                169,
                169,
                1
            ],
            darkkhaki: [
                189,
                183,
                107,
                1
            ],
            darkmagenta: [
                139,
                0,
                139,
                1
            ],
            darkolivegreen: [
                85,
                107,
                47,
                1
            ],
            darkorange: [
                255,
                140,
                0,
                1
            ],
            darkorchid: [
                153,
                50,
                204,
                1
            ],
            darkred: [
                139,
                0,
                0,
                1
            ],
            darksalmon: [
                233,
                150,
                122,
                1
            ],
            darkseagreen: [
                143,
                188,
                143,
                1
            ],
            darkslateblue: [
                72,
                61,
                139,
                1
            ],
            darkslategray: [
                47,
                79,
                79,
                1
            ],
            darkslategrey: [
                47,
                79,
                79,
                1
            ],
            darkturquoise: [
                0,
                206,
                209,
                1
            ],
            darkviolet: [
                148,
                0,
                211,
                1
            ],
            deeppink: [
                255,
                20,
                147,
                1
            ],
            deepskyblue: [
                0,
                191,
                255,
                1
            ],
            dimgray: [
                105,
                105,
                105,
                1
            ],
            dimgrey: [
                105,
                105,
                105,
                1
            ],
            dodgerblue: [
                30,
                144,
                255,
                1
            ],
            firebrick: [
                178,
                34,
                34,
                1
            ],
            floralwhite: [
                255,
                250,
                240,
                1
            ],
            forestgreen: [
                34,
                139,
                34,
                1
            ],
            fuchsia: [
                255,
                0,
                255,
                1
            ],
            gainsboro: [
                220,
                220,
                220,
                1
            ],
            ghostwhite: [
                248,
                248,
                255,
                1
            ],
            gold: [
                255,
                215,
                0,
                1
            ],
            goldenrod: [
                218,
                165,
                32,
                1
            ],
            gray: [
                128,
                128,
                128,
                1
            ],
            green: [
                0,
                128,
                0,
                1
            ],
            greenyellow: [
                173,
                255,
                47,
                1
            ],
            grey: [
                128,
                128,
                128,
                1
            ],
            honeydew: [
                240,
                255,
                240,
                1
            ],
            hotpink: [
                255,
                105,
                180,
                1
            ],
            indianred: [
                205,
                92,
                92,
                1
            ],
            indigo: [
                75,
                0,
                130,
                1
            ],
            ivory: [
                255,
                255,
                240,
                1
            ],
            khaki: [
                240,
                230,
                140,
                1
            ],
            lavender: [
                230,
                230,
                250,
                1
            ],
            lavenderblush: [
                255,
                240,
                245,
                1
            ],
            lawngreen: [
                124,
                252,
                0,
                1
            ],
            lemonchiffon: [
                255,
                250,
                205,
                1
            ],
            lightblue: [
                173,
                216,
                230,
                1
            ],
            lightcoral: [
                240,
                128,
                128,
                1
            ],
            lightcyan: [
                224,
                255,
                255,
                1
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210,
                1
            ],
            lightgray: [
                211,
                211,
                211,
                1
            ],
            lightgreen: [
                144,
                238,
                144,
                1
            ],
            lightgrey: [
                211,
                211,
                211,
                1
            ],
            lightpink: [
                255,
                182,
                193,
                1
            ],
            lightsalmon: [
                255,
                160,
                122,
                1
            ],
            lightseagreen: [
                32,
                178,
                170,
                1
            ],
            lightskyblue: [
                135,
                206,
                250,
                1
            ],
            lightslategray: [
                119,
                136,
                153,
                1
            ],
            lightslategrey: [
                119,
                136,
                153,
                1
            ],
            lightsteelblue: [
                176,
                196,
                222,
                1
            ],
            lightyellow: [
                255,
                255,
                224,
                1
            ],
            lime: [
                0,
                255,
                0,
                1
            ],
            limegreen: [
                50,
                205,
                50,
                1
            ],
            linen: [
                250,
                240,
                230,
                1
            ],
            magenta: [
                255,
                0,
                255,
                1
            ],
            maroon: [
                128,
                0,
                0,
                1
            ],
            mediumaquamarine: [
                102,
                205,
                170,
                1
            ],
            mediumblue: [
                0,
                0,
                205,
                1
            ],
            mediumorchid: [
                186,
                85,
                211,
                1
            ],
            mediumpurple: [
                147,
                112,
                219,
                1
            ],
            mediumseagreen: [
                60,
                179,
                113,
                1
            ],
            mediumslateblue: [
                123,
                104,
                238,
                1
            ],
            mediumspringgreen: [
                0,
                250,
                154,
                1
            ],
            mediumturquoise: [
                72,
                209,
                204,
                1
            ],
            mediumvioletred: [
                199,
                21,
                133,
                1
            ],
            midnightblue: [
                25,
                25,
                112,
                1
            ],
            mintcream: [
                245,
                255,
                250,
                1
            ],
            mistyrose: [
                255,
                228,
                225,
                1
            ],
            moccasin: [
                255,
                228,
                181,
                1
            ],
            navajowhite: [
                255,
                222,
                173,
                1
            ],
            navy: [
                0,
                0,
                128,
                1
            ],
            oldlace: [
                253,
                245,
                230,
                1
            ],
            olive: [
                128,
                128,
                0,
                1
            ],
            olivedrab: [
                107,
                142,
                35,
                1
            ],
            orange: [
                255,
                165,
                0,
                1
            ],
            orangered: [
                255,
                69,
                0,
                1
            ],
            orchid: [
                218,
                112,
                214,
                1
            ],
            palegoldenrod: [
                238,
                232,
                170,
                1
            ],
            palegreen: [
                152,
                251,
                152,
                1
            ],
            paleturquoise: [
                175,
                238,
                238,
                1
            ],
            palevioletred: [
                219,
                112,
                147,
                1
            ],
            papayawhip: [
                255,
                239,
                213,
                1
            ],
            peachpuff: [
                255,
                218,
                185,
                1
            ],
            peru: [
                205,
                133,
                63,
                1
            ],
            pink: [
                255,
                192,
                203,
                1
            ],
            plum: [
                221,
                160,
                221,
                1
            ],
            powderblue: [
                176,
                224,
                230,
                1
            ],
            purple: [
                128,
                0,
                128,
                1
            ],
            rebeccapurple: [
                102,
                51,
                153,
                1
            ],
            red: [
                255,
                0,
                0,
                1
            ],
            rosybrown: [
                188,
                143,
                143,
                1
            ],
            royalblue: [
                65,
                105,
                225,
                1
            ],
            saddlebrown: [
                139,
                69,
                19,
                1
            ],
            salmon: [
                250,
                128,
                114,
                1
            ],
            sandybrown: [
                244,
                164,
                96,
                1
            ],
            seagreen: [
                46,
                139,
                87,
                1
            ],
            seashell: [
                255,
                245,
                238,
                1
            ],
            sienna: [
                160,
                82,
                45,
                1
            ],
            silver: [
                192,
                192,
                192,
                1
            ],
            skyblue: [
                135,
                206,
                235,
                1
            ],
            slateblue: [
                106,
                90,
                205,
                1
            ],
            slategray: [
                112,
                128,
                144,
                1
            ],
            slategrey: [
                112,
                128,
                144,
                1
            ],
            snow: [
                255,
                250,
                250,
                1
            ],
            springgreen: [
                0,
                255,
                127,
                1
            ],
            steelblue: [
                70,
                130,
                180,
                1
            ],
            tan: [
                210,
                180,
                140,
                1
            ],
            teal: [
                0,
                128,
                128,
                1
            ],
            thistle: [
                216,
                191,
                216,
                1
            ],
            tomato: [
                255,
                99,
                71,
                1
            ],
            turquoise: [
                64,
                224,
                208,
                1
            ],
            violet: [
                238,
                130,
                238,
                1
            ],
            wheat: [
                245,
                222,
                179,
                1
            ],
            white: [
                255,
                255,
                255,
                1
            ],
            whitesmoke: [
                245,
                245,
                245,
                1
            ],
            yellow: [
                255,
                255,
                0,
                1
            ],
            yellowgreen: [
                154,
                205,
                50,
                1
            ]
        };
        function Ct(t1) {
            return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
        }
        function Pt(t1) {
            return Ct("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
        }
        function Vt(t1) {
            var e1;
            return (e1 = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e1 > 1 ? 1 : e1;
        }
        function Et(t1, e1, r) {
            return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e1 - t1) * r * 6 : 2 * r < 1 ? e1 : 3 * r < 2 ? t1 + (e1 - t1) * (2 / 3 - r) * 6 : t1;
        }
        try {
            zt = ({}).parseCSSColor = function(t1) {
                var e1, r = t1.replace(/ /g, "").toLowerCase();
                if (r in Bt) return Bt[r].slice();
                if ("#" === r[0]) return 4 === r.length ? (e1 = parseInt(r.substr(1), 16)) >= 0 && e1 <= 4095 ? [
                    (3840 & e1) >> 4 | (3840 & e1) >> 8,
                    240 & e1 | (240 & e1) >> 4,
                    15 & e1 | (15 & e1) << 4,
                    1
                ] : null : 7 === r.length && (e1 = parseInt(r.substr(1), 16)) >= 0 && e1 <= 16777215 ? [
                    (16711680 & e1) >> 16,
                    (65280 & e1) >> 8,
                    255 & e1,
                    1
                ] : null;
                var n = r.indexOf("("), i = r.indexOf(")");
                if (-1 !== n && i + 1 === r.length) {
                    var a = r.substr(0, n), s = r.substr(n + 1, i - (n + 1)).split(","), o = 1;
                    switch(a){
                        case "rgba":
                            if (4 !== s.length) return null;
                            o = Vt(s.pop());
                        case "rgb":
                            return 3 !== s.length ? null : [
                                Pt(s[0]),
                                Pt(s[1]),
                                Pt(s[2]),
                                o
                            ];
                        case "hsla":
                            if (4 !== s.length) return null;
                            o = Vt(s.pop());
                        case "hsl":
                            if (3 !== s.length) return null;
                            var l = (parseFloat(s[0]) % 360 + 360) % 360 / 360, u = Vt(s[1]), c = Vt(s[2]), h = c <= .5 ? c * (u + 1) : c + u - c * u, p = 2 * c - h;
                            return [
                                Ct(255 * Et(p, h, l + 1 / 3)),
                                Ct(255 * Et(p, h, l)),
                                Ct(255 * Et(p, h, l - 1 / 3)),
                                o
                            ];
                        default:
                            return null;
                    }
                }
                return null;
            };
        } catch (t1) {}
        class Ft {
            constructor(t1, e1, r, n = 1){
                this.r = t1, this.g = e1, this.b = r, this.a = n;
            }
            static parse(t1) {
                if (!t1) return;
                if (t1 instanceof Ft) return t1;
                if ("string" != typeof t1) return;
                const e1 = zt(t1);
                return e1 ? new Ft(e1[0] / 255 * e1[3], e1[1] / 255 * e1[3], e1[2] / 255 * e1[3], e1[3]) : void 0;
            }
            toString() {
                const [t1, e1, r, n] = this.toArray();
                return `rgba(${Math.round(t1)},${Math.round(e1)},${Math.round(r)},${n})`;
            }
            toArray() {
                const { r: t1, g: e1, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * t1 / n,
                    255 * e1 / n,
                    255 * r / n,
                    n
                ];
            }
        }
        Ft.black = new Ft(0, 0, 0, 1), Ft.white = new Ft(1, 1, 1, 1), Ft.transparent = new Ft(0, 0, 0, 0), Ft.red = new Ft(1, 0, 0, 1);
        class Tt {
            constructor(t1, e1, r){
                this.sensitivity = t1 ? e1 ? "variant" : "case" : e1 ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e1) {
                return this.collator.compare(t1, e1);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class Lt {
            constructor(t1, e1, r, n, i){
                this.text = t1, this.image = e1, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class Dt {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new Dt([
                    new Lt(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || t1.image && 0 !== t1.image.name.length);
            }
            static factory(t1) {
                return t1 instanceof Dt ? t1 : Dt.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
        }
        class $t {
            constructor(t1){
                this.values = t1.slice();
            }
            static parse(t1) {
                if (t1 instanceof $t) return t1;
                if ("number" == typeof t1) return new $t([
                    t1,
                    t1,
                    t1,
                    t1
                ]);
                if (Array.isArray(t1) && !(t1.length < 1 || t1.length > 4)) {
                    for (const e1 of t1)if ("number" != typeof e1) return;
                    switch(t1.length){
                        case 1:
                            t1 = [
                                t1[0],
                                t1[0],
                                t1[0],
                                t1[0]
                            ];
                            break;
                        case 2:
                            t1 = [
                                t1[0],
                                t1[1],
                                t1[0],
                                t1[1]
                            ];
                            break;
                        case 3:
                            t1 = [
                                t1[0],
                                t1[1],
                                t1[2],
                                t1[1]
                            ];
                    }
                    return new $t(t1);
                }
            }
            toString() {
                return JSON.stringify(this.values);
            }
        }
        class Rt {
            constructor(t1){
                this.name = t1.name, this.available = t1.available;
            }
            toString() {
                return this.name;
            }
            static fromString(t1) {
                return t1 ? new Rt({
                    name: t1,
                    available: !1
                }) : null;
            }
        }
        function Ot(t1, e1, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e1 && e1 >= 0 && e1 <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e1,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e1,
                r,
                n
            ] : [
                t1,
                e1,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Ut(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof Ft) return !0;
            if (t1 instanceof Tt) return !0;
            if (t1 instanceof Dt) return !0;
            if (t1 instanceof $t) return !0;
            if (t1 instanceof Rt) return !0;
            if (Array.isArray(t1)) {
                for (const e1 of t1)if (!Ut(e1)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e1 in t1)if (!Ut(t1[e1])) return !1;
                return !0;
            }
            return !1;
        }
        function qt(t1) {
            if (null === t1) return ht;
            if ("string" == typeof t1) return ft;
            if ("boolean" == typeof t1) return dt;
            if ("number" == typeof t1) return pt;
            if (t1 instanceof Ft) return yt;
            if (t1 instanceof Tt) return xt;
            if (t1 instanceof Dt) return vt;
            if (t1 instanceof $t) return bt;
            if (t1 instanceof Rt) return wt;
            if (Array.isArray(t1)) {
                const e1 = t1.length;
                let r;
                for (const e1 of t1){
                    const t1 = qt(e1);
                    if (r) {
                        if (r === t1) continue;
                        r = gt;
                        break;
                    }
                    r = t1;
                }
                return _t(r || gt, e1);
            }
            return mt;
        }
        function jt(t1) {
            const e1 = typeof t1;
            return null === t1 ? "" : "string" === e1 || "number" === e1 || "boolean" === e1 ? String(t1) : t1 instanceof Ft || t1 instanceof Dt || t1 instanceof $t || t1 instanceof Rt ? t1.toString() : JSON.stringify(t1);
        }
        class Nt {
            constructor(t1, e1){
                this.type = t1, this.value = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!Ut(t1[1])) return e1.error("invalid value");
                const r = t1[1];
                let n = qt(r);
                const i = e1.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new Nt(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
        }
        class Zt {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        }
        const Kt = {
            string: ft,
            number: pt,
            boolean: dt,
            object: mt
        };
        class Gt {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, a;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in Kt) || "object" === r) return e1.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = Kt[r], n++;
                    } else i = gt;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e1.error('The length argument to "array" must be a positive integer literal', 2);
                        a = t1[2], n++;
                    }
                    r = _t(i, a);
                } else {
                    if (!Kt[i]) throw new Error(`Types doesn't contain name = ${i}`);
                    r = Kt[i];
                }
                const a = [];
                for(; n < t1.length; n++){
                    const r = e1.parse(t1[n], n, gt);
                    if (!r) return null;
                    a.push(r);
                }
                return new Gt(r, a);
            }
            evaluate(t1) {
                for(let e1 = 0; e1 < this.args.length; e1++){
                    const r = this.args[e1].evaluate(t1);
                    if (!St(this.type, qt(r))) return r;
                    if (e1 === this.args.length - 1) throw new Zt(`Expected value to be of type ${At(this.type)}, but found ${At(qt(r))} instead.`);
                }
                throw new Error;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
        }
        const Jt = {
            "to-boolean": dt,
            "to-color": yt,
            "to-number": pt,
            "to-string": ft
        };
        class Xt {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                const r = t1[0];
                if (!Jt[r]) throw new Error(`Can't parse ${r} as it is not part of the known types`);
                if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e1.error("Expected one argument.");
                const n = Jt[r], i = [];
                for(let r = 1; r < t1.length; r++){
                    const n = e1.parse(t1[r], r, gt);
                    if (!n) return null;
                    i.push(n);
                }
                return new Xt(n, i);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e1, r;
                    for (const n of this.args){
                        if (e1 = n.evaluate(t1), r = null, e1 instanceof Ft) return e1;
                        if ("string" == typeof e1) {
                            const r = t1.parseColor(e1);
                            if (r) return r;
                        } else if (Array.isArray(e1) && (r = e1.length < 3 || e1.length > 4 ? `Invalid rbga value ${JSON.stringify(e1)}: expected an array containing either three or four numeric values.` : Ot(e1[0], e1[1], e1[2], e1[3]), !r)) return new Ft(e1[0] / 255, e1[1] / 255, e1[2] / 255, e1[3]);
                    }
                    throw new Zt(r || `Could not parse color from value '${"string" == typeof e1 ? e1 : JSON.stringify(e1)}'`);
                }
                if ("padding" === this.type.kind) {
                    let e1;
                    for (const r of this.args){
                        e1 = r.evaluate(t1);
                        const n = $t.parse(e1);
                        if (n) return n;
                    }
                    throw new Zt(`Could not parse padding from value '${"string" == typeof e1 ? e1 : JSON.stringify(e1)}'`);
                }
                if ("number" === this.type.kind) {
                    let e1 = null;
                    for (const r of this.args){
                        if (e1 = r.evaluate(t1), null === e1) return 0;
                        const n = Number(e1);
                        if (!isNaN(n)) return n;
                    }
                    throw new Zt(`Could not convert ${JSON.stringify(e1)} to number.`);
                }
                return "formatted" === this.type.kind ? Dt.fromString(jt(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? Rt.fromString(jt(this.args[0].evaluate(t1))) : jt(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
        }
        const Yt = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class Ht {
            constructor(){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
                return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Yt[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            parseColor(t1) {
                let e1 = this._parseColorCache[t1];
                return e1 || (e1 = this._parseColorCache[t1] = Ft.parse(t1)), e1;
            }
        }
        class Wt {
            constructor(t1, e1, r, n){
                this.name = t1, this.type = e1, this._evaluate = r, this.args = n;
            }
            evaluate(t1) {
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            static parse(t1, e1) {
                const r = t1[0], n = Wt.definitions[r];
                if (!n) return e1.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, a = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, s = a.filter(([e1])=>!Array.isArray(e1) || e1.length === t1.length - 1);
                let o = null;
                for (const [n, a] of s){
                    o = new we(e1.registry, e1.path, null, e1.scope);
                    const s = [];
                    let l = !1;
                    for(let e1 = 1; e1 < t1.length; e1++){
                        const r = t1[e1], i = Array.isArray(n) ? n[e1 - 1] : n.type, a = o.parse(r, 1 + s.length, i);
                        if (!a) {
                            l = !0;
                            break;
                        }
                        s.push(a);
                    }
                    if (!l) {
                        if (Array.isArray(n) && n.length !== s.length) o.error(`Expected ${n.length} arguments, but found ${s.length} instead.`);
                        else {
                            for(let t1 = 0; t1 < s.length; t1++){
                                const e1 = Array.isArray(n) ? n[t1] : n.type, r = s[t1];
                                o.concat(t1 + 1).checkSubtype(e1, r.type);
                            }
                            if (0 === o.errors.length) return new Wt(r, i, a, s);
                        }
                    }
                }
                if (1 === s.length) e1.errors.push(...o.errors);
                else {
                    const r = (s.length ? s : a).map(([t1])=>{
                        var e1;
                        return e1 = t1, Array.isArray(e1) ? `(${e1.map(At).join(", ")})` : `(${At(e1.type)}...)`;
                    }).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e1.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(At(i.type));
                    }
                    e1.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e1) {
                Wt.definitions = e1;
                for(const r in e1)t1[r] = Wt;
            }
        }
        class Qt {
            constructor(t1, e1, r){
                this.type = xt, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e1.error("Collator options argument must be an object.");
                const n = e1.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, dt);
                if (!n) return null;
                const i = e1.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, dt);
                if (!i) return null;
                let a = null;
                return r.locale && (a = e1.parse(r.locale, 1, ft), !a) ? null : new Qt(n, i, a);
            }
            evaluate(t1) {
                return new Tt(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
        }
        const te = 8192;
        function ee(t1, e1) {
            t1[0] = Math.min(t1[0], e1[0]), t1[1] = Math.min(t1[1], e1[1]), t1[2] = Math.max(t1[2], e1[0]), t1[3] = Math.max(t1[3], e1[1]);
        }
        function re(t1, e1) {
            return !(t1[0] <= e1[0] || t1[2] >= e1[2] || t1[1] <= e1[1] || t1[3] >= e1[3]);
        }
        function ne(t1, e1) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e1.z);
            return [
                Math.round(r * i * te),
                Math.round(n * i * te)
            ];
        }
        function ie(t1, e1, r) {
            const n = t1[0] - e1[0], i = t1[1] - e1[1], a = t1[0] - r[0], s = t1[1] - r[1];
            return n * s - a * i == 0 && n * a <= 0 && i * s <= 0;
        }
        function ae(t1, e1) {
            let r = !1;
            for(let s = 0, o = e1.length; s < o; s++){
                const o = e1[s];
                for(let e1 = 0, s = o.length; e1 < s - 1; e1++){
                    if (ie(t1, o[e1], o[e1 + 1])) return !1;
                    (i = o[e1])[1] > (n = t1)[1] != (a = o[e1 + 1])[1] > n[1] && n[0] < (a[0] - i[0]) * (n[1] - i[1]) / (a[1] - i[1]) + i[0] && (r = !r);
                }
            }
            var n, i, a;
            return r;
        }
        function se(t1, e1) {
            for(let r = 0; r < e1.length; r++)if (ae(t1, e1[r])) return !0;
            return !1;
        }
        function oe(t1, e1, r, n) {
            const i = n[0] - r[0], a = n[1] - r[1], s = (t1[0] - r[0]) * a - i * (t1[1] - r[1]), o = (e1[0] - r[0]) * a - i * (e1[1] - r[1]);
            return s > 0 && o < 0 || s < 0 && o > 0;
        }
        function le(t1, e1, r) {
            for (const u of r)for(let r = 0; r < u.length - 1; ++r)if (0 != (o = [
                (s = u[r + 1])[0] - (a = u[r])[0],
                s[1] - a[1]
            ])[0] * (l = [
                (i = e1)[0] - (n = t1)[0],
                i[1] - n[1]
            ])[1] - o[1] * l[0] && oe(n, i, a, s) && oe(a, s, n, i)) return !0;
            var n, i, a, s, o, l;
            return !1;
        }
        function ue(t1, e1) {
            for(let r = 0; r < t1.length; ++r)if (!ae(t1[r], e1)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (le(t1[r], t1[r + 1], e1)) return !1;
            return !0;
        }
        function ce(t1, e1) {
            for(let r = 0; r < e1.length; r++)if (ue(t1, e1[r])) return !0;
            return !1;
        }
        function he(t1, e1, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const a = [];
                for(let n = 0; n < t1[i].length; n++){
                    const s = ne(t1[i][n], r);
                    ee(e1, s), a.push(s);
                }
                n.push(a);
            }
            return n;
        }
        function pe(t1, e1, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const a = he(t1[i], e1, r);
                n.push(a);
            }
            return n;
        }
        function fe(t1, e1, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e1 = .5 * n;
                let i = t1[0] - r[0] > e1 ? -n : r[0] - t1[0] > e1 ? n : 0;
                0 === i && (i = t1[0] - r[2] > e1 ? -n : r[2] - t1[0] > e1 ? n : 0), t1[0] += i;
            }
            ee(e1, t1);
        }
        function de(t1, e1, r, n) {
            const i = Math.pow(2, n.z) * te, a = [
                n.x * te,
                n.y * te
            ], s = [];
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + a[0],
                    t1.y + a[1]
                ];
                fe(n, e1, r, i), s.push(n);
            }
            return s;
        }
        function ye(t1, e1, r, n) {
            const i = Math.pow(2, n.z) * te, a = [
                n.x * te,
                n.y * te
            ], s = [];
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + a[0],
                        n.y + a[1]
                    ];
                    ee(e1, r), t1.push(r);
                }
                s.push(t1);
            }
            if (e1[2] - e1[0] <= i / 2) {
                (o = e1)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
                for (const t1 of s)for (const n of t1)fe(n, e1, r, i);
            }
            var o;
            return s;
        }
        class me {
            constructor(t1, e1){
                this.type = dt, this.geojson = t1, this.geometries = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (Ut(t1[1])) {
                    const e1 = t1[1];
                    if ("FeatureCollection" === e1.type) for(let t1 = 0; t1 < e1.features.length; ++t1){
                        const r = e1.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new me(e1, e1.features[t1].geometry);
                    }
                    else if ("Feature" === e1.type) {
                        const t1 = e1.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new me(e1, e1.geometry);
                    } else if ("Polygon" === e1.type || "MultiPolygon" === e1.type) return new me(e1, e1);
                }
                return e1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e1) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if ("Polygon" === e1.type) {
                            const a = he(e1.coordinates, n, i), s = de(t1.geometry(), r, n, i);
                            if (!re(r, n)) return !1;
                            for (const t1 of s)if (!ae(t1, a)) return !1;
                        }
                        if ("MultiPolygon" === e1.type) {
                            const a = pe(e1.coordinates, n, i), s = de(t1.geometry(), r, n, i);
                            if (!re(r, n)) return !1;
                            for (const t1 of s)if (!se(t1, a)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e1) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if ("Polygon" === e1.type) {
                            const a = he(e1.coordinates, n, i), s = ye(t1.geometry(), r, n, i);
                            if (!re(r, n)) return !1;
                            for (const t1 of s)if (!ue(t1, a)) return !1;
                        }
                        if ("MultiPolygon" === e1.type) {
                            const a = pe(e1.coordinates, n, i), s = ye(t1.geometry(), r, n, i);
                            if (!re(r, n)) return !1;
                            for (const t1 of s)if (!ce(t1, a)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
        }
        function ge(t1) {
            if (t1 instanceof Wt) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof me) return !1;
            let e1 = !0;
            return t1.eachChild((t1)=>{
                e1 && !ge(t1) && (e1 = !1);
            }), e1;
        }
        function xe(t1) {
            if (t1 instanceof Wt && "feature-state" === t1.name) return !1;
            let e1 = !0;
            return t1.eachChild((t1)=>{
                e1 && !xe(t1) && (e1 = !1);
            }), e1;
        }
        function ve(t1, e1) {
            if (t1 instanceof Wt && e1.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !ve(t1, e1) && (r = !1);
            }), r;
        }
        class be {
            constructor(t1, e1){
                this.type = e1.type, this.name = t1, this.boundExpression = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e1.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e1.scope.has(r) ? new be(r, e1.scope.get(r)) : e1.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
        }
        class we {
            constructor(t1, e1 = [], r, n = new ct, i = []){
                this.registry = t1, this.path = e1, this.key = e1.map((t1)=>`[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r;
            }
            parse(t1, e1, r, n, i = {}) {
                return e1 ? this.concat(e1, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            _parse(t1, e1) {
                function r(t1, e1, r) {
                    return "assert" === r ? new Gt(e1, [
                        t1
                    ]) : "coerce" === r ? new Xt(e1, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = t1[0];
                    if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                    const i = this.registry[n];
                    if (i) {
                        let n = i.parse(t1, this);
                        if (!n) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, i = n.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== i.kind) {
                                if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== i.kind && "string" !== i.kind) {
                                    if ("padding" !== t1.kind || "value" !== i.kind && "number" !== i.kind && "array" !== i.kind) {
                                        if (this.checkSubtype(t1, i)) return null;
                                    } else n = r(n, t1, e1.typeAnnotation || "coerce");
                                } else n = r(n, t1, e1.typeAnnotation || "coerce");
                            } else n = r(n, t1, e1.typeAnnotation || "assert");
                        }
                        if (!(n instanceof Nt) && "resolvedImage" !== n.type.kind && _e(n)) {
                            const t1 = new Ht;
                            try {
                                n = new Nt(n.type, n.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return n;
                    }
                    return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e1, r) {
                const n = "number" == typeof t1 ? this.path.concat(t1) : this.path, i = r ? this.scope.concat(r) : this.scope;
                return new we(this.registry, n, e1 || null, i, this.errors);
            }
            error(t1, ...e1) {
                const r = `${this.key}${e1.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new ut(r, t1));
            }
            checkSubtype(t1, e1) {
                const r = St(t1, e1);
                return r && this.error(r), r;
            }
        }
        function _e(t1) {
            if (t1 instanceof be) return _e(t1.boundExpression);
            if (t1 instanceof Wt && "error" === t1.name) return !1;
            if (t1 instanceof Qt) return !1;
            if (t1 instanceof me) return !1;
            const e1 = t1 instanceof Xt || t1 instanceof Gt;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e1 ? r && _e(t1) : r && t1 instanceof Nt;
            }), !!r && ge(t1) && ve(t1, [
                "zoom",
                "heatmap-density",
                "line-progress",
                "accumulated",
                "is-supported-script"
            ]);
        }
        function Ae(t1, e1) {
            const r = t1.length - 1;
            let n, i, a = 0, s = r, o = 0;
            for(; a <= s;)if (o = Math.floor((a + s) / 2), n = t1[o], i = t1[o + 1], n <= e1) {
                if (o === r || e1 < i) return o;
                a = o + 1;
            } else {
                if (!(n > e1)) throw new Zt("Input is not a number.");
                s = o - 1;
            }
            return 0;
        }
        class ke {
            constructor(t1, e1, r){
                this.type = t1, this.input = e1, this.labels = [], this.outputs = [];
                for (const [t1, e1] of r)this.labels.push(t1), this.outputs.push(e1);
            }
            static parse(t1, e1) {
                if (t1.length - 1 < 4) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e1.error("Expected an even number of arguments.");
                const r = e1.parse(t1[1], 1, pt);
                if (!r) return null;
                const n = [];
                let i = null;
                e1.expectedType && "value" !== e1.expectedType.kind && (i = e1.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const a = 1 === r ? -1 / 0 : t1[r], s = t1[r + 1], o = r, l = r + 1;
                    if ("number" != typeof a) return e1.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= a) return e1.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e1.parse(s, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        a,
                        u
                    ]);
                }
                return new ke(i, r, n);
            }
            evaluate(t1) {
                const e1 = this.labels, r = this.outputs;
                if (1 === e1.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e1[0]) return r[0].evaluate(t1);
                const i = e1.length;
                return n >= e1[i - 1] ? r[i - 1].evaluate(t1) : r[Ae(e1, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e1 of this.outputs)t1(e1);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
        }
        function Se(t1, e1, r) {
            return t1 * (1 - r) + e1 * r;
        }
        var Ie = Object.freeze({
            __proto__: null,
            number: Se,
            color: function(t1, e1, r) {
                return new Ft(Se(t1.r, e1.r, r), Se(t1.g, e1.g, r), Se(t1.b, e1.b, r), Se(t1.a, e1.a, r));
            },
            array: function(t1, e1, r) {
                return t1.map((t1, n)=>Se(t1, e1[n], r));
            },
            padding: function(t1, e1, r) {
                const n = t1.values, i = e1.values;
                return new $t([
                    Se(n[0], i[0], r),
                    Se(n[1], i[1], r),
                    Se(n[2], i[2], r),
                    Se(n[3], i[3], r)
                ]);
            }
        });
        const Me = .95047, ze = 1.08883, Be = 4 / 29, Ce = 6 / 29, Pe = 3 * Ce * Ce, Ve = Math.PI / 180, Ee = 180 / Math.PI;
        function Fe(t1) {
            return t1 > .008856451679035631 ? Math.pow(t1, 1 / 3) : t1 / Pe + Be;
        }
        function Te(t1) {
            return t1 > Ce ? t1 * t1 * t1 : Pe * (t1 - Be);
        }
        function Le(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function De(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function $e(t1) {
            const e1 = De(t1.r), r = De(t1.g), n = De(t1.b), i = Fe((.4124564 * e1 + .3575761 * r + .1804375 * n) / Me), a = Fe((.2126729 * e1 + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * a - 16,
                a: 500 * (i - a),
                b: 200 * (a - Fe((.0193339 * e1 + .119192 * r + .9503041 * n) / ze)),
                alpha: t1.a
            };
        }
        function Re(t1) {
            let e1 = (t1.l + 16) / 116, r = isNaN(t1.a) ? e1 : e1 + t1.a / 500, n = isNaN(t1.b) ? e1 : e1 - t1.b / 200;
            return e1 = 1 * Te(e1), r = Me * Te(r), n = ze * Te(n), new Ft(Le(3.2404542 * r - 1.5371385 * e1 - .4985314 * n), Le(-0.969266 * r + 1.8760108 * e1 + .041556 * n), Le(.0556434 * r - .2040259 * e1 + 1.0572252 * n), t1.alpha);
        }
        function Oe(t1, e1, r) {
            const n = e1 - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const Ue = {
            forward: $e,
            reverse: Re,
            interpolate: function(t1, e1, r) {
                return {
                    l: Se(t1.l, e1.l, r),
                    a: Se(t1.a, e1.a, r),
                    b: Se(t1.b, e1.b, r),
                    alpha: Se(t1.alpha, e1.alpha, r)
                };
            }
        }, qe = {
            forward: function(t1) {
                const { l: e1, a: r, b: n } = $e(t1), i = Math.atan2(n, r) * Ee;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e1,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e1 = t1.h * Ve, r = t1.c;
                return Re({
                    l: t1.l,
                    a: Math.cos(e1) * r,
                    b: Math.sin(e1) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e1, r) {
                return {
                    h: Oe(t1.h, e1.h, r),
                    c: Se(t1.c, e1.c, r),
                    l: Se(t1.l, e1.l, r),
                    alpha: Se(t1.alpha, e1.alpha, r)
                };
            }
        };
        var je = Object.freeze({
            __proto__: null,
            lab: Ue,
            hcl: qe
        });
        class Ne {
            constructor(t1, e1, r, n, i){
                this.type = t1, this.operator = e1, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
                for (const [t1, e1] of i)this.labels.push(t1), this.outputs.push(e1);
            }
            static interpolationFactor(t1, r, n, i) {
                let a = 0;
                if ("exponential" === t1.name) a = Ze(r, t1.base, n, i);
                else if ("linear" === t1.name) a = Ze(r, 1, n, i);
                else if ("cubic-bezier" === t1.name) {
                    const s = t1.controlPoints;
                    a = new e1(s[0], s[1], s[2], s[3]).solve(Ze(r, 1, n, i));
                }
                return a;
            }
            static parse(t1, e1) {
                let [r, n, i, ...a] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e1.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e1.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e1.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 4) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e1.error("Expected an even number of arguments.");
                if (i = e1.parse(i, 2, pt), !i) return null;
                const s = [];
                let o = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? o = yt : e1.expectedType && "value" !== e1.expectedType.kind && (o = e1.expectedType);
                for(let t1 = 0; t1 < a.length; t1 += 2){
                    const r = a[t1], n = a[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e1.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (s.length && s[s.length - 1][0] >= r) return e1.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e1.parse(n, l, o);
                    if (!u) return null;
                    o = o || u.type, s.push([
                        r,
                        u
                    ]);
                }
                return "number" === o.kind || "color" === o.kind || "padding" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Ne(o, r, n, i, s) : e1.error(`Type ${At(o)} is not interpolatable.`);
            }
            evaluate(t1) {
                const e1 = this.labels, r = this.outputs;
                if (1 === e1.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e1[0]) return r[0].evaluate(t1);
                const i = e1.length;
                if (n >= e1[i - 1]) return r[i - 1].evaluate(t1);
                const a = Ae(e1, n), s = Ne.interpolationFactor(this.interpolation, n, e1[a], e1[a + 1]), o = r[a].evaluate(t1), l = r[a + 1].evaluate(t1);
                return "interpolate" === this.operator ? Ie[this.type.kind.toLowerCase()](o, l, s) : "interpolate-hcl" === this.operator ? qe.reverse(qe.interpolate(qe.forward(o), qe.forward(l), s)) : Ue.reverse(Ue.interpolate(Ue.forward(o), Ue.forward(l), s));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e1 of this.outputs)t1(e1);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
        }
        function Ze(t1, e1, r, n) {
            const i = n - r, a = t1 - r;
            return 0 === i ? 0 : 1 === e1 ? a / i : (Math.pow(e1, a) - 1) / (Math.pow(e1, i) - 1);
        }
        class Ke {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expectected at least one argument.");
                let r = null;
                const n = e1.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e1.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                if (!r) throw new Error("No output type");
                const a = n && i.some((t1)=>St(n, t1.type));
                return new Ke(a ? gt : r, i);
            }
            evaluate(t1) {
                let e1, r = null, n = 0;
                for (const i of this.args)if (n++, r = i.evaluate(t1), r && r instanceof Rt && !r.available && (e1 || (e1 = r.name), r = null, n === this.args.length && (r = e1)), null !== r) break;
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
        }
        class Ge {
            constructor(t1, e1){
                this.type = e1.type, this.bindings = [].concat(t1), this.result = e1;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e1 of this.bindings)t1(e1[1]);
                t1(this.result);
            }
            static parse(t1, e1) {
                if (t1.length < 4) return e1.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e1.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e1.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const a = e1.parse(t1[n + 1], n + 1);
                    if (!a) return null;
                    r.push([
                        i,
                        a
                    ]);
                }
                const n = e1.parse(t1[t1.length - 1], t1.length - 1, e1.expectedType, r);
                return n ? new Ge(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
        }
        class Je {
            constructor(t1, e1, r){
                this.type = t1, this.index = e1, this.input = r;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, pt), n = e1.parse(t1[2], 2, _t(e1.expectedType || gt));
                return r && n ? new Je(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e1 = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e1 < 0) throw new Zt(`Array index out of bounds: ${e1} < 0.`);
                if (e1 >= r.length) throw new Zt(`Array index out of bounds: ${e1} > ${r.length - 1}.`);
                if (e1 !== Math.floor(e1)) throw new Zt(`Array index must be an integer, but found ${e1} instead.`);
                return r[e1];
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
        }
        class Xe {
            constructor(t1, e1){
                this.type = dt, this.needle = t1, this.haystack = e1;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, gt), n = e1.parse(t1[2], 2, gt);
                return r && n ? It(r.type, [
                    dt,
                    ft,
                    pt,
                    ht,
                    gt
                ]) ? new Xe(r, n) : e1.error(`Expected first argument to be of type boolean, string, number or null, but found ${At(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e1 = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!r) return !1;
                if (!Mt(e1, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Zt(`Expected first argument to be of type boolean, string, number or null, but found ${At(qt(e1))} instead.`);
                if (!Mt(r, [
                    "string",
                    "array"
                ])) throw new Zt(`Expected second argument to be of type array or string, but found ${At(qt(r))} instead.`);
                return r.indexOf(e1) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
        }
        class Ye {
            constructor(t1, e1, r){
                this.type = pt, this.needle = t1, this.haystack = e1, this.fromIndex = r;
            }
            static parse(t1, e1) {
                if (t1.length <= 2 || t1.length >= 5) return e1.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, gt), n = e1.parse(t1[2], 2, gt);
                if (!r || !n) return null;
                if (!It(r.type, [
                    dt,
                    ft,
                    pt,
                    ht,
                    gt
                ])) return e1.error(`Expected first argument to be of type boolean, string, number or null, but found ${At(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e1.parse(t1[3], 3, pt);
                    return i ? new Ye(r, n, i) : null;
                }
                return new Ye(r, n);
            }
            evaluate(t1) {
                const e1 = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!Mt(e1, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Zt(`Expected first argument to be of type boolean, string, number or null, but found ${At(qt(e1))} instead.`);
                if (!Mt(r, [
                    "string",
                    "array"
                ])) throw new Zt(`Expected second argument to be of type array or string, but found ${At(qt(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e1, n);
                }
                return r.indexOf(e1);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
        }
        class He {
            constructor(t1, e1, r, n, i, a){
                this.inputType = t1, this.type = e1, this.input = r, this.cases = n, this.outputs = i, this.otherwise = a;
            }
            static parse(t1, e1) {
                if (t1.length < 5) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e1.error("Expected an even number of arguments.");
                let r, n;
                e1.expectedType && "value" !== e1.expectedType.kind && (n = e1.expectedType);
                const i = {}, a = [];
                for(let s = 2; s < t1.length - 1; s += 2){
                    let o = t1[s];
                    const l = t1[s + 1];
                    Array.isArray(o) || (o = [
                        o
                    ]);
                    const u = e1.concat(s);
                    if (0 === o.length) return u.error("Expected at least one branch label.");
                    for (const t1 of o){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, qt(t1))) return null;
                        } else r = qt(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = a.length;
                    }
                    const c = e1.parse(l, s, n);
                    if (!c) return null;
                    n = n || c.type, a.push(c);
                }
                const s = e1.parse(t1[1], 1, gt);
                if (!s) return null;
                const o = e1.parse(t1[t1.length - 1], t1.length - 1, n);
                return o ? "value" !== s.type.kind && e1.concat(1).checkSubtype(r, s.type) ? null : new He(r, n, s, i, a, o) : null;
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1);
                return (qt(e1) === this.inputType && this.outputs[this.cases[e1]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
        }
        class We {
            constructor(t1, e1, r){
                this.type = t1, this.branches = e1, this.otherwise = r;
            }
            static parse(t1, e1) {
                if (t1.length < 4) return e1.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e1.error("Expected an odd number of arguments.");
                let r;
                e1.expectedType && "value" !== e1.expectedType.kind && (r = e1.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const a = e1.parse(t1[i], i, dt);
                    if (!a) return null;
                    const s = e1.parse(t1[i + 1], i + 1, r);
                    if (!s) return null;
                    n.push([
                        a,
                        s
                    ]), r = r || s.type;
                }
                const i = e1.parse(t1[t1.length - 1], t1.length - 1, r);
                if (!i) return null;
                if (!r) throw new Error("Can't infer output type");
                return new We(r, n, i);
            }
            evaluate(t1) {
                for (const [e1, r] of this.branches)if (e1.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e1, r] of this.branches)t1(e1), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e1])=>e1.outputDefined()) && this.otherwise.outputDefined();
            }
        }
        class Qe {
            constructor(t1, e1, r, n){
                this.type = t1, this.input = e1, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e1) {
                if (t1.length <= 2 || t1.length >= 5) return e1.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, gt), n = e1.parse(t1[2], 2, pt);
                if (!r || !n) return null;
                if (!It(r.type, [
                    _t(gt),
                    ft,
                    gt
                ])) return e1.error(`Expected first argument to be of type array or string, but found ${At(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e1.parse(t1[3], 3, pt);
                    return i ? new Qe(r.type, r, n, i) : null;
                }
                return new Qe(r.type, r, n);
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!Mt(e1, [
                    "string",
                    "array"
                ])) throw new Zt(`Expected first argument to be of type array or string, but found ${At(qt(e1))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e1.slice(r, n);
                }
                return e1.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
        }
        function tr(t1, e1) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e1.kind || "string" === e1.kind || "number" === e1.kind || "null" === e1.kind || "value" === e1.kind : "string" === e1.kind || "number" === e1.kind || "value" === e1.kind;
        }
        function er(t1, e1, r, n) {
            return 0 === n.compare(e1, r);
        }
        function rr(t1, e1, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e1, r){
                    this.type = dt, this.lhs = t1, this.rhs = e1, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e1.type.kind;
                }
                static parse(t1, e1) {
                    if (3 !== t1.length && 4 !== t1.length) return e1.error("Expected two or three arguments.");
                    const r = t1[0];
                    let a = e1.parse(t1[1], 1, gt);
                    if (!a) return null;
                    if (!tr(r, a.type)) return e1.concat(1).error(`"${r}" comparisons are not supported for type '${At(a.type)}'.`);
                    let s = e1.parse(t1[2], 2, gt);
                    if (!s) return null;
                    if (!tr(r, s.type)) return e1.concat(2).error(`"${r}" comparisons are not supported for type '${At(s.type)}'.`);
                    if (a.type.kind !== s.type.kind && "value" !== a.type.kind && "value" !== s.type.kind) return e1.error(`Cannot compare types '${At(a.type)}' and '${At(s.type)}'.`);
                    n && ("value" === a.type.kind && "value" !== s.type.kind ? a = new Gt(s.type, [
                        a
                    ]) : "value" !== a.type.kind && "value" === s.type.kind && (s = new Gt(a.type, [
                        s
                    ])));
                    let o = null;
                    if (4 === t1.length) {
                        if ("string" !== a.type.kind && "string" !== s.type.kind && "value" !== a.type.kind && "value" !== s.type.kind) return e1.error("Cannot use collator to compare non-string types.");
                        if (o = e1.parse(t1[3], 3, xt), !o) return null;
                    }
                    return new i(a, s, o);
                }
                evaluate(i) {
                    const a = this.lhs.evaluate(i), s = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e1 = qt(a), r = qt(s);
                        if (e1.kind !== r.kind || "string" !== e1.kind && "number" !== e1.kind) throw new Zt(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e1.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = qt(a), r = qt(s);
                        if ("string" !== t1.kind || "string" !== r.kind) return e1(i, a, s);
                    }
                    return this.collator ? r(i, a, s, this.collator.evaluate(i)) : e1(i, a, s);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
            };
        }
        const nr = rr("==", function(t1, e1, r) {
            return e1 === r;
        }, er), ir = rr("!=", function(t1, e1, r) {
            return e1 !== r;
        }, function(t1, e1, r, n) {
            return !er(0, e1, r, n);
        }), ar = rr("<", function(t1, e1, r) {
            return e1 < r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) < 0;
        }), sr = rr(">", function(t1, e1, r) {
            return e1 > r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) > 0;
        }), or = rr("<=", function(t1, e1, r) {
            return e1 <= r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) <= 0;
        }), lr = rr(">=", function(t1, e1, r) {
            return e1 >= r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) >= 0;
        });
        class ur {
            constructor(t1, e1, r, n, i){
                this.type = ft, this.number = t1, this.locale = e1, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error("Expected two arguments.");
                const r = e1.parse(t1[1], 1, pt);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e1.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e1.parse(n.locale, 1, ft), !i)) return null;
                let a = null;
                if (n.currency && (a = e1.parse(n.currency, 1, ft), !a)) return null;
                let s = null;
                if (n["min-fraction-digits"] && (s = e1.parse(n["min-fraction-digits"], 1, pt), !s)) return null;
                let o = null;
                return n["max-fraction-digits"] && (o = e1.parse(n["max-fraction-digits"], 1, pt), !o) ? null : new ur(r, i, a, s, o);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: this.currency ? "currency" : "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
        }
        class cr {
            constructor(t1){
                this.type = vt, this.sections = t1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e1.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const a = t1[r];
                    if (i && "object" == typeof a && !Array.isArray(a)) {
                        i = !1;
                        let t1 = null;
                        if (a["font-scale"] && (t1 = e1.parse(a["font-scale"], 1, pt), !t1)) return null;
                        let r = null;
                        if (a["text-font"] && (r = e1.parse(a["text-font"], 1, _t(ft)), !r)) return null;
                        let s = null;
                        if (a["text-color"] && (s = e1.parse(a["text-color"], 1, yt), !s)) return null;
                        const o = n[n.length - 1];
                        o.scale = t1, o.font = r, o.textColor = s;
                    } else {
                        const a = e1.parse(t1[r], 1, gt);
                        if (!a) return null;
                        const s = a.type.kind;
                        if ("string" !== s && "value" !== s && "null" !== s && "resolvedImage" !== s) return e1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: a,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new cr(n);
            }
            evaluate(t1) {
                return new Dt(this.sections.map((e1)=>{
                    const r = e1.content.evaluate(t1);
                    return qt(r) === wt ? new Lt("", r, null, null, null) : new Lt(jt(r), null, e1.scale ? e1.scale.evaluate(t1) : null, e1.font ? e1.font.evaluate(t1).join(",") : null, e1.textColor ? e1.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e1 of this.sections)t1(e1.content), e1.scale && t1(e1.scale), e1.font && t1(e1.font), e1.textColor && t1(e1.textColor);
            }
            outputDefined() {
                return !1;
            }
        }
        class hr {
            constructor(t1){
                this.type = wt, this.input = t1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error("Expected two arguments.");
                const r = e1.parse(t1[1], 1, ft);
                return r ? new hr(r) : e1.error("No image name provided.");
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1), r = Rt.fromString(e1);
                return r && t1.availableImages && (r.available = t1.availableImages.indexOf(e1) > -1), r;
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
        }
        class pr {
            constructor(t1){
                this.type = pt, this.input = t1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e1.error(`Expected argument of type string or array, but found ${At(r.type)} instead.`) : new pr(r) : null;
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1);
                if ("string" == typeof e1) return e1.length;
                if (Array.isArray(e1)) return e1.length;
                throw new Zt(`Expected value to be of type string or array, but found ${At(qt(e1))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
        }
        const fr = {
            "==": nr,
            "!=": ir,
            ">": sr,
            "<": ar,
            ">=": lr,
            "<=": or,
            array: Gt,
            at: Je,
            boolean: Gt,
            case: We,
            coalesce: Ke,
            collator: Qt,
            format: cr,
            image: hr,
            in: Xe,
            "index-of": Ye,
            interpolate: Ne,
            "interpolate-hcl": Ne,
            "interpolate-lab": Ne,
            length: pr,
            let: Ge,
            literal: Nt,
            match: He,
            number: Gt,
            "number-format": ur,
            object: Gt,
            slice: Qe,
            step: ke,
            string: Gt,
            "to-boolean": Xt,
            "to-color": Xt,
            "to-number": Xt,
            "to-string": Xt,
            var: be,
            within: me
        };
        function dr(t1, [e1, r, n, i]) {
            e1 = e1.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const a = i ? i.evaluate(t1) : 1, s = Ot(e1, r, n, a);
            if (s) throw new Zt(s);
            return new Ft(e1 / 255 * a, r / 255 * a, n / 255 * a, a);
        }
        function yr(t1, e1) {
            return t1 in e1;
        }
        function mr(t1, e1) {
            const r = e1[t1];
            return void 0 === r ? null : r;
        }
        function gr(t1) {
            return {
                type: t1
            };
        }
        function xr(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function vr(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function br(t1) {
            return "data-driven" === t1["property-type"] || "cross-faded-data-driven" === t1["property-type"];
        }
        function wr(t1) {
            return !!t1.expression && t1.expression.parameters.indexOf("zoom") > -1;
        }
        function _r(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function Ar(t1) {
            return t1 instanceof Number ? "number" : t1 instanceof String ? "string" : t1 instanceof Boolean ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : typeof t1;
        }
        function kr(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function Sr(t1) {
            return t1;
        }
        function Ir(t1, e1) {
            const r = "color" === e1.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), a = t1.type || (_r(e1) ? "exponential" : "interval");
            if (r || "padding" === e1.type) {
                const n = r ? Ft.parse : $t.parse;
                (t1 = st({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                        t1[0],
                        n(t1[1])
                    ])), t1.default = n(t1.default ? t1.default : e1.default);
            }
            if (t1.colorSpace && "rgb" !== t1.colorSpace && !je[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let s, o, l;
            if ("exponential" === a) s = Cr;
            else if ("interval" === a) s = Br;
            else if ("categorical" === a) {
                s = zr, o = Object.create(null);
                for (const e1 of t1.stops)o[e1[0]] = e1[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== a) throw new Error(`Unknown function type "${a}"`);
                s = Pr;
            }
            if (n) {
                const r = {}, n = [];
                for(let e1 = 0; e1 < t1.stops.length; e1++){
                    const i = t1.stops[e1], a = i[0].zoom;
                    void 0 === r[a] && (r[a] = {
                        zoom: a,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(a)), r[a].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    Ir(r[t1], e1)
                ]);
                const a = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: a,
                    interpolationFactor: Ne.interpolationFactor.bind(void 0, a),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r }, n)=>Cr({
                            stops: i,
                            base: t1.base
                        }, e1, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === a ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: Ne.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r })=>s(t1, e1, r, o, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? Mr(t1.default, e1.default) : s(t1, e1, i, o, l);
                }
            };
        }
        function Mr(t1, e1, r) {
            return void 0 !== t1 ? t1 : void 0 !== e1 ? e1 : void 0 !== r ? r : void 0;
        }
        function zr(t1, e1, r, n, i) {
            return Mr(typeof r === i ? n[r] : void 0, t1.default, e1.default);
        }
        function Br(t1, e1, r) {
            if ("number" !== Ar(r)) return Mr(t1.default, e1.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = Ae(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function Cr(t1, e1, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if ("number" !== Ar(r)) return Mr(t1.default, e1.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const a = Ae(t1.stops.map((t1)=>t1[0]), r), s = function(t1, e1, r, n) {
                const i = n - r, a = t1 - r;
                return 0 === i ? 0 : 1 === e1 ? a / i : (Math.pow(e1, a) - 1) / (Math.pow(e1, i) - 1);
            }(r, n, t1.stops[a][0], t1.stops[a + 1][0]), o = t1.stops[a][1], l = t1.stops[a + 1][1];
            let u = Ie[e1.type] || Sr;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e1 = je[t1.colorSpace];
                u = (t1, r)=>e1.reverse(e1.interpolate(e1.forward(t1), e1.forward(r), s));
            }
            return "function" == typeof o.evaluate ? {
                evaluate (...t1) {
                    const e1 = o.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e1 && void 0 !== r) return u(e1, r, s);
                }
            } : u(o, l, s);
        }
        function Pr(t1, e1, r) {
            switch(e1.type){
                case "color":
                    r = Ft.parse(r);
                    break;
                case "formatted":
                    r = Dt.fromString(r.toString());
                    break;
                case "resolvedImage":
                    r = Rt.fromString(r.toString());
                    break;
                case "padding":
                    r = $t.parse(r);
                    break;
                default:
                    Ar(r) === e1.type || "enum" === e1.type && e1.values[r] || (r = void 0);
            }
            return Mr(r, t1.default, e1.default);
        }
        Wt.register(fr, {
            error: [
                {
                    kind: "error"
                },
                [
                    ft
                ],
                (t1, [e1])=>{
                    throw new Zt(e1.evaluate(t1));
                }
            ],
            typeof: [
                ft,
                [
                    gt
                ],
                (t1, [e1])=>At(qt(e1.evaluate(t1)))
            ],
            "to-rgba": [
                _t(pt, 4),
                [
                    yt
                ],
                (t1, [e1])=>e1.evaluate(t1).toArray()
            ],
            rgb: [
                yt,
                [
                    pt,
                    pt,
                    pt
                ],
                dr
            ],
            rgba: [
                yt,
                [
                    pt,
                    pt,
                    pt,
                    pt
                ],
                dr
            ],
            has: {
                type: dt,
                overloads: [
                    [
                        [
                            ft
                        ],
                        (t1, [e1])=>yr(e1.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            ft,
                            mt
                        ],
                        (t1, [e1, r])=>yr(e1.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: gt,
                overloads: [
                    [
                        [
                            ft
                        ],
                        (t1, [e1])=>mr(e1.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            ft,
                            mt
                        ],
                        (t1, [e1, r])=>mr(e1.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                gt,
                [
                    ft
                ],
                (t1, [e1])=>mr(e1.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                mt,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                ft,
                [],
                (t1)=>t1.geometryType()
            ],
            id: [
                gt,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                pt,
                [],
                (t1)=>t1.globals.zoom
            ],
            "heatmap-density": [
                pt,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                pt,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            accumulated: [
                gt,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                pt,
                gr(pt),
                (t1, e1)=>{
                    let r = 0;
                    for (const n of e1)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                pt,
                gr(pt),
                (t1, e1)=>{
                    let r = 1;
                    for (const n of e1)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: pt,
                overloads: [
                    [
                        [
                            pt,
                            pt
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            pt
                        ],
                        (t1, [e1])=>-e1.evaluate(t1)
                    ]
                ]
            },
            "/": [
                pt,
                [
                    pt,
                    pt
                ],
                (t1, [e1, r])=>e1.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                pt,
                [
                    pt,
                    pt
                ],
                (t1, [e1, r])=>e1.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                pt,
                [],
                ()=>Math.LN2
            ],
            pi: [
                pt,
                [],
                ()=>Math.PI
            ],
            e: [
                pt,
                [],
                ()=>Math.E
            ],
            "^": [
                pt,
                [
                    pt,
                    pt
                ],
                (t1, [e1, r])=>Math.pow(e1.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.sqrt(e1.evaluate(t1))
            ],
            log10: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1)) / Math.LN10
            ],
            ln: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1))
            ],
            log2: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1)) / Math.LN2
            ],
            sin: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.sin(e1.evaluate(t1))
            ],
            cos: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.cos(e1.evaluate(t1))
            ],
            tan: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.tan(e1.evaluate(t1))
            ],
            asin: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.asin(e1.evaluate(t1))
            ],
            acos: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.acos(e1.evaluate(t1))
            ],
            atan: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.atan(e1.evaluate(t1))
            ],
            min: [
                pt,
                gr(pt),
                (t1, e1)=>Math.min(...e1.map((e1)=>e1.evaluate(t1)))
            ],
            max: [
                pt,
                gr(pt),
                (t1, e1)=>Math.max(...e1.map((e1)=>e1.evaluate(t1)))
            ],
            abs: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.abs(e1.evaluate(t1))
            ],
            round: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>{
                    const r = e1.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.floor(e1.evaluate(t1))
            ],
            ceil: [
                pt,
                [
                    pt
                ],
                (t1, [e1])=>Math.ceil(e1.evaluate(t1))
            ],
            "filter-==": [
                dt,
                [
                    ft,
                    gt
                ],
                (t1, [e1, r])=>t1.properties()[e1.value] === r.value
            ],
            "filter-id-==": [
                dt,
                [
                    gt
                ],
                (t1, [e1])=>t1.id() === e1.value
            ],
            "filter-type-==": [
                dt,
                [
                    ft
                ],
                (t1, [e1])=>t1.geometryType() === e1.value
            ],
            "filter-<": [
                dt,
                [
                    ft,
                    gt
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                dt,
                [
                    gt
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                dt,
                [
                    ft,
                    gt
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                dt,
                [
                    gt
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                dt,
                [
                    ft,
                    gt
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                dt,
                [
                    gt
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                dt,
                [
                    ft,
                    gt
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                dt,
                [
                    gt
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                dt,
                [
                    gt
                ],
                (t1, [e1])=>e1.value in t1.properties()
            ],
            "filter-has-id": [
                dt,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                dt,
                [
                    _t(ft)
                ],
                (t1, [e1])=>e1.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                dt,
                [
                    _t(gt)
                ],
                (t1, [e1])=>e1.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                dt,
                [
                    ft,
                    _t(gt)
                ],
                (t1, [e1, r])=>r.value.indexOf(t1.properties()[e1.value]) >= 0
            ],
            "filter-in-large": [
                dt,
                [
                    ft,
                    _t(gt)
                ],
                (t1, [e1, r])=>(function(t1, e1, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e1[i] === t1) return !0;
                            e1[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e1.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: dt,
                overloads: [
                    [
                        [
                            dt,
                            dt
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        gr(dt),
                        (t1, e1)=>{
                            for (const r of e1)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: dt,
                overloads: [
                    [
                        [
                            dt,
                            dt
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        gr(dt),
                        (t1, e1)=>{
                            for (const r of e1)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                dt,
                [
                    dt
                ],
                (t1, [e1])=>!e1.evaluate(t1)
            ],
            "is-supported-script": [
                dt,
                [
                    ft
                ],
                (t1, [e1])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e1.evaluate(t1));
                }
            ],
            upcase: [
                ft,
                [
                    ft
                ],
                (t1, [e1])=>e1.evaluate(t1).toUpperCase()
            ],
            downcase: [
                ft,
                [
                    ft
                ],
                (t1, [e1])=>e1.evaluate(t1).toLowerCase()
            ],
            concat: [
                ft,
                gr(gt),
                (t1, e1)=>e1.map((e1)=>jt(e1.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                ft,
                [
                    xt
                ],
                (t1, [e1])=>e1.evaluate(t1).resolvedLocale()
            ]
        });
        class Vr {
            constructor(t1, e1){
                this.expression = t1, this._warningHistory = {}, this._evaluator = new Ht, this._defaultValue = e1 ? function(t1) {
                    return "color" === t1.type && kr(t1.default) ? new Ft(0, 0, 0, 0) : "color" === t1.type ? Ft.parse(t1.default) || null : "padding" === t1.type ? $t.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e1) : null, this._enumValues = e1 && "enum" === e1.type ? e1.values : null;
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, a) {
                return this._evaluator.globals = t1, this._evaluator.feature = e1, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e1, r, n, i, a) {
                this._evaluator.globals = t1, this._evaluator.feature = e1 || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new Zt(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    return this._warningHistory[t1.message] || (this._warningHistory[t1.message] = !0, "undefined" != typeof console && console.warn(t1.message)), this._defaultValue;
                }
            }
        }
        function Er(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in fr;
        }
        function Fr(t1, e1) {
            const r = new we(fr, [], e1 ? function(t1) {
                const e1 = {
                    color: yt,
                    string: ft,
                    number: pt,
                    enum: ft,
                    boolean: dt,
                    formatted: vt,
                    padding: bt,
                    resolvedImage: wt
                };
                return "array" === t1.type ? _t(e1[t1.value] || gt, t1.length) : e1[t1.type];
            }(e1) : void 0), n = r.parse(t1, void 0, void 0, void 0, e1 && "string" === e1.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return n ? xr(new Vr(n, e1)) : vr(r.errors);
        }
        class Tr {
            constructor(t1, e1){
                this.kind = t1, this._styleExpression = e1, this.isStateDependent = "constant" !== t1 && !xe(e1.expression);
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, a) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e1, r, n, i, a);
            }
            evaluate(t1, e1, r, n, i, a) {
                return this._styleExpression.evaluate(t1, e1, r, n, i, a);
            }
        }
        class Lr {
            constructor(t1, e1, r, n){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e1, this.isStateDependent = "camera" !== t1 && !xe(e1.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, a) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e1, r, n, i, a);
            }
            evaluate(t1, e1, r, n, i, a) {
                return this._styleExpression.evaluate(t1, e1, r, n, i, a);
            }
            interpolationFactor(t1, e1, r) {
                return this.interpolationType ? Ne.interpolationFactor(this.interpolationType, t1, e1, r) : 0;
            }
        }
        function Dr(t1, e1) {
            const r = Fr(t1, e1);
            if ("error" === r.result) return r;
            const n = r.value.expression, i = ge(n);
            if (!i && !br(e1)) return vr([
                new ut("", "data expressions not supported")
            ]);
            const a = ve(n, [
                "zoom"
            ]);
            if (!a && !wr(e1)) return vr([
                new ut("", "zoom expressions not supported")
            ]);
            const s = Rr(n);
            return s || a ? s instanceof ut ? vr([
                s
            ]) : s instanceof Ne && !_r(e1) ? vr([
                new ut("", '"interpolate" expressions cannot be used with this property')
            ]) : xr(s ? new Lr(i ? "camera" : "composite", r.value, s.labels, s instanceof Ne ? s.interpolation : void 0) : new Tr(i ? "constant" : "source", r.value)) : vr([
                new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
            ]);
        }
        class $r {
            constructor(t1, e1){
                this._parameters = t1, this._specification = e1, st(this, Ir(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new $r(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function Rr(t1) {
            let e1 = null;
            if (t1 instanceof Ge) e1 = Rr(t1.result);
            else if (t1 instanceof Ke) {
                for (const r of t1.args)if (e1 = Rr(r), e1) break;
            } else (t1 instanceof ke || t1 instanceof Ne) && t1.input instanceof Wt && "zoom" === t1.input.name && (e1 = t1);
            return e1 instanceof ut || t1.eachChild((t1)=>{
                const r = Rr(t1);
                r instanceof ut ? e1 = r : !e1 && r ? e1 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e1 && r && e1 !== r && (e1 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e1;
        }
        function Or(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec || {}, i = t1.objectElementValidators || {}, a = t1.style, s = t1.styleSpec;
            let o = [];
            const l = Ar(r);
            if ("object" !== l) return [
                new it(e1, r, `object expected, ${l} found`)
            ];
            for(const t1 in r){
                const l = t1.split(".")[0], u = n[l] || n["*"];
                let c;
                if (i[l]) c = i[l];
                else if (n[l]) c = yn;
                else if (i["*"]) c = i["*"];
                else {
                    if (!n["*"]) {
                        o.push(new it(e1, r[t1], `unknown property "${t1}"`));
                        continue;
                    }
                    c = yn;
                }
                o = o.concat(c({
                    key: (e1 ? `${e1}.` : e1) + t1,
                    value: r[t1],
                    valueSpec: u,
                    style: a,
                    styleSpec: s,
                    object: r,
                    objectKey: t1
                }, r));
            }
            for(const t1 in n)i[t1] || n[t1].required && void 0 === n[t1].default && void 0 === r[t1] && o.push(new it(e1, r, `missing required property "${t1}"`));
            return o;
        }
        function Ur(t1) {
            const e1 = t1.value, r = t1.valueSpec, n = t1.style, i = t1.styleSpec, a = t1.key, s = t1.arrayElementValidator || yn;
            if ("array" !== Ar(e1)) return [
                new it(a, e1, `array expected, ${Ar(e1)} found`)
            ];
            if (r.length && e1.length !== r.length) return [
                new it(a, e1, `array length ${r.length} expected, length ${e1.length} found`)
            ];
            if (r["min-length"] && e1.length < r["min-length"]) return [
                new it(a, e1, `array length at least ${r["min-length"]} expected, length ${e1.length} found`)
            ];
            let o = {
                type: r.value,
                values: r.values
            };
            i.$version < 7 && (o.function = r.function), "object" === Ar(r.value) && (o = r.value);
            let l = [];
            for(let t1 = 0; t1 < e1.length; t1++)l = l.concat(s({
                array: e1,
                arrayIndex: t1,
                value: e1[t1],
                valueSpec: o,
                style: n,
                styleSpec: i,
                key: `${a}[${t1}]`
            }));
            return l;
        }
        function qr(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec;
            let i = Ar(r);
            return "number" === i && r != r && (i = "NaN"), "number" !== i ? [
                new it(e1, r, `number expected, ${i} found`)
            ] : "minimum" in n && r < n.minimum ? [
                new it(e1, r, `${r} is less than the minimum value ${n.minimum}`)
            ] : "maximum" in n && r > n.maximum ? [
                new it(e1, r, `${r} is greater than the maximum value ${n.maximum}`)
            ] : [];
        }
        function jr(t1) {
            const e1 = t1.valueSpec, r = ot(t1.value.type);
            let n, i, a, s = {};
            const o = "categorical" !== r && void 0 === t1.value.property, l = !o, u = "array" === Ar(t1.value.stops) && "array" === Ar(t1.value.stops[0]) && "object" === Ar(t1.value.stops[0][0]), c = Or({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === r) return [
                            new it(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let e1 = [];
                        const n = t1.value;
                        return e1 = e1.concat(Ur({
                            key: t1.key,
                            value: n,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: h
                        })), "array" === Ar(n) && 0 === n.length && e1.push(new it(t1.key, n, "array must have at least one stop")), e1;
                    },
                    default: function(t1) {
                        return yn({
                            key: t1.key,
                            value: t1.value,
                            valueSpec: e1,
                            style: t1.style,
                            styleSpec: t1.styleSpec
                        });
                    }
                }
            });
            return "identity" === r && o && c.push(new it(t1.key, t1.value, 'missing required property "property"')), "identity" === r || t1.value.stops || c.push(new it(t1.key, t1.value, 'missing required property "stops"')), "exponential" === r && t1.valueSpec.expression && !_r(t1.valueSpec) && c.push(new it(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (l && !br(t1.valueSpec) ? c.push(new it(t1.key, t1.value, "property functions not supported")) : o && !wr(t1.valueSpec) && c.push(new it(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t1.value.property || c.push(new it(t1.key, t1.value, '"property" property is required')), c;
            function h(t1) {
                let r = [];
                const n = t1.value, o = t1.key;
                if ("array" !== Ar(n)) return [
                    new it(o, n, `array expected, ${Ar(n)} found`)
                ];
                if (2 !== n.length) return [
                    new it(o, n, `array length 2 expected, length ${n.length} found`)
                ];
                if (u) {
                    if ("object" !== Ar(n[0])) return [
                        new it(o, n, `object expected, ${Ar(n[0])} found`)
                    ];
                    if (void 0 === n[0].zoom) return [
                        new it(o, n, "object stop key must have zoom")
                    ];
                    if (void 0 === n[0].value) return [
                        new it(o, n, "object stop key must have value")
                    ];
                    if (a && a > ot(n[0].zoom)) return [
                        new it(o, n[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    ot(n[0].zoom) !== a && (a = ot(n[0].zoom), i = void 0, s = {}), r = r.concat(Or({
                        key: `${o}[0]`,
                        value: n[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: qr,
                            value: p
                        }
                    }));
                } else r = r.concat(p({
                    key: `${o}[0]`,
                    value: n[0],
                    valueSpec: {},
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, n));
                return Er(lt(n[1])) ? r.concat([
                    new it(`${o}[1]`, n[1], "expressions are not allowed in function stops.")
                ]) : r.concat(yn({
                    key: `${o}[1]`,
                    value: n[1],
                    valueSpec: e1,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function p(t1, a) {
                const o = Ar(t1.value), l = ot(t1.value), u = null !== t1.value ? t1.value : a;
                if (n) {
                    if (o !== n) return [
                        new it(t1.key, u, `${o} stop domain type must match previous stop domain type ${n}`)
                    ];
                } else n = o;
                if ("number" !== o && "string" !== o && "boolean" !== o) return [
                    new it(t1.key, u, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== o && "categorical" !== r) {
                    let n = `number expected, ${o} found`;
                    return br(e1) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new it(t1.key, u, n)
                    ];
                }
                return "categorical" !== r || "number" !== o || isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && void 0 !== i && l < i ? [
                    new it(t1.key, u, "stop domain values must appear in ascending order")
                ] : (i = l, "categorical" === r && l in s ? [
                    new it(t1.key, u, "stop domain values must be unique")
                ] : (s[l] = !0, [])) : [
                    new it(t1.key, u, `integer expected, found ${l}`)
                ];
            }
        }
        function Nr(t1) {
            const e1 = ("property" === t1.expressionContext ? Dr : Fr)(lt(t1.value), t1.valueSpec);
            if ("error" === e1.result) return e1.value.map((e1)=>new it(`${t1.key}${e1.key}`, t1.value, e1.message));
            const r = e1.value.expression || e1.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !r.outputDefined()) return [
                new it(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !xe(r)) return [
                new it(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext && !xe(r)) return [
                new it(t1.key, t1.value, '"feature-state" data expressions are not supported with filters.')
            ];
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!ve(r, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new it(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !ge(r)) return [
                    new it(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function Zr(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec, i = [];
            return Array.isArray(n.values) ? -1 === n.values.indexOf(ot(r)) && i.push(new it(e1, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(ot(r)) && i.push(new it(e1, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i;
        }
        function Kr(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e1 of t1.slice(1))if (!Kr(e1) && "boolean" != typeof e1) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        const Gr = {
            type: "boolean",
            default: !1,
            transition: !1,
            "property-type": "data-driven",
            expression: {
                interpolated: !1,
                parameters: [
                    "zoom",
                    "feature"
                ]
            }
        };
        function Jr(t1) {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1
            };
            Kr(t1) || (t1 = Hr(t1));
            const e1 = Fr(t1, Gr);
            if ("error" === e1.result) throw new Error(e1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
            return {
                filter: (t1, r, n)=>e1.value.evaluate(t1, r, {}, n),
                needGeometry: Yr(t1)
            };
        }
        function Xr(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function Yr(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0]) return !0;
            for(let e1 = 1; e1 < t1.length; e1++)if (Yr(t1[e1])) return !0;
            return !1;
        }
        function Hr(t1) {
            if (!t1) return !0;
            const e1 = t1[0];
            var r;
            return t1.length <= 1 ? "any" !== e1 : "==" === e1 ? Wr(t1[1], t1[2], "==") : "!=" === e1 ? en(Wr(t1[1], t1[2], "==")) : "<" === e1 || ">" === e1 || "<=" === e1 || ">=" === e1 ? Wr(t1[1], t1[2], e1) : "any" === e1 ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(Hr))) : "all" === e1 ? [
                "all"
            ].concat(t1.slice(1).map(Hr)) : "none" === e1 ? [
                "all"
            ].concat(t1.slice(1).map(Hr).map(en)) : "in" === e1 ? Qr(t1[1], t1.slice(2)) : "!in" === e1 ? en(Qr(t1[1], t1.slice(2))) : "has" === e1 ? tn(t1[1]) : "!has" === e1 ? en(tn(t1[1])) : "within" !== e1 || t1;
        }
        function Wr(t1, e1, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e1
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e1
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e1
                    ];
            }
        }
        function Qr(t1, e1) {
            if (0 === e1.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e1
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e1
                        ]
                    ];
                default:
                    return e1.length > 200 && !e1.some((t1)=>typeof t1 != typeof e1[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e1.sort(Xr)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e1
                        ]
                    ];
            }
        }
        function tn(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function en(t1) {
            return [
                "!",
                t1
            ];
        }
        function rn(t1) {
            return Kr(lt(t1.value)) ? Nr(st({}, t1, {
                expressionContext: "filter",
                valueSpec: {
                    value: "boolean"
                }
            })) : nn(t1);
        }
        function nn(t1) {
            const e1 = t1.value, r = t1.key;
            if ("array" !== Ar(e1)) return [
                new it(r, e1, `array expected, ${Ar(e1)} found`)
            ];
            const n = t1.styleSpec;
            let i, a = [];
            if (e1.length < 1) return [
                new it(r, e1, "filter array must have at least 1 element")
            ];
            switch(a = a.concat(Zr({
                key: `${r}[0]`,
                value: e1[0],
                valueSpec: n.filter_operator,
                style: t1.style,
                styleSpec: t1.styleSpec
            })), ot(e1[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    e1.length >= 2 && "$type" === ot(e1[1]) && a.push(new it(r, e1, `"$type" cannot be use with operator "${e1[0]}"`));
                case "==":
                case "!=":
                    3 !== e1.length && a.push(new it(r, e1, `filter array for operator "${e1[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    e1.length >= 2 && (i = Ar(e1[1]), "string" !== i && a.push(new it(`${r}[1]`, e1[1], `string expected, ${i} found`)));
                    for(let s = 2; s < e1.length; s++)i = Ar(e1[s]), "$type" === ot(e1[1]) ? a = a.concat(Zr({
                        key: `${r}[${s}]`,
                        value: e1[s],
                        valueSpec: n.geometry_type,
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    })) : "string" !== i && "number" !== i && "boolean" !== i && a.push(new it(`${r}[${s}]`, e1[s], `string, number, or boolean expected, ${i} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let n = 1; n < e1.length; n++)a = a.concat(nn({
                        key: `${r}[${n}]`,
                        value: e1[n],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    i = Ar(e1[1]), 2 !== e1.length ? a.push(new it(r, e1, `filter array for "${e1[0]}" operator must have 2 elements`)) : "string" !== i && a.push(new it(`${r}[1]`, e1[1], `string expected, ${i} found`));
                    break;
                case "within":
                    i = Ar(e1[1]), 2 !== e1.length ? a.push(new it(r, e1, `filter array for "${e1[0]}" operator must have 2 elements`)) : "object" !== i && a.push(new it(`${r}[1]`, e1[1], `object expected, ${i} found`));
            }
            return a;
        }
        function an(t1, e1) {
            const r = t1.key, n = t1.style, i = t1.styleSpec, a = t1.value, s = t1.objectKey, o = i[`${e1}_${t1.layerType}`];
            if (!o) return [];
            const l = s.match(/^(.*)-transition$/);
            if ("paint" === e1 && l && o[l[1]] && o[l[1]].transition) return yn({
                key: r,
                value: a,
                valueSpec: i.transition,
                style: n,
                styleSpec: i
            });
            const u = t1.valueSpec || o[s];
            if (!u) return [
                new it(r, a, `unknown property "${s}"`)
            ];
            let c;
            if ("string" === Ar(a) && br(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(a))) return [
                new it(r, a, `"${s}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c[1])} }\`.`)
            ];
            const h = [];
            return "symbol" === t1.layerType && ("text-field" === s && n && !n.glyphs && h.push(new it(r, a, 'use of "text-field" requires a style "glyphs" property')), "text-font" === s && kr(lt(a)) && "identity" === ot(a.type) && h.push(new it(r, a, '"text-font" does not support identity functions'))), h.concat(yn({
                key: t1.key,
                value: a,
                valueSpec: u,
                style: n,
                styleSpec: i,
                expressionContext: "property",
                propertyType: e1,
                propertyKey: s
            }));
        }
        function sn(t1) {
            return an(t1, "paint");
        }
        function on(t1) {
            return an(t1, "layout");
        }
        function ln(t1) {
            let e1 = [];
            const r = t1.value, n = t1.key, i = t1.style, a = t1.styleSpec;
            r.type || r.ref || e1.push(new it(n, r, 'either "type" or "ref" is required'));
            let s = ot(r.type);
            const o = ot(r.ref);
            if (r.id) {
                const a = ot(r.id);
                for(let s = 0; s < t1.arrayIndex; s++){
                    const t1 = i.layers[s];
                    ot(t1.id) === a && e1.push(new it(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in r) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in r && e1.push(new it(n, r[t1], `"${t1}" is prohibited for ref layers`));
                }), i.layers.forEach((e1)=>{
                    ot(e1.id) === o && (t1 = e1);
                }), t1 ? t1.ref ? e1.push(new it(n, r.ref, "ref cannot reference another ref layer")) : s = ot(t1.type) : e1.push(new it(n, r.ref, `ref layer "${o}" not found`));
            } else if ("background" !== s) {
                if (r.source) {
                    const t1 = i.sources && i.sources[r.source], a = t1 && ot(t1.type);
                    t1 ? "vector" === a && "raster" === s ? e1.push(new it(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === a && "raster" !== s ? e1.push(new it(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== a || r["source-layer"] ? "raster-dem" === a && "hillshade" !== s ? e1.push(new it(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s || !r.paint || !r.paint["line-gradient"] || "geojson" === a && t1.lineMetrics || e1.push(new it(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e1.push(new it(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e1.push(new it(n, r.source, `source "${r.source}" not found`));
                } else e1.push(new it(n, r, 'missing required property "source"'));
            }
            return e1 = e1.concat(Or({
                key: n,
                value: r,
                valueSpec: a.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>yn({
                            key: `${n}.type`,
                            value: r.type,
                            valueSpec: a.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: r,
                            objectKey: "type"
                        }),
                    filter: rn,
                    layout: (t1)=>Or({
                            layer: r,
                            key: t1.key,
                            value: t1.value,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>on(st({
                                        layerType: s
                                    }, t1))
                            }
                        }),
                    paint: (t1)=>Or({
                            layer: r,
                            key: t1.key,
                            value: t1.value,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>sn(st({
                                        layerType: s
                                    }, t1))
                            }
                        })
                }
            })), e1;
        }
        function un(t1) {
            const e1 = t1.value, r = t1.key, n = Ar(e1);
            return "string" !== n ? [
                new it(r, e1, `string expected, ${n} found`)
            ] : [];
        }
        const cn = {
            promoteId: function({ key: t1, value: e1 }) {
                if ("string" === Ar(e1)) return un({
                    key: t1,
                    value: e1
                });
                {
                    const r = [];
                    for(const n in e1)r.push(...un({
                        key: `${t1}.${n}`,
                        value: e1[n]
                    }));
                    return r;
                }
            }
        };
        function hn(t1) {
            const e1 = t1.value, r = t1.key, n = t1.styleSpec, i = t1.style;
            if (!e1.type) return [
                new it(r, e1, '"type" is required')
            ];
            const a = ot(e1.type);
            let s;
            switch(a){
                case "vector":
                case "raster":
                case "raster-dem":
                    return s = Or({
                        key: r,
                        value: e1,
                        valueSpec: n[`source_${a.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: n,
                        objectElementValidators: cn
                    }), s;
                case "geojson":
                    if (s = Or({
                        key: r,
                        value: e1,
                        valueSpec: n.source_geojson,
                        style: i,
                        styleSpec: n,
                        objectElementValidators: cn
                    }), e1.cluster) for(const t1 in e1.clusterProperties){
                        const [n, i] = e1.clusterProperties[t1], a = "string" == typeof n ? [
                            n,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                t1
                            ]
                        ] : n;
                        s.push(...Nr({
                            key: `${r}.${t1}.map`,
                            value: i,
                            expressionContext: "cluster-map"
                        })), s.push(...Nr({
                            key: `${r}.${t1}.reduce`,
                            value: a,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return s;
                case "video":
                    return Or({
                        key: r,
                        value: e1,
                        valueSpec: n.source_video,
                        style: i,
                        styleSpec: n
                    });
                case "image":
                    return Or({
                        key: r,
                        value: e1,
                        valueSpec: n.source_image,
                        style: i,
                        styleSpec: n
                    });
                case "canvas":
                    return [
                        new it(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return Zr({
                        key: `${r}.type`,
                        value: e1.type,
                        valueSpec: {
                            values: [
                                "vector",
                                "raster",
                                "raster-dem",
                                "geojson",
                                "video",
                                "image"
                            ]
                        },
                        style: i,
                        styleSpec: n
                    });
            }
        }
        function pn(t1) {
            const e1 = t1.value, r = t1.styleSpec, n = r.light, i = t1.style;
            let a = [];
            const s = Ar(e1);
            if (void 0 === e1) return a;
            if ("object" !== s) return a = a.concat([
                new it("light", e1, `object expected, ${s} found`)
            ]), a;
            for(const t1 in e1){
                const s = t1.match(/^(.*)-transition$/);
                a = a.concat(s && n[s[1]] && n[s[1]].transition ? yn({
                    key: t1,
                    value: e1[t1],
                    valueSpec: r.transition,
                    style: i,
                    styleSpec: r
                }) : n[t1] ? yn({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n[t1],
                    style: i,
                    styleSpec: r
                }) : [
                    new it(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            return a;
        }
        function fn(t1) {
            const e1 = t1.value, r = t1.styleSpec, n = r.terrain, i = t1.style;
            let a = [];
            const s = Ar(e1);
            if (void 0 === e1) return a;
            if ("object" !== s) return a = a.concat([
                new it("terrain", e1, `object expected, ${s} found`)
            ]), a;
            for(const t1 in e1)a = a.concat(n[t1] ? yn({
                key: t1,
                value: e1[t1],
                valueSpec: n[t1],
                style: i,
                styleSpec: r
            }) : [
                new it(t1, e1[t1], `unknown property "${t1}"`)
            ]);
            return a;
        }
        const dn = {
            "*": ()=>[],
            array: Ur,
            boolean: function(t1) {
                const e1 = t1.value, r = t1.key, n = Ar(e1);
                return "boolean" !== n ? [
                    new it(r, e1, `boolean expected, ${n} found`)
                ] : [];
            },
            number: qr,
            color: function(t1) {
                const e1 = t1.key, r = t1.value, n = Ar(r);
                return "string" !== n ? [
                    new it(e1, r, `color expected, ${n} found`)
                ] : null === zt(r) ? [
                    new it(e1, r, `color expected, "${r}" found`)
                ] : [];
            },
            constants: at,
            enum: Zr,
            filter: rn,
            function: jr,
            layer: ln,
            object: Or,
            source: hn,
            light: pn,
            terrain: fn,
            string: un,
            formatted: function(t1) {
                return 0 === un(t1).length ? [] : Nr(t1);
            },
            resolvedImage: function(t1) {
                return 0 === un(t1).length ? [] : Nr(t1);
            },
            padding: function(t1) {
                const e1 = t1.key, r = t1.value;
                if ("array" === Ar(r)) {
                    if (r.length < 1 || r.length > 4) return [
                        new it(e1, r, `padding requires 1 to 4 values; ${r.length} values found`)
                    ];
                    const t1 = {
                        type: "number"
                    };
                    let n = [];
                    for(let i = 0; i < r.length; i++)n = n.concat(yn({
                        key: `${e1}[${i}]`,
                        value: r[i],
                        valueSpec: t1
                    }));
                    return n;
                }
                return qr({
                    key: e1,
                    value: r,
                    valueSpec: {}
                });
            }
        };
        function yn(t1) {
            const e1 = t1.value, r = t1.valueSpec, n = t1.styleSpec;
            return r.expression && kr(ot(e1)) ? jr(t1) : r.expression && Er(lt(e1)) ? Nr(t1) : r.type && dn[r.type] ? dn[r.type](t1) : Or(st({}, t1, {
                valueSpec: r.type ? n[r.type] : r
            }));
        }
        function mn(t1) {
            const e1 = t1.value, r = t1.key, n = un(t1);
            return n.length || (-1 === e1.indexOf("{fontstack}") && n.push(new it(r, e1, '"glyphs" url must include a "{fontstack}" token')), -1 === e1.indexOf("{range}") && n.push(new it(r, e1, '"glyphs" url must include a "{range}" token'))), n;
        }
        function gn(t1, e1 = nt) {
            let r = [];
            return r = r.concat(yn({
                key: "",
                value: t1,
                valueSpec: e1.$root,
                styleSpec: e1,
                style: t1,
                objectElementValidators: {
                    glyphs: mn,
                    "*": ()=>[]
                }
            })), t1.constants && (r = r.concat(at({
                key: "constants",
                value: t1.constants,
                style: t1,
                styleSpec: e1
            }))), xn(r);
        }
        function xn(t1) {
            return [].concat(t1).sort((t1, e1)=>t1.line - e1.line);
        }
        function vn(t1) {
            return function(...e1) {
                return xn(t1.apply(this, e1));
            };
        }
        gn.source = vn(hn), gn.light = vn(pn), gn.terrain = vn(fn), gn.layer = vn(ln), gn.filter = vn(rn), gn.paintProperty = vn(sn), gn.layoutProperty = vn(on);
        const bn = gn, wn = bn.light, _n = bn.paintProperty, An = bn.layoutProperty;
        function kn(t1, e1) {
            let r = !1;
            if (e1 && e1.length) for (const n of e1)t1.fire(new et(new Error(n.message))), r = !0;
            return r;
        }
        class Sn {
            constructor(t1, e1, r){
                const n = this.cells = [];
                if (t1 instanceof ArrayBuffer) {
                    this.arrayBuffer = t1;
                    const i = new Int32Array(this.arrayBuffer);
                    t1 = i[0], this.d = (e1 = i[1]) + 2 * (r = i[2]);
                    for(let t1 = 0; t1 < this.d * this.d; t1++){
                        const e1 = i[3 + t1], r = i[3 + t1 + 1];
                        n.push(e1 === r ? null : i.subarray(e1, r));
                    }
                    const a = i[3 + n.length + 1];
                    this.keys = i.subarray(i[3 + n.length], a), this.bboxes = i.subarray(a), this.insert = this._insertReadonly;
                } else {
                    this.d = e1 + 2 * r;
                    for(let t1 = 0; t1 < this.d * this.d; t1++)n.push([]);
                    this.keys = [], this.bboxes = [];
                }
                this.n = e1, this.extent = t1, this.padding = r, this.scale = e1 / t1, this.uid = 0;
                const i = r / e1 * t1;
                this.min = -i, this.max = t1 + i;
            }
            insert(t1, e1, r, n, i) {
                this._forEachCell(e1, r, n, i, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t1), this.bboxes.push(e1), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
            }
            _insertReadonly() {
                throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t1, e1, r, n, i, a) {
                this.cells[i].push(a);
            }
            query(t1, e1, r, n, i) {
                const a = this.min, s = this.max;
                if (t1 <= a && e1 <= a && s <= r && s <= n && !i) return Array.prototype.slice.call(this.keys);
                {
                    const a = [];
                    return this._forEachCell(t1, e1, r, n, this._queryCell, a, {}, i), a;
                }
            }
            _queryCell(t1, e1, r, n, i, a, s, o) {
                const l = this.cells[i];
                if (null !== l) {
                    const i = this.keys, u = this.bboxes;
                    for(let c = 0; c < l.length; c++){
                        const h = l[c];
                        if (void 0 === s[h]) {
                            const l = 4 * h;
                            (o ? o(u[l + 0], u[l + 1], u[l + 2], u[l + 3]) : t1 <= u[l + 2] && e1 <= u[l + 3] && r >= u[l + 0] && n >= u[l + 1]) ? (s[h] = !0, a.push(i[h])) : s[h] = !1;
                        }
                    }
                }
            }
            _forEachCell(t1, e1, r, n, i, a, s, o) {
                const l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e1), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n);
                for(let p = l; p <= c; p++)for(let l = u; l <= h; l++){
                    const u = this.d * l + p;
                    if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(l), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(l + 1))) && i.call(this, t1, e1, r, n, u, a, s, o)) return;
                }
            }
            _convertFromCellCoord(t1) {
                return (t1 - this.padding) / this.scale;
            }
            _convertToCellCoord(t1) {
                return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
            }
            toArrayBuffer() {
                if (this.arrayBuffer) return this.arrayBuffer;
                const t1 = this.cells, e1 = 3 + this.cells.length + 1 + 1;
                let r = 0;
                for(let t1 = 0; t1 < this.cells.length; t1++)r += this.cells[t1].length;
                const n = new Int32Array(e1 + r + this.keys.length + this.bboxes.length);
                n[0] = this.extent, n[1] = this.n, n[2] = this.padding;
                let i = e1;
                for(let e1 = 0; e1 < t1.length; e1++){
                    const r = t1[e1];
                    n[3 + e1] = i, n.set(r, i), i += r.length;
                }
                return n[3 + t1.length] = i, n.set(this.keys, i), i += this.keys.length, n[3 + t1.length + 1] = i, n.set(this.bboxes, i), i += this.bboxes.length, n.buffer;
            }
            static serialize(t1, e1) {
                const r = t1.toArrayBuffer();
                return e1 && e1.push(r), {
                    buffer: r
                };
            }
            static deserialize(t1) {
                return new Sn(t1.buffer);
            }
        }
        const In = {};
        function Mn(t1, e1, r = {}) {
            if (In[t1]) throw new Error(`${t1} is already registered.`);
            Object.defineProperty(e1, "_classRegistryKey", {
                value: t1,
                writeable: !1
            }), In[t1] = {
                klass: e1,
                omit: r.omit || [],
                shallow: r.shallow || []
            };
        }
        Mn("Object", Object), Mn("TransferableGridIndex", Sn), Mn("Color", Ft), Mn("Error", Error), Mn("AJAXError", q), Mn("ResolvedImage", Rt), Mn("StylePropertyFunction", $r), Mn("StyleExpression", Vr, {
            omit: [
                "_evaluator"
            ]
        }), Mn("ZoomDependentExpression", Lr), Mn("ZoomConstantExpression", Tr), Mn("CompoundExpression", Wt, {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in fr)fr[t1]._classRegistryKey || Mn(`Expression_${t1}`, fr[t1]);
        function zn(t1) {
            return t1 && "undefined" != typeof ArrayBuffer && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function Bn(t1, e1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || t1 instanceof Blob) return t1;
            if (zn(t1)) return e1 && e1.push(t1), t1;
            if (A(t1)) return e1 && e1.push(t1), t1;
            if (ArrayBuffer.isView(t1)) {
                const r = t1;
                return e1 && e1.push(r.buffer), r;
            }
            if (t1 instanceof ImageData) return e1 && e1.push(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const r = [];
                for (const n of t1)r.push(Bn(n, e1));
                return r;
            }
            if ("object" == typeof t1) {
                const r = t1.constructor, n = r._classRegistryKey;
                if (!n) throw new Error("can't serialize object of unregistered class");
                if (!In[n]) throw new Error(`${n} is not registered.`);
                const i = r.serialize ? r.serialize(t1, e1) : {};
                if (r.serialize) {
                    if (e1 && i === e1[e1.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
                } else {
                    for(const r in t1){
                        if (!t1.hasOwnProperty(r)) continue;
                        if (In[n].omit.indexOf(r) >= 0) continue;
                        const a = t1[r];
                        i[r] = In[n].shallow.indexOf(r) >= 0 ? a : Bn(a, e1);
                    }
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function Cn(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || t1 instanceof Blob || zn(t1) || A(t1) || ArrayBuffer.isView(t1) || t1 instanceof ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(Cn);
            if ("object" == typeof t1) {
                const e1 = t1.$name || "Object";
                if (!In[e1]) throw new Error(`can't deserialize unregistered class ${e1}`);
                const { klass: r } = In[e1];
                if (!r) throw new Error(`can't deserialize unregistered class ${e1}`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const r of Object.keys(t1)){
                    if ("$name" === r) continue;
                    const i = t1[r];
                    n[r] = In[e1].shallow.indexOf(r) >= 0 ? i : Cn(i);
                }
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        class Pn {
            constructor(){
                this.first = !0;
            }
            update(t1, e1) {
                const r = Math.floor(t1);
                return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t1, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e1) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e1), t1 !== this.lastZoom && (this.lastZoom = t1, this.lastFloorZoom = r, !0));
            }
        }
        const Vn = {
            "Latin-1 Supplement": (t1)=>t1 >= 128 && t1 <= 255,
            Arabic: (t1)=>t1 >= 1536 && t1 <= 1791,
            "Arabic Supplement": (t1)=>t1 >= 1872 && t1 <= 1919,
            "Arabic Extended-A": (t1)=>t1 >= 2208 && t1 <= 2303,
            "Hangul Jamo": (t1)=>t1 >= 4352 && t1 <= 4607,
            "Unified Canadian Aboriginal Syllabics": (t1)=>t1 >= 5120 && t1 <= 5759,
            Khmer: (t1)=>t1 >= 6016 && t1 <= 6143,
            "Unified Canadian Aboriginal Syllabics Extended": (t1)=>t1 >= 6320 && t1 <= 6399,
            "General Punctuation": (t1)=>t1 >= 8192 && t1 <= 8303,
            "Letterlike Symbols": (t1)=>t1 >= 8448 && t1 <= 8527,
            "Number Forms": (t1)=>t1 >= 8528 && t1 <= 8591,
            "Miscellaneous Technical": (t1)=>t1 >= 8960 && t1 <= 9215,
            "Control Pictures": (t1)=>t1 >= 9216 && t1 <= 9279,
            "Optical Character Recognition": (t1)=>t1 >= 9280 && t1 <= 9311,
            "Enclosed Alphanumerics": (t1)=>t1 >= 9312 && t1 <= 9471,
            "Geometric Shapes": (t1)=>t1 >= 9632 && t1 <= 9727,
            "Miscellaneous Symbols": (t1)=>t1 >= 9728 && t1 <= 9983,
            "Miscellaneous Symbols and Arrows": (t1)=>t1 >= 11008 && t1 <= 11263,
            "CJK Radicals Supplement": (t1)=>t1 >= 11904 && t1 <= 12031,
            "Kangxi Radicals": (t1)=>t1 >= 12032 && t1 <= 12255,
            "Ideographic Description Characters": (t1)=>t1 >= 12272 && t1 <= 12287,
            "CJK Symbols and Punctuation": (t1)=>t1 >= 12288 && t1 <= 12351,
            Hiragana: (t1)=>t1 >= 12352 && t1 <= 12447,
            Katakana: (t1)=>t1 >= 12448 && t1 <= 12543,
            Bopomofo: (t1)=>t1 >= 12544 && t1 <= 12591,
            "Hangul Compatibility Jamo": (t1)=>t1 >= 12592 && t1 <= 12687,
            Kanbun: (t1)=>t1 >= 12688 && t1 <= 12703,
            "Bopomofo Extended": (t1)=>t1 >= 12704 && t1 <= 12735,
            "CJK Strokes": (t1)=>t1 >= 12736 && t1 <= 12783,
            "Katakana Phonetic Extensions": (t1)=>t1 >= 12784 && t1 <= 12799,
            "Enclosed CJK Letters and Months": (t1)=>t1 >= 12800 && t1 <= 13055,
            "CJK Compatibility": (t1)=>t1 >= 13056 && t1 <= 13311,
            "CJK Unified Ideographs Extension A": (t1)=>t1 >= 13312 && t1 <= 19903,
            "Yijing Hexagram Symbols": (t1)=>t1 >= 19904 && t1 <= 19967,
            "CJK Unified Ideographs": (t1)=>t1 >= 19968 && t1 <= 40959,
            "Yi Syllables": (t1)=>t1 >= 40960 && t1 <= 42127,
            "Yi Radicals": (t1)=>t1 >= 42128 && t1 <= 42191,
            "Hangul Jamo Extended-A": (t1)=>t1 >= 43360 && t1 <= 43391,
            "Hangul Syllables": (t1)=>t1 >= 44032 && t1 <= 55215,
            "Hangul Jamo Extended-B": (t1)=>t1 >= 55216 && t1 <= 55295,
            "Private Use Area": (t1)=>t1 >= 57344 && t1 <= 63743,
            "CJK Compatibility Ideographs": (t1)=>t1 >= 63744 && t1 <= 64255,
            "Arabic Presentation Forms-A": (t1)=>t1 >= 64336 && t1 <= 65023,
            "Vertical Forms": (t1)=>t1 >= 65040 && t1 <= 65055,
            "CJK Compatibility Forms": (t1)=>t1 >= 65072 && t1 <= 65103,
            "Small Form Variants": (t1)=>t1 >= 65104 && t1 <= 65135,
            "Arabic Presentation Forms-B": (t1)=>t1 >= 65136 && t1 <= 65279,
            "Halfwidth and Fullwidth Forms": (t1)=>t1 >= 65280 && t1 <= 65519
        };
        function En(t1) {
            for (const e1 of t1)if (Ln(e1.charCodeAt(0))) return !0;
            return !1;
        }
        function Fn(t1) {
            for (const e1 of t1)if (!Tn(e1.charCodeAt(0))) return !1;
            return !0;
        }
        function Tn(t1) {
            return !(Vn.Arabic(t1) || Vn["Arabic Supplement"](t1) || Vn["Arabic Extended-A"](t1) || Vn["Arabic Presentation Forms-A"](t1) || Vn["Arabic Presentation Forms-B"](t1));
        }
        function Ln(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(Vn["Bopomofo Extended"](t1) || Vn.Bopomofo(t1) || Vn["CJK Compatibility Forms"](t1) && !(t1 >= 65097 && t1 <= 65103) || Vn["CJK Compatibility Ideographs"](t1) || Vn["CJK Compatibility"](t1) || Vn["CJK Radicals Supplement"](t1) || Vn["CJK Strokes"](t1) || !(!Vn["CJK Symbols and Punctuation"](t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || Vn["CJK Unified Ideographs Extension A"](t1) || Vn["CJK Unified Ideographs"](t1) || Vn["Enclosed CJK Letters and Months"](t1) || Vn["Hangul Compatibility Jamo"](t1) || Vn["Hangul Jamo Extended-A"](t1) || Vn["Hangul Jamo Extended-B"](t1) || Vn["Hangul Jamo"](t1) || Vn["Hangul Syllables"](t1) || Vn.Hiragana(t1) || Vn["Ideographic Description Characters"](t1) || Vn.Kanbun(t1) || Vn["Kangxi Radicals"](t1) || Vn["Katakana Phonetic Extensions"](t1) || Vn.Katakana(t1) && 12540 !== t1 || !(!Vn["Halfwidth and Fullwidth Forms"](t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!Vn["Small Form Variants"](t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || Vn["Unified Canadian Aboriginal Syllabics"](t1) || Vn["Unified Canadian Aboriginal Syllabics Extended"](t1) || Vn["Vertical Forms"](t1) || Vn["Yijing Hexagram Symbols"](t1) || Vn["Yi Syllables"](t1) || Vn["Yi Radicals"](t1))));
        }
        function Dn(t1) {
            return !(Ln(t1) || function(t1) {
                return !!(Vn["Latin-1 Supplement"](t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || Vn["General Punctuation"](t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || Vn["Letterlike Symbols"](t1) || Vn["Number Forms"](t1) || Vn["Miscellaneous Technical"](t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || Vn["Control Pictures"](t1) && 9251 !== t1 || Vn["Optical Character Recognition"](t1) || Vn["Enclosed Alphanumerics"](t1) || Vn["Geometric Shapes"](t1) || Vn["Miscellaneous Symbols"](t1) && !(t1 >= 9754 && t1 <= 9759) || Vn["Miscellaneous Symbols and Arrows"](t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || Vn["CJK Symbols and Punctuation"](t1) || Vn.Katakana(t1) || Vn["Private Use Area"](t1) || Vn["CJK Compatibility Forms"](t1) || Vn["Small Form Variants"](t1) || Vn["Halfwidth and Fullwidth Forms"](t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function $n(t1) {
            return t1 >= 1424 && t1 <= 2303 || Vn["Arabic Presentation Forms-A"](t1) || Vn["Arabic Presentation Forms-B"](t1);
        }
        function Rn(t1, e1) {
            return !(!e1 && $n(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || Vn.Khmer(t1));
        }
        function On(t1) {
            for (const e1 of t1)if ($n(e1.charCodeAt(0))) return !0;
            return !1;
        }
        const Un = "deferred", qn = "loading", jn = "loaded";
        let Nn = null, Zn = "unavailable", Kn = null;
        const Gn = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (Zn = "error"), Nn && Nn(t1);
        };
        function Jn() {
            Xn.fire(new tt("pluginStateChange", {
                pluginStatus: Zn,
                pluginURL: Kn
            }));
        }
        const Xn = new rt, Yn = function() {
            return Zn;
        }, Hn = function() {
            if (Zn !== Un || !Kn) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Zn = qn, Jn(), Kn && K({
                url: Kn
            }, (t1)=>{
                t1 ? Gn(t1) : (Zn = jn, Jn());
            });
        }, Wn = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>Zn === jn || null != Wn.applyArabicShaping,
            isLoading: ()=>Zn === qn,
            setState (t1) {
                if (!g()) throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
                Zn = t1.pluginStatus, Kn = t1.pluginURL;
            },
            isParsed () {
                if (!g()) throw new Error("rtl-text-plugin is only parsed on the worker-threads");
                return null != Wn.applyArabicShaping && null != Wn.processBidirectionalText && null != Wn.processStyledBidirectionalText;
            },
            getPluginURL () {
                if (!g()) throw new Error("rtl-text-plugin url can only be queried from the worker threads");
                return Kn;
            }
        };
        class Qn {
            constructor(t1, e1){
                this.zoom = t1, e1 ? (this.now = e1.now, this.fadeDuration = e1.fadeDuration, this.zoomHistory = e1.zoomHistory, this.transition = e1.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Pn, this.transition = {});
            }
            isSupportedScript(t1) {
                return function(t1, e1) {
                    for (const r of t1)if (!Rn(r.charCodeAt(0), e1)) return !1;
                    return !0;
                }(t1, Wn.isLoaded());
            }
            crossFadingFactor() {
                return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
                const t1 = this.zoom, e1 = t1 - Math.floor(t1), r = this.crossFadingFactor();
                return t1 > this.zoomHistory.lastIntegerZoom ? {
                    fromScale: 2,
                    toScale: 1,
                    t: e1 + (1 - e1) * r
                } : {
                    fromScale: .5,
                    toScale: 1,
                    t: 1 - (1 - r) * e1
                };
            }
        }
        class ti {
            constructor(t1, e1){
                this.property = t1, this.value = e1, this.expression = function(t1, e1) {
                    if (kr(t1)) return new $r(t1, e1);
                    if (Er(t1)) {
                        const r = Dr(t1, e1);
                        if ("error" === r.result) throw new Error(r.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return r.value;
                    }
                    {
                        let r = t1;
                        return "color" === e1.type && "string" == typeof t1 ? r = Ft.parse(t1) : "padding" !== e1.type || "number" != typeof t1 && !Array.isArray(t1) || (r = $t.parse(t1)), {
                            kind: "constant",
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e1 ? t1.specification.default : e1, t1.specification);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e1, r) {
                return this.property.possiblyEvaluate(this, t1, e1, r);
            }
        }
        class ei {
            constructor(t1){
                this.property = t1, this.value = new ti(t1, void 0);
            }
            transitioned(t1, e1) {
                return new ni(this.property, this.value, e1, o({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new ni(this.property, this.value, null, {}, 0);
            }
        }
        class ri {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues);
            }
            getValue(t1) {
                return p(this._values[t1].value.value);
            }
            setValue(t1, e1) {
                Object.prototype.hasOwnProperty.call(this._values, t1) || (this._values[t1] = new ei(this._values[t1].property)), this._values[t1].value = new ti(this._values[t1].property, null === e1 ? void 0 : p(e1));
            }
            getTransition(t1) {
                return p(this._values[t1].transition);
            }
            setTransition(t1, e1) {
                Object.prototype.hasOwnProperty.call(this._values, t1) || (this._values[t1] = new ei(this._values[t1].property)), this._values[t1].transition = p(e1) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e1 of Object.keys(this._values)){
                    const r = this.getValue(e1);
                    void 0 !== r && (t1[e1] = r);
                    const n = this.getTransition(e1);
                    void 0 !== n && (t1[`${e1}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e1) {
                const r = new ii(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e1._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new ii(this._properties);
                for (const e1 of Object.keys(this._values))t1._values[e1] = this._values[e1].untransitioned();
                return t1;
            }
        }
        class ni {
            constructor(t1, e1, r, n, i){
                this.property = t1, this.value = e1, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e1, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e1, r), a = this.prior;
                if (a) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return a.possiblyEvaluate(t1, e1, r);
                    {
                        const s = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(a.possiblyEvaluate(t1, e1, r), i, function(t1) {
                            if (t1 <= 0) return 0;
                            if (t1 >= 1) return 1;
                            const e1 = t1 * t1, r = e1 * t1;
                            return 4 * (t1 < .5 ? r : 3 * (t1 - e1) + r - .75);
                        }(s));
                    }
                }
                return i;
            }
        }
        class ii {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e1, r) {
                const n = new oi(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e1, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class ai {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues);
            }
            getValue(t1) {
                return p(this._values[t1].value);
            }
            setValue(t1, e1) {
                this._values[t1] = new ti(this._values[t1].property, null === e1 ? void 0 : p(e1));
            }
            serialize() {
                const t1 = {};
                for (const e1 of Object.keys(this._values)){
                    const r = this.getValue(e1);
                    void 0 !== r && (t1[e1] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e1, r) {
                const n = new oi(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e1, r);
                return n;
            }
        }
        class si {
            constructor(t1, e1, r){
                this.property = t1, this.value = e1, this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e1, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e1, r, n);
            }
        }
        class oi {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class li {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1) {
                if (t1.isDataDriven()) throw new Error("Value should not be data driven");
                return t1.expression.evaluate(e1);
            }
            interpolate(t1, e1, r) {
                const n = Ie[this.specification.type];
                return n ? n(t1, e1, r) : t1;
            }
        }
        class ui {
            constructor(t1, e1){
                this.specification = t1, this.overrides = e1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                return new si(this, "constant" === t1.expression.kind || "camera" === t1.expression.kind ? {
                    kind: "constant",
                    value: t1.expression.evaluate(e1, null, {}, r, n)
                } : t1.expression, e1);
            }
            interpolate(t1, e1, r) {
                if ("constant" !== t1.value.kind || "constant" !== e1.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e1.value.value) return new si(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = Ie[this.specification.type];
                return n ? new si(this, {
                    kind: "constant",
                    value: n(t1.value.value, e1.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e1, r, n, i, a) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e1, r, n, i, a);
            }
        }
        class ci extends ui {
            possiblyEvaluate(t1, e1, r, n) {
                if (void 0 === t1.value) return new si(this, {
                    kind: "constant",
                    value: void 0
                }, e1);
                if ("constant" === t1.expression.kind) {
                    const i = t1.expression.evaluate(e1, null, {}, r, n), a = "resolvedImage" === t1.property.specification.type && "string" != typeof i ? i.name : i, s = this._calculate(a, a, a, e1);
                    return new si(this, {
                        kind: "constant",
                        value: s
                    }, e1);
                }
                if ("camera" === t1.expression.kind) {
                    const r = this._calculate(t1.expression.evaluate({
                        zoom: e1.zoom - 1
                    }), t1.expression.evaluate({
                        zoom: e1.zoom
                    }), t1.expression.evaluate({
                        zoom: e1.zoom + 1
                    }), e1);
                    return new si(this, {
                        kind: "constant",
                        value: r
                    }, e1);
                }
                return new si(this, t1.expression, e1);
            }
            evaluate(t1, e1, r, n, i, a) {
                if ("source" === t1.kind) {
                    const s = t1.evaluate(e1, r, n, i, a);
                    return this._calculate(s, s, s, e1);
                }
                return "composite" === t1.kind ? this._calculate(t1.evaluate({
                    zoom: Math.floor(e1.zoom) - 1
                }, r, n), t1.evaluate({
                    zoom: Math.floor(e1.zoom)
                }, r, n), t1.evaluate({
                    zoom: Math.floor(e1.zoom) + 1
                }, r, n), e1) : t1.value;
            }
            _calculate(t1, e1, r, n) {
                return n.zoom > n.zoomHistory.lastIntegerZoom ? {
                    from: t1,
                    to: e1
                } : {
                    from: r,
                    to: e1
                };
            }
            interpolate(t1) {
                return t1;
            }
        }
        class hi {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                if (void 0 !== t1.value) {
                    if ("constant" === t1.expression.kind) {
                        const i = t1.expression.evaluate(e1, null, {}, r, n);
                        return this._calculate(i, i, i, e1);
                    }
                    return this._calculate(t1.expression.evaluate(new Qn(Math.floor(e1.zoom - 1), e1)), t1.expression.evaluate(new Qn(Math.floor(e1.zoom), e1)), t1.expression.evaluate(new Qn(Math.floor(e1.zoom + 1), e1)), e1);
                }
            }
            _calculate(t1, e1, r, n) {
                return n.zoom > n.zoomHistory.lastIntegerZoom ? {
                    from: t1,
                    to: e1
                } : {
                    from: r,
                    to: e1
                };
            }
            interpolate(t1) {
                return t1;
            }
        }
        class pi {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                return !!t1.expression.evaluate(e1, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class fi {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                for(const e1 in t1){
                    const r = t1[e1];
                    r.specification.overridable && this.overridableProperties.push(e1);
                    const n = this.defaultPropertyValues[e1] = new ti(r, void 0), i = this.defaultTransitionablePropertyValues[e1] = new ei(r);
                    this.defaultTransitioningPropertyValues[e1] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e1] = n.possiblyEvaluate({});
                }
            }
        }
        Mn("DataDrivenProperty", ui), Mn("DataConstantProperty", li), Mn("CrossFadedDataDrivenProperty", ci), Mn("CrossFadedProperty", hi), Mn("ColorRampProperty", pi);
        const di = "-transition";
        class yi extends rt {
            constructor(t1, e1){
                if (super(), this.id = t1.id, this.type = t1.type, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1
                }, "custom" !== t1.type && (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, "background" !== t1.type && (this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter), e1.layout && (this._unevaluatedLayout = new ai(e1.layout)), e1.paint)) {
                    this._transitionablePaint = new ri(e1.paint);
                    for(const e1 in t1.paint)this.setPaintProperty(e1, t1.paint[e1], {
                        validate: !1
                    });
                    for(const e1 in t1.layout)this.setLayoutProperty(e1, t1.layout[e1], {
                        validate: !1
                    });
                    this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new oi(e1.paint);
                }
            }
            getCrossfadeParameters() {
                return this._crossfadeParameters;
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e1, r = {}) {
                null != e1 && this._validate(An, `layers.${this.id}.layout.${t1}`, t1, e1, r) || ("visibility" !== t1 ? this._unevaluatedLayout.setValue(t1, e1) : this.visibility = e1);
            }
            getPaintProperty(t1) {
                return t1.endsWith(di) ? this._transitionablePaint.getTransition(t1.slice(0, -di.length)) : this._transitionablePaint.getValue(t1);
            }
            setPaintProperty(t1, e1, r = {}) {
                if (null != e1 && this._validate(_n, `layers.${this.id}.paint.${t1}`, t1, e1, r)) return !1;
                if (t1.endsWith(di)) return this._transitionablePaint.setTransition(t1.slice(0, -di.length), e1 || void 0), !1;
                {
                    const r = this._transitionablePaint._values[t1], n = "cross-faded-data-driven" === r.property.specification["property-type"], i = r.value.isDataDriven(), a = r.value;
                    this._transitionablePaint.setValue(t1, e1), this._handleSpecialPaintPropertyUpdate(t1);
                    const s = this._transitionablePaint._values[t1].value;
                    return s.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t1, a, s);
                }
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            _handleOverridablePaintPropertyUpdate(t1, e1, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e1) {
                t1.getCrossfadeParameters && (this._crossfadeParameters = t1.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e1)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e1);
            }
            serialize() {
                const t1 = {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return this.visibility && (t1.layout = t1.layout || {}, t1.layout.visibility = this.visibility), h(t1, (t1, e1)=>!(void 0 === t1 || "layout" === e1 && !Object.keys(t1).length || "paint" === e1 && !Object.keys(t1).length));
            }
            _validate(t1, e1, r, n, i = {}) {
                return (!i || !1 !== i.validate) && kn(this, t1.call(bn, {
                    key: e1,
                    layerType: this.type,
                    objectKey: r,
                    value: n,
                    styleSpec: nt,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    }
                }));
            }
            is3D() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            resize() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e1 = this.paint.get(t1);
                    if (e1 instanceof si && br(e1.property.specification) && ("source" === e1.value.kind || "composite" === e1.value.kind) && e1.value.isStateDependent) return !0;
                }
                return !1;
            }
        }
        const mi = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class gi {
            constructor(t1, e1){
                this._structArray = t1, this._pos1 = e1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class xi {
            constructor(){
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }
            static serialize(t1, e1) {
                return t1._trim(), e1 && (t1.isTransferred = !0, e1.push(t1.arrayBuffer)), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e1 = Object.create(this.prototype);
                return e1.arrayBuffer = t1.arrayBuffer, e1.length = t1.length, e1.capacity = t1.arrayBuffer.byteLength / e1.bytesPerElement, e1._refreshViews(), e1;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e1 = this.uint8;
                    this._refreshViews(), e1 && this.uint8.set(e1);
                }
            }
            _refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
        }
        function vi(t1, e1 = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = mi[t1.type].BYTES_PER_ELEMENT, a = r = bi(r, Math.max(e1, i)), s = t1.components || 1;
                    return n = Math.max(n, i), r += i * s, {
                        name: t1.name,
                        type: t1.type,
                        components: s,
                        offset: a
                    };
                }),
                size: bi(r, Math.max(n, e1)),
                alignment: e1
            };
        }
        function bi(t1, e1) {
            return Math.ceil(t1 / e1) * e1;
        }
        class wi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e1, this.int16[n + 1] = r, t1;
            }
        }
        wi.prototype.bytesPerElement = 4, Mn("StructArrayLayout2i4", wi);
        class _i extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const a = 4 * t1;
                return this.int16[a + 0] = e1, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, t1;
            }
        }
        _i.prototype.bytesPerElement = 8, Mn("StructArrayLayout4i8", _i);
        class Ai extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i, a);
            }
            emplace(t1, e1, r, n, i, a, s) {
                const o = 6 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = a, this.int16[o + 5] = s, t1;
            }
        }
        Ai.prototype.bytesPerElement = 12, Mn("StructArrayLayout2i4i12", Ai);
        class ki extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i, a);
            }
            emplace(t1, e1, r, n, i, a, s) {
                const o = 4 * t1, l = 8 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.uint8[l + 4] = n, this.uint8[l + 5] = i, this.uint8[l + 6] = a, this.uint8[l + 7] = s, t1;
            }
        }
        ki.prototype.bytesPerElement = 8, Mn("StructArrayLayout2i4ub8", ki);
        class Si extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e1, this.float32[n + 1] = r, t1;
            }
        }
        Si.prototype.bytesPerElement = 8, Mn("StructArrayLayout2f8", Si);
        class Ii extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a, s, o, l, u) {
                const c = this.length;
                return this.resize(c + 1), this.emplace(c, t1, e1, r, n, i, a, s, o, l, u);
            }
            emplace(t1, e1, r, n, i, a, s, o, l, u, c) {
                const h = 10 * t1;
                return this.uint16[h + 0] = e1, this.uint16[h + 1] = r, this.uint16[h + 2] = n, this.uint16[h + 3] = i, this.uint16[h + 4] = a, this.uint16[h + 5] = s, this.uint16[h + 6] = o, this.uint16[h + 7] = l, this.uint16[h + 8] = u, this.uint16[h + 9] = c, t1;
            }
        }
        Ii.prototype.bytesPerElement = 20, Mn("StructArrayLayout10ui20", Ii);
        class Mi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a, s, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e1, r, n, i, a, s, o, l, u, c, h);
            }
            emplace(t1, e1, r, n, i, a, s, o, l, u, c, h, p) {
                const f = 12 * t1;
                return this.int16[f + 0] = e1, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = a, this.uint16[f + 5] = s, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t1;
            }
        }
        Mi.prototype.bytesPerElement = 24, Mn("StructArrayLayout4i4ui4i24", Mi);
        class zi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e1, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        zi.prototype.bytesPerElement = 12, Mn("StructArrayLayout3f12", zi);
        class Bi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.uint32[1 * t1 + 0] = e1, t1;
            }
        }
        Bi.prototype.bytesPerElement = 4, Mn("StructArrayLayout1ul4", Bi);
        class Ci extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a, s, o, l) {
                const u = this.length;
                return this.resize(u + 1), this.emplace(u, t1, e1, r, n, i, a, s, o, l);
            }
            emplace(t1, e1, r, n, i, a, s, o, l, u) {
                const c = 10 * t1, h = 5 * t1;
                return this.int16[c + 0] = e1, this.int16[c + 1] = r, this.int16[c + 2] = n, this.int16[c + 3] = i, this.int16[c + 4] = a, this.int16[c + 5] = s, this.uint32[h + 3] = o, this.uint16[c + 8] = l, this.uint16[c + 9] = u, t1;
            }
        }
        Ci.prototype.bytesPerElement = 20, Mn("StructArrayLayout6i1ul2ui20", Ci);
        class Pi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i, a);
            }
            emplace(t1, e1, r, n, i, a, s) {
                const o = 6 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = a, this.int16[o + 5] = s, t1;
            }
        }
        Pi.prototype.bytesPerElement = 12, Mn("StructArrayLayout2i2i2i12", Pi);
        class Vi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, a) {
                const s = 4 * t1, o = 8 * t1;
                return this.float32[s + 0] = e1, this.float32[s + 1] = r, this.float32[s + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = a, t1;
            }
        }
        Vi.prototype.bytesPerElement = 16, Mn("StructArrayLayout2f1f2i16", Vi);
        class Ei extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const a = 12 * t1, s = 3 * t1;
                return this.uint8[a + 0] = e1, this.uint8[a + 1] = r, this.float32[s + 1] = n, this.float32[s + 2] = i, t1;
            }
        }
        Ei.prototype.bytesPerElement = 12, Mn("StructArrayLayout2ub2f12", Ei);
        class Fi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e1, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        Fi.prototype.bytesPerElement = 6, Mn("StructArrayLayout3ui6", Fi);
        class Ti extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m) {
                const g = this.length;
                return this.resize(g + 1), this.emplace(g, t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m);
            }
            emplace(t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m, g) {
                const x = 24 * t1, v = 12 * t1, b = 48 * t1;
                return this.int16[x + 0] = e1, this.int16[x + 1] = r, this.uint16[x + 2] = n, this.uint16[x + 3] = i, this.uint32[v + 2] = a, this.uint32[v + 3] = s, this.uint32[v + 4] = o, this.uint16[x + 10] = l, this.uint16[x + 11] = u, this.uint16[x + 12] = c, this.float32[v + 7] = h, this.float32[v + 8] = p, this.uint8[b + 36] = f, this.uint8[b + 37] = d, this.uint8[b + 38] = y, this.uint32[v + 10] = m, this.int16[x + 22] = g, t1;
            }
        }
        Ti.prototype.bytesPerElement = 48, Mn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ti);
        class Li extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, k, S, I, M) {
                const z = this.length;
                return this.resize(z + 1), this.emplace(z, t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, k, S, I, M);
            }
            emplace(t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, k, S, I, M, z) {
                const B = 34 * t1, C = 17 * t1;
                return this.int16[B + 0] = e1, this.int16[B + 1] = r, this.int16[B + 2] = n, this.int16[B + 3] = i, this.int16[B + 4] = a, this.int16[B + 5] = s, this.int16[B + 6] = o, this.int16[B + 7] = l, this.uint16[B + 8] = u, this.uint16[B + 9] = c, this.uint16[B + 10] = h, this.uint16[B + 11] = p, this.uint16[B + 12] = f, this.uint16[B + 13] = d, this.uint16[B + 14] = y, this.uint16[B + 15] = m, this.uint16[B + 16] = g, this.uint16[B + 17] = x, this.uint16[B + 18] = v, this.uint16[B + 19] = b, this.uint16[B + 20] = w, this.uint16[B + 21] = _, this.uint16[B + 22] = A, this.uint32[C + 12] = k, this.float32[C + 13] = S, this.float32[C + 14] = I, this.float32[C + 15] = M, this.float32[C + 16] = z, t1;
            }
        }
        Li.prototype.bytesPerElement = 68, Mn("StructArrayLayout8i15ui1ul4f68", Li);
        class Di extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.float32[1 * t1 + 0] = e1, t1;
            }
        }
        Di.prototype.bytesPerElement = 4, Mn("StructArrayLayout1f4", Di);
        class $i extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e1, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        $i.prototype.bytesPerElement = 6, Mn("StructArrayLayout3i6", $i);
        class Ri extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 4 * t1;
                return this.uint32[2 * t1 + 0] = e1, this.uint16[i + 2] = r, this.uint16[i + 3] = n, t1;
            }
        }
        Ri.prototype.bytesPerElement = 8, Mn("StructArrayLayout1ul2ui8", Ri);
        class Oi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e1, this.uint16[n + 1] = r, t1;
            }
        }
        Oi.prototype.bytesPerElement = 4, Mn("StructArrayLayout2ui4", Oi);
        class Ui extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.uint16[1 * t1 + 0] = e1, t1;
            }
        }
        Ui.prototype.bytesPerElement = 2, Mn("StructArrayLayout1ui2", Ui);
        class qi extends xi {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const a = 4 * t1;
                return this.float32[a + 0] = e1, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, t1;
            }
        }
        qi.prototype.bytesPerElement = 16, Mn("StructArrayLayout4f16", qi);
        class ji extends gi {
            get anchorPointX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
                return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
                return new S(this.anchorPointX, this.anchorPointY);
            }
        }
        ji.prototype.size = 20;
        class Ni extends Ci {
            get(t1) {
                return new ji(this, t1);
            }
        }
        Mn("CollisionBoxArray", Ni);
        class Zi extends gi {
            get anchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 37] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 38] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 10] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 22];
            }
        }
        Zi.prototype.size = 48;
        class Ki extends Ti {
            get(t1) {
                return new Zi(this, t1);
            }
        }
        Mn("PlacedSymbolArray", Ki);
        class Gi extends gi {
            get anchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 12] = t1;
            }
            get textBoxScale() {
                return this._structArray.float32[this._pos4 + 13];
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 14];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 15];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 16];
            }
        }
        Gi.prototype.size = 68;
        class Ji extends Li {
            get(t1) {
                return new Gi(this, t1);
            }
        }
        Mn("SymbolInstanceArray", Ji);
        class Xi extends Di {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        Mn("GlyphOffsetArray", Xi);
        class Yi extends $i {
            getx(t1) {
                return this.int16[3 * t1 + 0];
            }
            gety(t1) {
                return this.int16[3 * t1 + 1];
            }
            gettileUnitDistanceFromAnchor(t1) {
                return this.int16[3 * t1 + 2];
            }
        }
        Mn("SymbolLineVertexArray", Yi);
        class Hi extends gi {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
        }
        Hi.prototype.size = 8;
        class Wi extends Ri {
            get(t1) {
                return new Hi(this, t1);
            }
        }
        Mn("FeatureIndexArray", Wi);
        class Qi extends wi {
        }
        class ta extends wi {
        }
        class ea extends wi {
        }
        class ra extends Ai {
        }
        class na extends ki {
        }
        class ia extends Si {
        }
        class aa extends Ii {
        }
        class sa extends Mi {
        }
        class oa extends zi {
        }
        class la extends Bi {
        }
        class ua extends Pi {
        }
        class ca extends Ei {
        }
        class ha extends Fi {
        }
        class pa extends Oi {
        }
        const fa = vi([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: da } = fa;
        class ya {
            constructor(t1 = []){
                this.segments = t1;
            }
            prepareSegment(t1, e1, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > ya.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${ya.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > ya.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e1.length,
                    primitiveOffset: r.length,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e1 in t1.vaos)t1.vaos[e1].destroy();
            }
            static simpleSegment(t1, e1, r, n) {
                return new ya([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e1,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        function ma(t1, e1) {
            return 256 * (t1 = a(Math.floor(t1), 0, 255)) + a(Math.floor(e1), 0, 255);
        }
        ya.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Mn("SegmentVector", ya);
        const ga = vi([
            {
                name: "a_pattern_from",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pattern_to",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio_from",
                components: 1,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio_to",
                components: 1,
                type: "Uint16"
            }
        ]);
        var xa = {
            exports: {}
        }, va = {
            exports: {}
        };
        va.exports = function(t1, e1) {
            var r, n, i, a, s, o, l, u;
            for(n = t1.length - (r = 3 & t1.length), i = e1, s = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (a = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16);
            switch(l = 0, r){
                case 3:
                    l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                case 2:
                    l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                case 1:
                    i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
            }
            return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
        };
        var ba = {
            exports: {}
        };
        ba.exports = function(t1, e1) {
            for(var r, n = t1.length, i = e1 ^ n, a = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(a) | (255 & t1.charCodeAt(++a)) << 8 | (255 & t1.charCodeAt(++a)) << 16 | (255 & t1.charCodeAt(++a)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++a;
            switch(n){
                case 3:
                    i ^= (255 & t1.charCodeAt(a + 2)) << 16;
                case 2:
                    i ^= (255 & t1.charCodeAt(a + 1)) << 8;
                case 1:
                    i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(a))) + ((1540483477 * (i >>> 16) & 65535) << 16);
            }
            return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
        };
        var wa = va.exports, _a = ba.exports;
        xa.exports = wa, xa.exports.murmur3 = wa, xa.exports.murmur2 = _a;
        class Aa {
            constructor(){
                this.ids = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e1, r, n) {
                this.ids.push(ka(t1)), this.positions.push(e1, r, n);
            }
            getPositions(t1) {
                if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
                const e1 = ka(t1);
                let r = 0, n = this.ids.length - 1;
                for(; r < n;){
                    const t1 = r + n >> 1;
                    this.ids[t1] >= e1 ? n = t1 : r = t1 + 1;
                }
                const i = [];
                for(; this.ids[r] === e1;)i.push({
                    index: this.positions[3 * r],
                    start: this.positions[3 * r + 1],
                    end: this.positions[3 * r + 2]
                }), r++;
                return i;
            }
            static serialize(t1, e1) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return Sa(r, n, 0, r.length - 1), e1 && e1.push(r.buffer, n.buffer), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e1 = new Aa;
                return e1.ids = t1.ids, e1.positions = t1.positions, e1.indexed = !0, e1;
            }
        }
        function ka(t1) {
            const e1 = +t1;
            return !isNaN(e1) && e1 <= Number.MAX_SAFE_INTEGER ? e1 : xa.exports(String(t1));
        }
        function Sa(t1, e1, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let a = r - 1, s = n + 1;
                for(;;){
                    do a++;
                    while (t1[a] < i);
                    do s--;
                    while (t1[s] > i);
                    if (a >= s) break;
                    Ia(t1, a, s), Ia(e1, 3 * a, 3 * s), Ia(e1, 3 * a + 1, 3 * s + 1), Ia(e1, 3 * a + 2, 3 * s + 2);
                }
                s - r < n - s ? (Sa(t1, e1, r, s), r = s + 1) : (Sa(t1, e1, s + 1, n), n = s);
            }
        }
        function Ia(t1, e1, r) {
            const n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        Mn("FeaturePositionMap", Aa);
        class Ma {
            constructor(t1, e1){
                this.gl = t1.gl, this.location = e1;
            }
        }
        class za extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = 0;
            }
            set(t1) {
                this.current !== t1 && (this.current = t1, this.gl.uniform1f(this.location, t1));
            }
        }
        class Ba extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1) {
                t1[0] === this.current[0] && t1[1] === this.current[1] && t1[2] === this.current[2] && t1[3] === this.current[3] || (this.current = t1, this.gl.uniform4f(this.location, t1[0], t1[1], t1[2], t1[3]));
            }
        }
        class Ca extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = Ft.transparent;
            }
            set(t1) {
                t1.r === this.current.r && t1.g === this.current.g && t1.b === this.current.b && t1.a === this.current.a || (this.current = t1, this.gl.uniform4f(this.location, t1.r, t1.g, t1.b, t1.a));
            }
        }
        const Pa = new Float32Array(16);
        function Va(t1) {
            return [
                ma(255 * t1.r, 255 * t1.g),
                ma(255 * t1.b, 255 * t1.a)
            ];
        }
        class Ea {
            constructor(t1, e1, r){
                this.value = t1, this.uniformNames = e1.map((t1)=>`u_${t1}`), this.type = r;
            }
            setUniform(t1, e1, r) {
                t1.set(r.constantOr(this.value));
            }
            getBinding(t1, e1, r) {
                return "color" === this.type ? new Ca(t1, e1) : new za(t1, e1);
            }
        }
        class Fa {
            constructor(t1, e1){
                this.uniformNames = e1.map((t1)=>`u_${t1}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t1, e1) {
                this.pixelRatioFrom = e1.pixelRatio, this.pixelRatioTo = t1.pixelRatio, this.patternFrom = e1.tlbr, this.patternTo = t1.tlbr;
            }
            setUniform(t1, e1, r, n) {
                const i = "u_pattern_to" === n ? this.patternTo : "u_pattern_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null;
                i && t1.set(i);
            }
            getBinding(t1, e1, r) {
                return "u_pattern" === r.substr(0, 9) ? new Ba(t1, e1) : new za(t1, e1);
            }
        }
        class Ta {
            constructor(t1, e1, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e1.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e1, r, n, i) {
                const a = this.paintVertexArray.length, s = this.expression.evaluate(new Qn(0), e1, {}, n, [], i);
                this.paintVertexArray.resize(t1), this._setPaintValue(a, t1, s);
            }
            updatePaintArray(t1, e1, r, n) {
                const i = this.expression.evaluate({
                    zoom: 0
                }, r, n);
                this._setPaintValue(t1, e1, i);
            }
            _setPaintValue(t1, e1, r) {
                if ("color" === this.type) {
                    const n = Va(r);
                    for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, n[0], n[1]);
                } else {
                    for(let n = t1; n < e1; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class La {
            constructor(t1, e1, r, n, i, a){
                this.expression = t1, this.uniformNames = e1.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e1.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new a;
            }
            populatePaintArray(t1, e1, r, n, i) {
                const a = this.expression.evaluate(new Qn(this.zoom), e1, {}, n, [], i), s = this.expression.evaluate(new Qn(this.zoom + 1), e1, {}, n, [], i), o = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(o, t1, a, s);
            }
            updatePaintArray(t1, e1, r, n) {
                const i = this.expression.evaluate({
                    zoom: this.zoom
                }, r, n), a = this.expression.evaluate({
                    zoom: this.zoom + 1
                }, r, n);
                this._setPaintValue(t1, e1, i, a);
            }
            _setPaintValue(t1, e1, r, n) {
                if ("color" === this.type) {
                    const i = Va(r), a = Va(n);
                    for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, i[0], i[1], a[0], a[1]);
                } else {
                    for(let i = t1; i < e1; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e1) {
                const r = this.useIntegerZoom ? Math.floor(e1.zoom) : e1.zoom, n = a(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);
                t1.set(n);
            }
            getBinding(t1, e1, r) {
                return new za(t1, e1);
            }
        }
        class Da {
            constructor(t1, e1, r, n, i, a){
                this.expression = t1, this.type = e1, this.useIntegerZoom = r, this.zoom = n, this.layerId = a, this.zoomInPaintVertexArray = new i, this.zoomOutPaintVertexArray = new i;
            }
            populatePaintArray(t1, e1, r) {
                const n = this.zoomInPaintVertexArray.length;
                this.zoomInPaintVertexArray.resize(t1), this.zoomOutPaintVertexArray.resize(t1), this._setPaintValues(n, t1, e1.patterns && e1.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e1, r, n, i) {
                this._setPaintValues(t1, e1, r.patterns && r.patterns[this.layerId], i);
            }
            _setPaintValues(t1, e1, r, n) {
                if (!n || !r) return;
                const { min: i, mid: a, max: s } = r, o = n[i], l = n[a], u = n[s];
                if (o && l && u) for(let r = t1; r < e1; r++)this.zoomInPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], l.pixelRatio, o.pixelRatio), this.zoomOutPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], u.tl[0], u.tl[1], u.br[0], u.br[1], l.pixelRatio, u.pixelRatio);
            }
            upload(t1) {
                this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t1.createVertexBuffer(this.zoomInPaintVertexArray, ga.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t1.createVertexBuffer(this.zoomOutPaintVertexArray, ga.members, this.expression.isStateDependent));
            }
            destroy() {
                this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
        }
        class $a {
            constructor(t1, e1, r){
                this.binders = {}, this._buffers = [];
                const n = [];
                for(const i in t1.paint._values){
                    if (!r(i)) continue;
                    const a = t1.paint.get(i);
                    if (!(a instanceof si && br(a.property.specification))) continue;
                    const s = Oa(i, t1.type), o = a.value, l = a.property.specification.type, u = a.property.useIntegerZoom, c = a.property.specification["property-type"], h = "cross-faded" === c || "cross-faded-data-driven" === c;
                    if ("constant" === o.kind) this.binders[i] = h ? new Fa(o.value, s) : new Ea(o.value, s, l), n.push(`/u_${i}`);
                    else if ("source" === o.kind || h) {
                        const r = Ua(i, l, "source");
                        this.binders[i] = h ? new Da(o, l, u, e1, r, t1.id) : new Ta(o, s, l, r), n.push(`/a_${i}`);
                    } else {
                        const t1 = Ua(i, l, "composite");
                        this.binders[i] = new La(o, s, l, u, e1, t1), n.push(`/z_${i}`);
                    }
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e1 = this.binders[t1];
                return e1 instanceof Ta || e1 instanceof La ? e1.maxValue : 0;
            }
            populatePaintArrays(t1, e1, r, n, i) {
                for(const a in this.binders){
                    const s = this.binders[a];
                    (s instanceof Ta || s instanceof La || s instanceof Da) && s.populatePaintArray(t1, e1, r, n, i);
                }
            }
            setConstantPatternPositions(t1, e1) {
                for(const r in this.binders){
                    const n = this.binders[r];
                    n instanceof Fa && n.setConstantPatternPositions(t1, e1);
                }
            }
            updatePaintArrays(t1, e1, r, n, i) {
                let a = !1;
                for(const s in t1){
                    const o = e1.getPositions(s);
                    for (const e1 of o){
                        const o = r.feature(e1.index);
                        for(const r in this.binders){
                            const l = this.binders[r];
                            if ((l instanceof Ta || l instanceof La || l instanceof Da) && !0 === l.expression.isStateDependent) {
                                const u = n.paint.get(r);
                                l.expression = u.value, l.updatePaintArray(e1.start, e1.end, o, t1[s], i), a = !0;
                            }
                        }
                    }
                }
                return a;
            }
            defines() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    (r instanceof Ea || r instanceof Fa) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getBinderAttributes() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (r instanceof Ta || r instanceof La) for(let e1 = 0; e1 < r.paintVertexAttributes.length; e1++)t1.push(r.paintVertexAttributes[e1].name);
                    else if (r instanceof Da) for(let e1 = 0; e1 < ga.members.length; e1++)t1.push(ga.members[e1].name);
                }
                return t1;
            }
            getBinderUniforms() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (r instanceof Ea || r instanceof Fa || r instanceof La) for (const e1 of r.uniformNames)t1.push(e1);
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1, e1) {
                const r = [];
                for(const n in this.binders){
                    const i = this.binders[n];
                    if (i instanceof Ea || i instanceof Fa || i instanceof La) {
                        for (const a of i.uniformNames)if (e1[a]) {
                            const s = i.getBinding(t1, e1[a], a);
                            r.push({
                                name: a,
                                property: n,
                                binding: s
                            });
                        }
                    }
                }
                return r;
            }
            setUniforms(t1, e1, r, n) {
                for (const { name: t1, property: i, binding: a } of e1)this.binders[i].setUniform(a, n, r.get(i), t1);
            }
            updatePaintBuffers(t1) {
                this._buffers = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (t1 && r instanceof Da) {
                        const e1 = 2 === t1.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;
                        e1 && this._buffers.push(e1);
                    } else (r instanceof Ta || r instanceof La) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);
                }
            }
            upload(t1) {
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    (r instanceof Ta || r instanceof La || r instanceof Da) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e1 = this.binders[t1];
                    (e1 instanceof Ta || e1 instanceof La || e1 instanceof Da) && e1.destroy();
                }
            }
        }
        class Ra {
            constructor(t1, e1, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new $a(n, e1, r);
                this.needsUpload = !1, this._featureMap = new Aa, this._bufferOffset = 0;
            }
            populatePaintArrays(t1, e1, r, n, i, a) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e1, n, i, a);
                void 0 !== e1.id && this._featureMap.add(e1.id, r, this._bufferOffset, t1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e1, r, n) {
                for (const i of r)this.needsUpload = this.programConfigurations[i.id].updatePaintArrays(t1, this._featureMap, e1, i, n) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e1 in this.programConfigurations)this.programConfigurations[e1].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        function Oa(t1, e1) {
            return ({
                "text-opacity": [
                    "opacity"
                ],
                "icon-opacity": [
                    "opacity"
                ],
                "text-color": [
                    "fill_color"
                ],
                "icon-color": [
                    "fill_color"
                ],
                "text-halo-color": [
                    "halo_color"
                ],
                "icon-halo-color": [
                    "halo_color"
                ],
                "text-halo-blur": [
                    "halo_blur"
                ],
                "icon-halo-blur": [
                    "halo_blur"
                ],
                "text-halo-width": [
                    "halo_width"
                ],
                "icon-halo-width": [
                    "halo_width"
                ],
                "line-gap-width": [
                    "gapwidth"
                ],
                "line-pattern": [
                    "pattern_to",
                    "pattern_from",
                    "pixel_ratio_to",
                    "pixel_ratio_from"
                ],
                "fill-pattern": [
                    "pattern_to",
                    "pattern_from",
                    "pixel_ratio_to",
                    "pixel_ratio_from"
                ],
                "fill-extrusion-pattern": [
                    "pattern_to",
                    "pattern_from",
                    "pixel_ratio_to",
                    "pixel_ratio_from"
                ]
            })[t1] || [
                t1.replace(`${e1}-`, "").replace(/-/g, "_")
            ];
        }
        function Ua(t1, e1, r) {
            const n = {
                color: {
                    source: Si,
                    composite: qi
                },
                number: {
                    source: Di,
                    composite: Si
                }
            }, i = function(t1) {
                return ({
                    "line-pattern": {
                        source: aa,
                        composite: aa
                    },
                    "fill-pattern": {
                        source: aa,
                        composite: aa
                    },
                    "fill-extrusion-pattern": {
                        source: aa,
                        composite: aa
                    }
                })[t1];
            }(t1);
            return i && i[r] || n[e1][r];
        }
        Mn("ConstantBinder", Ea), Mn("CrossFadedConstantBinder", Fa), Mn("SourceExpressionBinder", Ta), Mn("CrossFadedCompositeBinder", Da), Mn("CompositeExpressionBinder", La), Mn("ProgramConfiguration", $a, {
            omit: [
                "_buffers"
            ]
        }), Mn("ProgramConfigurationSet", Ra);
        var qa = 8192;
        const ja = Math.pow(2, 14) - 1, Na = -ja - 1;
        function Za(t1) {
            const e1 = qa / t1.extent, r = t1.loadGeometry();
            for(let t1 = 0; t1 < r.length; t1++){
                const n = r[t1];
                for(let t1 = 0; t1 < n.length; t1++){
                    const r = n[t1], i = Math.round(r.x * e1), s = Math.round(r.y * e1);
                    r.x = a(i, Na, ja), r.y = a(s, Na, ja), (i < r.x || i > r.x + 1 || s < r.y || s > r.y + 1) && d("Geometry exceeds allowed extent, reduce your vector tile buffer size");
                }
            }
            return r;
        }
        function Ka(t1, e1) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e1 ? Za(t1) : []
            };
        }
        function Ga(t1, e1, r, n, i) {
            t1.emplaceBack(2 * e1 + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        class Ja {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.layoutVertexArray = new ta, this.indexArray = new ha, this.segments = new ya, this.programConfigurations = new Ra(t1.layers, t1.zoom), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r) {
                const n = this.layers[0], i = [];
                let a = null, s = !1;
                "circle" === n.type && (a = n.layout.get("circle-sort-key"), s = !a.isConstant());
                for (const { feature: e1, id: n, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = Ka(e1, t1);
                    if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), u, r)) continue;
                    const c = s ? a.evaluate(u, {}, r) : void 0, h = {
                        id: n,
                        properties: e1.properties,
                        type: e1.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : Za(e1),
                        patterns: {},
                        sortKey: c
                    };
                    i.push(h);
                }
                s && i.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                for (const n of i){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n, o = t1[a].feature;
                    this.addFeature(n, i, a, r), e1.featureIndex.insert(o, i, a, s, this.index);
                }
            }
            update(t1, e1, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, da), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e1, r, n) {
                for (const r of e1)for (const e1 of r){
                    const r = e1.x, n = e1.y;
                    if (r < 0 || r >= qa || n < 0 || n >= qa) continue;
                    const i = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), a = i.vertexLength;
                    Ga(this.layoutVertexArray, r, n, -1, -1), Ga(this.layoutVertexArray, r, n, 1, -1), Ga(this.layoutVertexArray, r, n, 1, 1), Ga(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(a, a + 1, a + 2), this.indexArray.emplaceBack(a, a + 3, a + 2), i.vertexLength += 4, i.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n);
            }
        }
        function Xa(t1, e1) {
            for(let r = 0; r < t1.length; r++)if (is(e1, t1[r])) return !0;
            for(let r = 0; r < e1.length; r++)if (is(t1, e1[r])) return !0;
            return !!Qa(t1, e1);
        }
        function Ya(t1, e1, r) {
            return !!is(t1, e1) || !!es(e1, t1, r);
        }
        function Ha(t1, e1) {
            if (1 === t1.length) return ns(e1, t1[0]);
            for(let r = 0; r < e1.length; r++){
                const n = e1[r];
                for(let e1 = 0; e1 < n.length; e1++)if (is(t1, n[e1])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (ns(e1, t1[r])) return !0;
            for(let r = 0; r < e1.length; r++)if (Qa(t1, e1[r])) return !0;
            return !1;
        }
        function Wa(t1, e1, r) {
            if (t1.length > 1) {
                if (Qa(t1, e1)) return !0;
                for(let n = 0; n < e1.length; n++)if (es(e1[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (es(t1[n], e1, r)) return !0;
            return !1;
        }
        function Qa(t1, e1) {
            if (0 === t1.length || 0 === e1.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e1.length - 1; t1++)if (ts(n, i, e1[t1], e1[t1 + 1])) return !0;
            }
            return !1;
        }
        function ts(t1, e1, r, n) {
            return y(t1, r, n) !== y(e1, r, n) && y(t1, e1, r) !== y(t1, e1, n);
        }
        function es(t1, e1, r) {
            const n = r * r;
            if (1 === e1.length) return t1.distSqr(e1[0]) < n;
            for(let r = 1; r < e1.length; r++)if (rs(t1, e1[r - 1], e1[r]) < n) return !0;
            return !1;
        }
        function rs(t1, e1, r) {
            const n = e1.distSqr(r);
            if (0 === n) return t1.distSqr(e1);
            const i = ((t1.x - e1.x) * (r.x - e1.x) + (t1.y - e1.y) * (r.y - e1.y)) / n;
            return t1.distSqr(i < 0 ? e1 : i > 1 ? r : r.sub(e1)._mult(i)._add(e1));
        }
        function ns(t1, e1) {
            let r, n, i, a = !1;
            for(let s = 0; s < t1.length; s++){
                r = t1[s];
                for(let t1 = 0, s = r.length - 1; t1 < r.length; s = t1++)n = r[t1], i = r[s], n.y > e1.y != i.y > e1.y && e1.x < (i.x - n.x) * (e1.y - n.y) / (i.y - n.y) + n.x && (a = !a);
            }
            return a;
        }
        function is(t1, e1) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const a = t1[n], s = t1[i];
                a.y > e1.y != s.y > e1.y && e1.x < (s.x - a.x) * (e1.y - a.y) / (s.y - a.y) + a.x && (r = !r);
            }
            return r;
        }
        function as(t1, e1, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e1.x < n.x || t1.x > i.x && e1.x > i.x || t1.y < n.y && e1.y < n.y || t1.y > i.y && e1.y > i.y) return !1;
            const a = y(t1, e1, r[0]);
            return a !== y(t1, e1, r[1]) || a !== y(t1, e1, r[2]) || a !== y(t1, e1, r[3]);
        }
        function ss(t1, e1, r) {
            const n = e1.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e1.id).getMaxValue(t1);
        }
        function os(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function ls(t1, e1, r, n, i) {
            if (!e1[0] && !e1[1]) return t1;
            const a = S.convert(e1)._mult(i);
            "viewport" === r && a._rotate(-n);
            const s = [];
            for(let e1 = 0; e1 < t1.length; e1++)s.push(t1[e1].sub(a));
            return s;
        }
        Mn("CircleBucket", Ja, {
            omit: [
                "layers"
            ]
        });
        const us = new fi({
            "circle-sort-key": new ui(nt.layout_circle["circle-sort-key"])
        });
        var cs = {
            paint: new fi({
                "circle-radius": new ui(nt.paint_circle["circle-radius"]),
                "circle-color": new ui(nt.paint_circle["circle-color"]),
                "circle-blur": new ui(nt.paint_circle["circle-blur"]),
                "circle-opacity": new ui(nt.paint_circle["circle-opacity"]),
                "circle-translate": new li(nt.paint_circle["circle-translate"]),
                "circle-translate-anchor": new li(nt.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new li(nt.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new li(nt.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new ui(nt.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new ui(nt.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new ui(nt.paint_circle["circle-stroke-opacity"])
            }),
            layout: us
        }, hs = 1e-6, ps = "undefined" != typeof Float32Array ? Float32Array : Array;
        function fs() {
            var t1 = new ps(9);
            return ps != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
        }
        function ds(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function ys(t1, e1, r) {
            var n = e1[0], i = e1[1], a = e1[2], s = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = e1[9], f = e1[10], d = e1[11], y = e1[12], m = e1[13], g = e1[14], x = e1[15], v = r[0], b = r[1], w = r[2], _ = r[3];
            return t1[0] = v * n + b * o + w * h + _ * y, t1[1] = v * i + b * l + w * p + _ * m, t1[2] = v * a + b * u + w * f + _ * g, t1[3] = v * s + b * c + w * d + _ * x, t1[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t1[5] = v * i + b * l + w * p + _ * m, t1[6] = v * a + b * u + w * f + _ * g, t1[7] = v * s + b * c + w * d + _ * x, t1[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t1[9] = v * i + b * l + w * p + _ * m, t1[10] = v * a + b * u + w * f + _ * g, t1[11] = v * s + b * c + w * d + _ * x, t1[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t1[13] = v * i + b * l + w * p + _ * m, t1[14] = v * a + b * u + w * f + _ * g, t1[15] = v * s + b * c + w * d + _ * x, t1;
        }
        Math.hypot || (Math.hypot = function() {
            for(var t1 = 0, e1 = arguments.length; e1--;)t1 += arguments[e1] * arguments[e1];
            return Math.sqrt(t1);
        });
        var ms, gs = ys;
        function xs() {
            var t1 = new ps(3);
            return ps != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
        }
        function vs(t1, e1, r) {
            var n = new ps(3);
            return n[0] = t1, n[1] = e1, n[2] = r, n;
        }
        function bs(t1, e1, r) {
            var n = e1[0], i = e1[1], a = e1[2], s = e1[3];
            return t1[0] = r[0] * n + r[4] * i + r[8] * a + r[12] * s, t1[1] = r[1] * n + r[5] * i + r[9] * a + r[13] * s, t1[2] = r[2] * n + r[6] * i + r[10] * a + r[14] * s, t1[3] = r[3] * n + r[7] * i + r[11] * a + r[15] * s, t1;
        }
        function ws() {
            var t1 = new ps(4);
            return ps != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
        }
        function _s(t1, e1) {
            const r = bs([], [
                t1.x,
                t1.y,
                0,
                1
            ], e1);
            return new S(r[0] / r[3], r[1] / r[3]);
        }
        xs(), ms = new ps(4), ps != Float32Array && (ms[0] = 0, ms[1] = 0, ms[2] = 0, ms[3] = 0), xs(), vs(1, 0, 0), vs(0, 1, 0), ws(), ws(), fs(), function() {
            var t1;
            t1 = new ps(2), ps != Float32Array && (t1[0] = 0, t1[1] = 0);
        }();
        class As extends Ja {
        }
        Mn("HeatmapBucket", As, {
            omit: [
                "layers"
            ]
        });
        var ks = {
            paint: new fi({
                "heatmap-radius": new ui(nt.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new ui(nt.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new li(nt.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new pi(nt.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new li(nt.paint_heatmap["heatmap-opacity"])
            })
        };
        function Ss(t1, { width: e1, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e1 * r * n) throw new RangeError(`mismatched image size. expected: ${i.length} but got: ${e1 * r * n}`);
            } else i = new Uint8Array(e1 * r * n);
            return t1.width = e1, t1.height = r, t1.data = i, t1;
        }
        function Is(t1, { width: e1, height: r }, n) {
            if (e1 === t1.width && r === t1.height) return;
            const i = Ss({}, {
                width: e1,
                height: r
            }, n);
            Ms(t1, i, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, e1),
                height: Math.min(t1.height, r)
            }, n), t1.width = e1, t1.height = r, t1.data = i.data;
        }
        function Ms(t1, e1, r, n, i, a) {
            if (0 === i.width || 0 === i.height) return e1;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e1.width || i.height > e1.height || n.x > e1.width - i.width || n.y > e1.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const s = t1.data, o = e1.data;
            if (s === o) throw new Error("srcData equals dstData, so image is already copied");
            for(let l = 0; l < i.height; l++){
                const u = ((r.y + l) * t1.width + r.x) * a, c = ((n.y + l) * e1.width + n.x) * a;
                for(let t1 = 0; t1 < i.width * a; t1++)o[c + t1] = s[u + t1];
            }
            return e1;
        }
        class zs {
            constructor(t1, e1){
                Ss(this, t1, 1, e1);
            }
            resize(t1) {
                Is(this, t1, 1);
            }
            clone() {
                return new zs({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e1, r, n, i) {
                Ms(t1, e1, r, n, i, 1);
            }
        }
        class Bs {
            constructor(t1, e1){
                Ss(this, t1, 4, e1);
            }
            resize(t1) {
                Is(this, t1, 4);
            }
            replace(t1, e1) {
                e1 ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new Bs({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e1, r, n, i) {
                Ms(t1, e1, r, n, i, 4);
            }
        }
        function Cs(t1) {
            const e1 = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new Bs({
                width: r,
                height: n
            });
            if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
            const a = (r, n, a)=>{
                e1[t1.evaluationKey] = a;
                const s = t1.expression.evaluate(e1);
                i.data[r + n + 0] = Math.floor(255 * s.r / s.a), i.data[r + n + 1] = Math.floor(255 * s.g / s.a), i.data[r + n + 2] = Math.floor(255 * s.b / s.a), i.data[r + n + 3] = Math.floor(255 * s.a);
            };
            if (t1.clips) for(let e1 = 0, i = 0; e1 < n; ++e1, i += 4 * r)for(let n = 0, s = 0; n < r; n++, s += 4){
                const o = n / (r - 1), { start: l, end: u } = t1.clips[e1];
                a(i, s, l * (1 - o) + u * o);
            }
            else for(let t1 = 0, e1 = 0; t1 < r; t1++, e1 += 4)a(0, e1, t1 / (r - 1));
            return i;
        }
        Mn("AlphaImage", zs), Mn("RGBAImage", Bs);
        var Ps = {
            paint: new fi({
                "hillshade-illumination-direction": new li(nt.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new li(nt.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new li(nt.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new li(nt.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new li(nt.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new li(nt.paint_hillshade["hillshade-accent-color"])
            })
        };
        const Vs = vi([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: Es } = Vs;
        var Fs = {
            exports: {}
        };
        function Ts(t1, e1, r) {
            r = r || 2;
            var n, i, a, s, o, l, u, c = e1 && e1.length, h = c ? e1[0] * r : t1.length, p = Ls(t1, 0, h, r, !0), f = [];
            if (!p || p.next === p.prev) return f;
            if (c && (p = function(t1, e1, r, n) {
                var i, a, s, o = [];
                for(i = 0, a = e1.length; i < a; i++)(s = Ls(t1, e1[i] * n, i < a - 1 ? e1[i + 1] * n : t1.length, n, !1)) === s.next && (s.steiner = !0), o.push(Gs(s));
                for(o.sort(js), i = 0; i < o.length; i++)r = Ns(o[i], r);
                return r;
            }(t1, e1, p, r)), t1.length > 80 * r) {
                n = a = t1[0], i = s = t1[1];
                for(var d = r; d < h; d += r)(o = t1[d]) < n && (n = o), (l = t1[d + 1]) < i && (i = l), o > a && (a = o), l > s && (s = l);
                u = 0 !== (u = Math.max(a - n, s - i)) ? 32767 / u : 0;
            }
            return $s(p, f, r, n, i, u, 0), f;
        }
        function Ls(t1, e1, r, n, i) {
            var a, s;
            if (i === so(t1, e1, r, n) > 0) for(a = e1; a < r; a += n)s = no(a, t1[a], t1[a + 1], s);
            else for(a = r - n; a >= e1; a -= n)s = no(a, t1[a], t1[a + 1], s);
            return s && Hs(s, s.next) && (io(s), s = s.next), s;
        }
        function Ds(t1, e1) {
            if (!t1) return t1;
            e1 || (e1 = t1);
            var r, n = t1;
            do if (r = !1, n.steiner || !Hs(n, n.next) && 0 !== Ys(n.prev, n, n.next)) n = n.next;
            else {
                if (io(n), (n = e1 = n.prev) === n.next) break;
                r = !0;
            }
            while (r || n !== e1);
            return e1;
        }
        function $s(t1, e1, r, n, i, a, s) {
            if (t1) {
                !s && a && function(t1, e1, r, n) {
                    var i = t1;
                    do 0 === i.z && (i.z = Ks(i.x, i.y, e1, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                    while (i !== t1);
                    i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                        var e1, r, n, i, a, s, o, l, u = 1;
                        do {
                            for(r = t1, t1 = null, a = null, s = 0; r;){
                                for(s++, n = r, o = 0, e1 = 0; e1 < u && (o++, n = n.nextZ); e1++);
                                for(l = u; o > 0 || l > 0 && n;)0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), a ? a.nextZ = i : t1 = i, i.prevZ = a, a = i;
                                r = n;
                            }
                            a.nextZ = null, u *= 2;
                        }while (s > 1);
                    }(i);
                }(t1, n, i, a);
                for(var o, l, u = t1; t1.prev !== t1.next;)if (o = t1.prev, l = t1.next, a ? Os(t1, n, i, a) : Rs(t1)) e1.push(o.i / r | 0), e1.push(t1.i / r | 0), e1.push(l.i / r | 0), io(t1), t1 = l.next, u = l.next;
                else if ((t1 = l) === u) {
                    s ? 1 === s ? $s(t1 = Us(Ds(t1), e1, r), e1, r, n, i, a, 2) : 2 === s && qs(t1, e1, r, n, i, a) : $s(Ds(t1), e1, r, n, i, a, 1);
                    break;
                }
            }
        }
        function Rs(t1) {
            var e1 = t1.prev, r = t1, n = t1.next;
            if (Ys(e1, r, n) >= 0) return !1;
            for(var i = e1.x, a = r.x, s = n.x, o = e1.y, l = r.y, u = n.y, c = i < a ? i < s ? i : s : a < s ? a : s, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > a ? i > s ? i : s : a > s ? a : s, f = o > l ? o > u ? o : u : l > u ? l : u, d = n.next; d !== e1;){
                if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && Js(i, o, a, l, s, u, d.x, d.y) && Ys(d.prev, d, d.next) >= 0) return !1;
                d = d.next;
            }
            return !0;
        }
        function Os(t1, e1, r, n) {
            var i = t1.prev, a = t1, s = t1.next;
            if (Ys(i, a, s) >= 0) return !1;
            for(var o = i.x, l = a.x, u = s.x, c = i.y, h = a.y, p = s.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = Ks(f, d, e1, r, n), x = Ks(y, m, e1, r, n), v = t1.prevZ, b = t1.nextZ; v && v.z >= g && b && b.z <= x;){
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== s && Js(o, c, l, h, u, p, v.x, v.y) && Ys(v.prev, v, v.next) >= 0) return !1;
                if (v = v.prevZ, b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== s && Js(o, c, l, h, u, p, b.x, b.y) && Ys(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            for(; v && v.z >= g;){
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== s && Js(o, c, l, h, u, p, v.x, v.y) && Ys(v.prev, v, v.next) >= 0) return !1;
                v = v.prevZ;
            }
            for(; b && b.z <= x;){
                if (b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== s && Js(o, c, l, h, u, p, b.x, b.y) && Ys(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            return !0;
        }
        function Us(t1, e1, r) {
            var n = t1;
            do {
                var i = n.prev, a = n.next.next;
                !Hs(i, a) && Ws(i, n, n.next, a) && eo(i, a) && eo(a, i) && (e1.push(i.i / r | 0), e1.push(n.i / r | 0), e1.push(a.i / r | 0), io(n), io(n.next), n = t1 = a), n = n.next;
            }while (n !== t1);
            return Ds(n);
        }
        function qs(t1, e1, r, n, i, a) {
            var s = t1;
            do {
                for(var o = s.next.next; o !== s.prev;){
                    if (s.i !== o.i && Xs(s, o)) {
                        var l = ro(s, o);
                        return s = Ds(s, s.next), l = Ds(l, l.next), $s(s, e1, r, n, i, a, 0), void $s(l, e1, r, n, i, a, 0);
                    }
                    o = o.next;
                }
                s = s.next;
            }while (s !== t1);
        }
        function js(t1, e1) {
            return t1.x - e1.x;
        }
        function Ns(t1, e1) {
            var r = function(t1, e1) {
                var r, n = e1, i = t1.x, a = t1.y, s = -1 / 0;
                do {
                    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                        var o = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (o <= i && o > s && (s = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;
                    }
                    n = n.next;
                }while (n !== e1);
                if (!r) return null;
                var l, u = r, c = r.x, h = r.y, p = 1 / 0;
                n = r;
                do i >= n.x && n.x >= c && i !== n.x && Js(a < h ? i : s, a, c, h, a < h ? s : i, a, n.x, n.y) && (l = Math.abs(a - n.y) / (i - n.x), eo(n, t1) && (l < p || l === p && (n.x > r.x || n.x === r.x && Zs(r, n))) && (r = n, p = l)), n = n.next;
                while (n !== u);
                return r;
            }(t1, e1);
            if (!r) return e1;
            var n = ro(r, t1);
            return Ds(n, n.next), Ds(r, r.next);
        }
        function Zs(t1, e1) {
            return Ys(t1.prev, t1, e1.prev) < 0 && Ys(e1.next, t1, t1.next) < 0;
        }
        function Ks(t1, e1, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e1 = 1431655765 & ((e1 = 858993459 & ((e1 = 252645135 & ((e1 = 16711935 & ((e1 = (e1 - n) * i | 0) | e1 << 8)) | e1 << 4)) | e1 << 2)) | e1 << 1)) << 1;
        }
        function Gs(t1) {
            var e1 = t1, r = t1;
            do (e1.x < r.x || e1.x === r.x && e1.y < r.y) && (r = e1), e1 = e1.next;
            while (e1 !== t1);
            return r;
        }
        function Js(t1, e1, r, n, i, a, s, o) {
            return (i - s) * (e1 - o) >= (t1 - s) * (a - o) && (t1 - s) * (n - o) >= (r - s) * (e1 - o) && (r - s) * (a - o) >= (i - s) * (n - o);
        }
        function Xs(t1, e1) {
            return t1.next.i !== e1.i && t1.prev.i !== e1.i && !function(t1, e1) {
                var r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e1.i && r.next.i !== e1.i && Ws(r, r.next, t1, e1)) return !0;
                    r = r.next;
                }while (r !== t1);
                return !1;
            }(t1, e1) && (eo(t1, e1) && eo(e1, t1) && function(t1, e1) {
                var r = t1, n = !1, i = (t1.x + e1.x) / 2, a = (t1.y + e1.y) / 2;
                do r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                while (r !== t1);
                return n;
            }(t1, e1) && (Ys(t1.prev, t1, e1.prev) || Ys(t1, e1.prev, e1)) || Hs(t1, e1) && Ys(t1.prev, t1, t1.next) > 0 && Ys(e1.prev, e1, e1.next) > 0);
        }
        function Ys(t1, e1, r) {
            return (e1.y - t1.y) * (r.x - e1.x) - (e1.x - t1.x) * (r.y - e1.y);
        }
        function Hs(t1, e1) {
            return t1.x === e1.x && t1.y === e1.y;
        }
        function Ws(t1, e1, r, n) {
            var i = to(Ys(t1, e1, r)), a = to(Ys(t1, e1, n)), s = to(Ys(r, n, t1)), o = to(Ys(r, n, e1));
            return i !== a && s !== o || !(0 !== i || !Qs(t1, r, e1)) || !(0 !== a || !Qs(t1, n, e1)) || !(0 !== s || !Qs(r, t1, n)) || !(0 !== o || !Qs(r, e1, n));
        }
        function Qs(t1, e1, r) {
            return e1.x <= Math.max(t1.x, r.x) && e1.x >= Math.min(t1.x, r.x) && e1.y <= Math.max(t1.y, r.y) && e1.y >= Math.min(t1.y, r.y);
        }
        function to(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function eo(t1, e1) {
            return Ys(t1.prev, t1, t1.next) < 0 ? Ys(t1, e1, t1.next) >= 0 && Ys(t1, t1.prev, e1) >= 0 : Ys(t1, e1, t1.prev) < 0 || Ys(t1, t1.next, e1) < 0;
        }
        function ro(t1, e1) {
            var r = new ao(t1.i, t1.x, t1.y), n = new ao(e1.i, e1.x, e1.y), i = t1.next, a = e1.prev;
            return t1.next = e1, e1.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;
        }
        function no(t1, e1, r, n) {
            var i = new ao(t1, e1, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function io(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function ao(t1, e1, r) {
            this.i = t1, this.x = e1, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function so(t1, e1, r, n) {
            for(var i = 0, a = e1, s = r - n; a < r; a += n)i += (t1[s] - t1[a]) * (t1[a + 1] + t1[s + 1]), s = a;
            return i;
        }
        function oo(t1, e1, r, n, i) {
            lo(t1, e1, r || 0, n || t1.length - 1, i || co);
        }
        function lo(t1, e1, r, n, i) {
            for(; n > r;){
                if (n - r > 600) {
                    var a = n - r + 1, s = e1 - r + 1, o = Math.log(a), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (a - l) / a) * (s - a / 2 < 0 ? -1 : 1);
                    lo(t1, e1, Math.max(r, Math.floor(e1 - s * l / a + u)), Math.min(n, Math.floor(e1 + (a - s) * l / a + u)), i);
                }
                var c = t1[e1], h = r, p = n;
                for(uo(t1, r, e1), i(t1[n], c) > 0 && uo(t1, r, n); h < p;){
                    for(uo(t1, h, p), h++, p--; i(t1[h], c) < 0;)h++;
                    for(; i(t1[p], c) > 0;)p--;
                }
                0 === i(t1[r], c) ? uo(t1, r, p) : uo(t1, ++p, n), p <= e1 && (r = p + 1), e1 <= p && (n = p - 1);
            }
        }
        function uo(t1, e1, r) {
            var n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        function co(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function ho(t1, e1) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, a;
            for(let e1 = 0; e1 < r; e1++){
                const r = m(t1[e1]);
                0 !== r && (t1[e1].area = Math.abs(r), void 0 === a && (a = r < 0), a === r < 0 ? (i && n.push(i), i = [
                    t1[e1]
                ]) : i.push(t1[e1]));
            }
            if (i && n.push(i), e1 > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e1 || (oo(n[t1], e1, 1, n[t1].length - 1, po), n[t1] = n[t1].slice(0, e1));
            return n;
        }
        function po(t1, e1) {
            return e1.area - t1.area;
        }
        function fo(t1, e1, r) {
            const n = r.patternDependencies;
            let i = !1;
            for (const r of e1){
                const e1 = r.paint.get(`${t1}-pattern`);
                e1.isConstant() || (i = !0);
                const a = e1.constantOr(null);
                a && (i = !0, n[a.to] = !0, n[a.from] = !0);
            }
            return i;
        }
        function yo(t1, e1, r, n, i) {
            const a = i.patternDependencies;
            for (const s of e1){
                const e1 = s.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e1.kind) {
                    let t1 = e1.evaluate({
                        zoom: n - 1
                    }, r, {}, i.availableImages), o = e1.evaluate({
                        zoom: n
                    }, r, {}, i.availableImages), l = e1.evaluate({
                        zoom: n + 1
                    }, r, {}, i.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1, o = o && o.name ? o.name : o, l = l && l.name ? l.name : l, a[t1] = !0, a[o] = !0, a[l] = !0, r.patterns[s.id] = {
                        min: t1,
                        mid: o,
                        max: l
                    };
                }
            }
            return r;
        }
        Fs.exports = Ts, Fs.exports.default = Ts, Ts.deviation = function(t1, e1, r, n) {
            var i = e1 && e1.length, a = Math.abs(so(t1, 0, i ? e1[0] * r : t1.length, r));
            if (i) for(var s = 0, o = e1.length; s < o; s++)a -= Math.abs(so(t1, e1[s] * r, s < o - 1 ? e1[s + 1] * r : t1.length, r));
            var l = 0;
            for(s = 0; s < n.length; s += 3){
                var u = n[s] * r, c = n[s + 1] * r, h = n[s + 2] * r;
                l += Math.abs((t1[u] - t1[h]) * (t1[c + 1] - t1[u + 1]) - (t1[u] - t1[c]) * (t1[h + 1] - t1[u + 1]));
            }
            return 0 === a && 0 === l ? 0 : Math.abs((l - a) / a);
        }, Ts.flatten = function(t1) {
            for(var e1 = t1[0][0].length, r = {
                vertices: [],
                holes: [],
                dimensions: e1
            }, n = 0, i = 0; i < t1.length; i++){
                for(var a = 0; a < t1[i].length; a++)for(var s = 0; s < e1; s++)r.vertices.push(t1[i][a][s]);
                i > 0 && r.holes.push(n += t1[i - 1].length);
            }
            return r;
        };
        class mo {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new ea, this.indexArray = new ha, this.indexArray2 = new pa, this.programConfigurations = new Ra(t1.layers, t1.zoom), this.segments = new ya, this.segments2 = new ya, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r) {
                this.hasPattern = fo("fill", this.layers, e1);
                const n = this.layers[0].layout.get("fill-sort-key"), i = !n.isConstant(), a = [];
                for (const { feature: s, id: o, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = Ka(s, t1);
                    if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), c, r)) continue;
                    const h = i ? n.evaluate(c, {}, r, e1.availableImages) : void 0, p = {
                        id: o,
                        properties: s.properties,
                        type: s.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : Za(s),
                        patterns: {},
                        sortKey: h
                    };
                    a.push(p);
                }
                i && a.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                for (const n of a){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n;
                    if (this.hasPattern) {
                        const t1 = yo("fill", this.layers, n, this.zoom, e1);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, a, r, {});
                    e1.featureIndex.insert(t1[a].feature, i, a, s, this.index);
                }
            }
            update(t1, e1, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r);
            }
            addFeatures(t1, e1, r) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e1, r);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Es), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t1, e1, r, n, i) {
                for (const t1 of ho(e1, 500)){
                    let e1 = 0;
                    for (const r of t1)e1 += r.length;
                    const r = this.segments.prepareSegment(e1, this.layoutVertexArray, this.indexArray), n = r.vertexLength, i = [], a = [];
                    for (const e1 of t1){
                        if (0 === e1.length) continue;
                        e1 !== t1[0] && a.push(i.length / 2);
                        const r = this.segments2.prepareSegment(e1.length, this.layoutVertexArray, this.indexArray2), n = r.vertexLength;
                        this.layoutVertexArray.emplaceBack(e1[0].x, e1[0].y), this.indexArray2.emplaceBack(n + e1.length - 1, n), i.push(e1[0].x), i.push(e1[0].y);
                        for(let t1 = 1; t1 < e1.length; t1++)this.layoutVertexArray.emplaceBack(e1[t1].x, e1[t1].y), this.indexArray2.emplaceBack(n + t1 - 1, n + t1), i.push(e1[t1].x), i.push(e1[t1].y);
                        r.vertexLength += e1.length, r.primitiveLength += e1.length;
                    }
                    const s = Fs.exports(i, a);
                    for(let t1 = 0; t1 < s.length; t1 += 3)this.indexArray.emplaceBack(n + s[t1], n + s[t1 + 1], n + s[t1 + 2]);
                    r.vertexLength += e1, r.primitiveLength += s.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, n);
            }
        }
        Mn("FillBucket", mo, {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const go = new fi({
            "fill-sort-key": new ui(nt.layout_fill["fill-sort-key"])
        });
        var xo = {
            paint: new fi({
                "fill-antialias": new li(nt.paint_fill["fill-antialias"]),
                "fill-opacity": new ui(nt.paint_fill["fill-opacity"]),
                "fill-color": new ui(nt.paint_fill["fill-color"]),
                "fill-outline-color": new ui(nt.paint_fill["fill-outline-color"]),
                "fill-translate": new li(nt.paint_fill["fill-translate"]),
                "fill-translate-anchor": new li(nt.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new ci(nt.paint_fill["fill-pattern"])
            }),
            layout: go
        };
        const vo = vi([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_normal_ed",
                components: 4,
                type: "Int16"
            }
        ], 4), bo = vi([
            {
                name: "a_centroid",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: wo } = vo;
        var _o = {}, Ao = S, ko = So;
        function So(t1, e1, r, n, i) {
            this.properties = {}, this.extent = r, this.type = 0, this._pbf = t1, this._geometry = -1, this._keys = n, this._values = i, t1.readFields(Io, this, e1);
        }
        function Io(t1, e1, r) {
            1 == t1 ? e1.id = r.readVarint() : 2 == t1 ? function(t1, e1) {
                for(var r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = e1._keys[t1.readVarint()], i = e1._values[t1.readVarint()];
                    e1.properties[n] = i;
                }
            }(r, e1) : 3 == t1 ? e1.type = r.readVarint() : 4 == t1 && (e1._geometry = r.pos);
        }
        function Mo(t1) {
            for(var e1, r, n = 0, i = 0, a = t1.length, s = a - 1; i < a; s = i++)n += ((r = t1[s]).x - (e1 = t1[i]).x) * (e1.y + r.y);
            return n;
        }
        So.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ], So.prototype.loadGeometry = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e1, r = t1.readVarint() + t1.pos, n = 1, i = 0, a = 0, s = 0, o = []; t1.pos < r;){
                if (i <= 0) {
                    var l = t1.readVarint();
                    n = 7 & l, i = l >> 3;
                }
                if (i--, 1 === n || 2 === n) a += t1.readSVarint(), s += t1.readSVarint(), 1 === n && (e1 && o.push(e1), e1 = []), e1.push(new Ao(a, s));
                else {
                    if (7 !== n) throw new Error("unknown command " + n);
                    e1 && e1.push(e1[0].clone());
                }
            }
            return e1 && o.push(e1), o;
        }, So.prototype.bbox = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e1 = t1.readVarint() + t1.pos, r = 1, n = 0, i = 0, a = 0, s = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t1.pos < e1;){
                if (n <= 0) {
                    var c = t1.readVarint();
                    r = 7 & c, n = c >> 3;
                }
                if (n--, 1 === r || 2 === r) (i += t1.readSVarint()) < s && (s = i), i > o && (o = i), (a += t1.readSVarint()) < l && (l = a), a > u && (u = a);
                else if (7 !== r) throw new Error("unknown command " + r);
            }
            return [
                s,
                l,
                o,
                u
            ];
        }, So.prototype.toGeoJSON = function(t1, e1, r) {
            var n, i, a = this.extent * Math.pow(2, r), s = this.extent * t1, o = this.extent * e1, l = this.loadGeometry(), u = So.types[this.type];
            function c(t1) {
                for(var e1 = 0; e1 < t1.length; e1++){
                    var r = t1[e1];
                    t1[e1] = [
                        360 * (r.x + s) / a - 180,
                        360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / a) * Math.PI / 180)) - 90
                    ];
                }
            }
            switch(this.type){
                case 1:
                    var h = [];
                    for(n = 0; n < l.length; n++)h[n] = l[n][0];
                    c(l = h);
                    break;
                case 2:
                    for(n = 0; n < l.length; n++)c(l[n]);
                    break;
                case 3:
                    for(l = function(t1) {
                        var e1 = t1.length;
                        if (e1 <= 1) return [
                            t1
                        ];
                        for(var r, n, i = [], a = 0; a < e1; a++){
                            var s = Mo(t1[a]);
                            0 !== s && (void 0 === n && (n = s < 0), n === s < 0 ? (r && i.push(r), r = [
                                t1[a]
                            ]) : r.push(t1[a]));
                        }
                        return r && i.push(r), i;
                    }(l), n = 0; n < l.length; n++)for(i = 0; i < l[n].length; i++)c(l[n][i]);
            }
            1 === l.length ? l = l[0] : u = "Multi" + u;
            var p = {
                type: "Feature",
                geometry: {
                    type: u,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id" in this && (p.id = this.id), p;
        };
        var zo = ko, Bo = Co;
        function Co(t1, e1) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(Po, this, e1), this.length = this._features.length;
        }
        function Po(t1, e1, r) {
            15 === t1 ? e1.version = r.readVarint() : 1 === t1 ? e1.name = r.readString() : 5 === t1 ? e1.extent = r.readVarint() : 2 === t1 ? e1._features.push(r.pos) : 3 === t1 ? e1._keys.push(r.readString()) : 4 === t1 && e1._values.push(function(t1) {
                for(var e1 = null, r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = t1.readVarint() >> 3;
                    e1 = 1 === n ? t1.readString() : 2 === n ? t1.readFloat() : 3 === n ? t1.readDouble() : 4 === n ? t1.readVarint64() : 5 === n ? t1.readVarint() : 6 === n ? t1.readSVarint() : 7 === n ? t1.readBoolean() : null;
                }
                return e1;
            }(r));
        }
        Co.prototype.feature = function(t1) {
            if (t1 < 0 || t1 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t1];
            var e1 = this._pbf.readVarint() + this._pbf.pos;
            return new zo(this._pbf, e1, this.extent, this._keys, this._values);
        };
        var Vo = Bo;
        function Eo(t1, e1, r) {
            if (3 === t1) {
                var n = new Vo(r, r.readVarint() + r.pos);
                n.length && (e1[n.name] = n);
            }
        }
        _o.VectorTile = function(t1, e1) {
            this.layers = t1.readFields(Eo, {}, e1);
        }, _o.VectorTileFeature = ko, _o.VectorTileLayer = Bo;
        const Fo = _o.VectorTileFeature.types, To = Math.pow(2, 13);
        function Lo(t1, e1, r, n, i, a, s, o) {
            t1.emplaceBack(e1, r, 2 * Math.floor(n * To) + s, i * To * 2, a * To * 2, Math.round(o));
        }
        class Do {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.layoutVertexArray = new ra, this.centroidVertexArray = new Qi, this.indexArray = new ha, this.programConfigurations = new Ra(t1.layers, t1.zoom), this.segments = new ya, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r) {
                this.features = [], this.hasPattern = fo("fill-extrusion", this.layers, e1);
                for (const { feature: n, id: i, index: a, sourceLayerIndex: s } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, o = Ka(n, t1);
                    if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), o, r)) continue;
                    const l = {
                        id: i,
                        sourceLayerIndex: s,
                        index: a,
                        geometry: t1 ? o.geometry : Za(n),
                        properties: n.properties,
                        type: n.type,
                        patterns: {}
                    };
                    this.hasPattern ? this.features.push(yo("fill-extrusion", this.layers, l, this.zoom, e1)) : this.addFeature(l, l.geometry, a, r, {}), e1.featureIndex.insert(n, l.geometry, a, s, this.index, !0);
                }
            }
            addFeatures(t1, e1, r) {
                for (const t1 of this.features){
                    const { geometry: n } = t1;
                    this.addFeature(t1, n, t1.index, e1, r);
                }
            }
            update(t1, e1, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, wo), this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, bo.members, !0), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t1, e1, r, n, i) {
                const a = {
                    x: 0,
                    y: 0,
                    vertexCount: 0
                };
                for (const r of ho(e1, 500)){
                    let e1 = 0;
                    for (const t1 of r)e1 += t1.length;
                    let n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                    for (const t1 of r){
                        if (0 === t1.length) continue;
                        if (Ro(t1)) continue;
                        let e1 = 0;
                        for(let r = 0; r < t1.length; r++){
                            const i = t1[r];
                            if (r >= 1) {
                                const s = t1[r - 1];
                                if (!$o(i, s)) {
                                    n.vertexLength + 4 > ya.MAX_VERTEX_ARRAY_LENGTH && (n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                                    const t1 = i.sub(s)._perp()._unit(), r = s.dist(i);
                                    e1 + r > 32768 && (e1 = 0), Lo(this.layoutVertexArray, i.x, i.y, t1.x, t1.y, 0, 0, e1), Lo(this.layoutVertexArray, i.x, i.y, t1.x, t1.y, 0, 1, e1), a.x += 2 * i.x, a.y += 2 * i.y, a.vertexCount += 2, e1 += r, Lo(this.layoutVertexArray, s.x, s.y, t1.x, t1.y, 0, 0, e1), Lo(this.layoutVertexArray, s.x, s.y, t1.x, t1.y, 0, 1, e1), a.x += 2 * s.x, a.y += 2 * s.y, a.vertexCount += 2;
                                    const o = n.vertexLength;
                                    this.indexArray.emplaceBack(o, o + 2, o + 1), this.indexArray.emplaceBack(o + 1, o + 2, o + 3), n.vertexLength += 4, n.primitiveLength += 2;
                                }
                            }
                        }
                    }
                    if (n.vertexLength + e1 > ya.MAX_VERTEX_ARRAY_LENGTH && (n = this.segments.prepareSegment(e1, this.layoutVertexArray, this.indexArray)), "Polygon" !== Fo[t1.type]) continue;
                    const i = [], s = [], o = n.vertexLength;
                    for (const t1 of r)if (0 !== t1.length) {
                        t1 !== r[0] && s.push(i.length / 2);
                        for(let e1 = 0; e1 < t1.length; e1++){
                            const r = t1[e1];
                            Lo(this.layoutVertexArray, r.x, r.y, 0, 0, 1, 1, 0), a.x += r.x, a.y += r.y, a.vertexCount += 1, i.push(r.x), i.push(r.y);
                        }
                    }
                    const l = Fs.exports(i, s);
                    for(let t1 = 0; t1 < l.length; t1 += 3)this.indexArray.emplaceBack(o + l[t1], o + l[t1 + 2], o + l[t1 + 1]);
                    n.primitiveLength += l.length / 3, n.vertexLength += e1;
                }
                for(let t1 = 0; t1 < a.vertexCount; t1++)this.centroidVertexArray.emplaceBack(Math.floor(a.x / a.vertexCount), Math.floor(a.y / a.vertexCount));
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, n);
            }
        }
        function $o(t1, e1) {
            return t1.x === e1.x && (t1.x < 0 || t1.x > qa) || t1.y === e1.y && (t1.y < 0 || t1.y > qa);
        }
        function Ro(t1) {
            return t1.every((t1)=>t1.x < 0) || t1.every((t1)=>t1.x > qa) || t1.every((t1)=>t1.y < 0) || t1.every((t1)=>t1.y > qa);
        }
        Mn("FillExtrusionBucket", Do, {
            omit: [
                "layers",
                "features"
            ]
        });
        var Oo = {
            paint: new fi({
                "fill-extrusion-opacity": new li(nt["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new ui(nt["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new li(nt["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new li(nt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new ci(nt["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new ui(nt["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new ui(nt["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new li(nt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
        };
        function Uo(t1, e1) {
            return t1.x * e1.x + t1.y * e1.y;
        }
        function qo(t1, e1) {
            if (1 === t1.length) {
                let r = 0;
                const n = e1[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e1[r++], !i) return 1 / 0;
                for(; r < e1.length; r++){
                    const a = e1[r], s = t1[0], o = i.sub(n), l = a.sub(n), u = s.sub(n), c = Uo(o, o), h = Uo(o, l), p = Uo(l, l), f = Uo(u, o), d = Uo(u, l), y = c * p - h * h, m = (p * f - h * d) / y, g = (c * d - h * f) / y, x = n.z * (1 - m - g) + i.z * m + a.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e1)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        const jo = vi([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            }
        ], 4), { members: No } = jo, Zo = vi([
            {
                name: "a_uv_x",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_split_index",
                components: 1,
                type: "Float32"
            }
        ]), { members: Ko } = Zo, Go = _o.VectorTileFeature.types, Jo = Math.cos(Math.PI / 180 * 37.5), Xo = Math.pow(2, 14) / .5;
        class Yo {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new na, this.layoutVertexArray2 = new ia, this.indexArray = new ha, this.programConfigurations = new Ra(t1.layers, t1.zoom), this.segments = new ya, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r) {
                this.hasPattern = fo("line", this.layers, e1);
                const n = this.layers[0].layout.get("line-sort-key"), i = !n.isConstant(), a = [];
                for (const { feature: e1, id: s, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = Ka(e1, t1);
                    if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), u, r)) continue;
                    const c = i ? n.evaluate(u, {}, r) : void 0, h = {
                        id: s,
                        properties: e1.properties,
                        type: e1.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : Za(e1),
                        patterns: {},
                        sortKey: c
                    };
                    a.push(h);
                }
                i && a.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                for (const n of a){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n;
                    if (this.hasPattern) {
                        const t1 = yo("line", this.layers, n, this.zoom, e1);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, a, r, {});
                    e1.featureIndex.insert(t1[a].feature, i, a, s, this.index);
                }
            }
            update(t1, e1, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r);
            }
            addFeatures(t1, e1, r) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e1, r);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, Ko)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, No), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1) {
                if (t1.properties && Object.prototype.hasOwnProperty.call(t1.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t1.properties, "mapbox_clip_end")) return {
                    start: +t1.properties.mapbox_clip_start,
                    end: +t1.properties.mapbox_clip_end
                };
            }
            addFeature(t1, e1, r, n, i) {
                const a = this.layers[0].layout, s = a.get("line-join").evaluate(t1, {}), o = a.get("line-cap"), l = a.get("line-miter-limit"), u = a.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1);
                for (const r of e1)this.addLine(r, t1, s, o, l, u);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, n);
            }
            addLine(t1, e1, r, n, i, a) {
                if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for(let e1 = 0; e1 < t1.length - 1; e1++)this.totalDistance += t1[e1].dist(t1[e1 + 1]);
                    this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const s = "Polygon" === Go[e1.type];
                let o = t1.length;
                for(; o >= 2 && t1[o - 1].equals(t1[o - 2]);)o--;
                let l = 0;
                for(; l < o - 1 && t1[l].equals(t1[l + 1]);)l++;
                if (o < (s ? 3 : 2)) return;
                "bevel" === r && (i = 1.05);
                const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);
                let h, p, f, d, y;
                this.e1 = this.e2 = -1, s && (h = t1[o - 2], y = t1[l].sub(h)._unit()._perp());
                for(let e1 = l; e1 < o; e1++){
                    if (f = e1 === o - 1 ? s ? t1[l + 1] : void 0 : t1[e1 + 1], f && t1[e1].equals(f)) continue;
                    y && (d = y), h && (p = h), h = t1[e1], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;
                    let m = d.add(y);
                    0 === m.x && 0 === m.y || m._unit();
                    const g = d.x * y.x + d.y * y.y, x = m.x * y.x + m.y * y.y, v = 0 !== x ? 1 / x : 1 / 0, b = 2 * Math.sqrt(2 - 2 * x), w = x < Jo && p && f, _ = d.x * y.y - d.y * y.x > 0;
                    if (w && e1 > l) {
                        const t1 = h.dist(p);
                        if (t1 > 2 * u) {
                            const e1 = h.sub(h.sub(p)._mult(u / t1)._round());
                            this.updateDistance(p, e1), this.addCurrentVertex(e1, d, 0, 0, c), p = e1;
                        }
                    }
                    const A = p && f;
                    let k = A ? r : s ? "butt" : n;
                    if (A && "round" === k && (v < a ? k = "miter" : v <= 2 && (k = "fakeround")), "miter" === k && v > i && (k = "bevel"), "bevel" === k && (v > 2 && (k = "flipbevel"), v < i && (k = "miter")), p && this.updateDistance(p, h), "miter" === k) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);
                    else if ("flipbevel" === k) {
                        if (v > 100) m = y.mult(-1);
                        else {
                            const t1 = v * d.add(y).mag() / d.sub(y).mag();
                            m._perp()._mult(t1 * (_ ? -1 : 1));
                        }
                        this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);
                    } else if ("bevel" === k || "fakeround" === k) {
                        const t1 = -Math.sqrt(v * v - 1), e1 = _ ? t1 : 0, r = _ ? 0 : t1;
                        if (p && this.addCurrentVertex(h, d, e1, r, c), "fakeround" === k) {
                            const t1 = Math.round(180 * b / Math.PI / 20);
                            for(let e1 = 1; e1 < t1; e1++){
                                let r = e1 / t1;
                                if (.5 !== r) {
                                    const t1 = r - .5;
                                    r += r * t1 * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t1 * t1 + (.848013 + g * (.215638 * g - 1.06021)));
                                }
                                const n = y.sub(d)._mult(r)._add(d)._unit()._mult(_ ? -1 : 1);
                                this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);
                            }
                        }
                        f && this.addCurrentVertex(h, y, -e1, -r, c);
                    } else if ("butt" === k) this.addCurrentVertex(h, m, 0, 0, c);
                    else if ("square" === k) {
                        const t1 = p ? 1 : -1;
                        this.addCurrentVertex(h, m, t1, t1, c);
                    } else "round" === k && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));
                    if (w && e1 < o - 1) {
                        const t1 = h.dist(f);
                        if (t1 > 2 * u) {
                            const e1 = h.add(f.sub(h)._mult(u / t1)._round());
                            this.updateDistance(h, e1), this.addCurrentVertex(e1, y, 0, 0, c), h = e1;
                        }
                    }
                }
            }
            addCurrentVertex(t1, e1, r, n, i, a = !1) {
                const s = e1.y * n - e1.x, o = -e1.y - e1.x * n;
                this.addHalfVertex(t1, e1.x + e1.y * r, e1.y - e1.x * r, a, !1, r, i), this.addHalfVertex(t1, s, o, a, !0, -n, i), this.distance > Xo / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t1, e1, r, n, i, a));
            }
            addHalfVertex({ x: t1, y: e1 }, r, n, i, a, s, o) {
                const l = .5 * (this.lineClips ? this.scaledDistance * (Xo - 1) : this.scaledDistance);
                this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e1 << 1) + (a ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === s ? 0 : s < 0 ? -1 : 1) | (63 & l) << 2, l >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                const u = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), a ? this.e2 = u : this.e1 = u;
            }
            updateScaledDistance() {
                this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t1, e1) {
                this.distance += t1.dist(e1), this.updateScaledDistance();
            }
        }
        Mn("LineBucket", Yo, {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const Ho = new fi({
            "line-cap": new li(nt.layout_line["line-cap"]),
            "line-join": new ui(nt.layout_line["line-join"]),
            "line-miter-limit": new li(nt.layout_line["line-miter-limit"]),
            "line-round-limit": new li(nt.layout_line["line-round-limit"]),
            "line-sort-key": new ui(nt.layout_line["line-sort-key"])
        });
        var Wo = {
            paint: new fi({
                "line-opacity": new ui(nt.paint_line["line-opacity"]),
                "line-color": new ui(nt.paint_line["line-color"]),
                "line-translate": new li(nt.paint_line["line-translate"]),
                "line-translate-anchor": new li(nt.paint_line["line-translate-anchor"]),
                "line-width": new ui(nt.paint_line["line-width"]),
                "line-gap-width": new ui(nt.paint_line["line-gap-width"]),
                "line-offset": new ui(nt.paint_line["line-offset"]),
                "line-blur": new ui(nt.paint_line["line-blur"]),
                "line-dasharray": new hi(nt.paint_line["line-dasharray"]),
                "line-pattern": new ci(nt.paint_line["line-pattern"]),
                "line-gradient": new pi(nt.paint_line["line-gradient"])
            }),
            layout: Ho
        };
        const Qo = new class extends ui {
            possiblyEvaluate(t1, e1) {
                return e1 = new Qn(Math.floor(e1.zoom), {
                    now: e1.now,
                    fadeDuration: e1.fadeDuration,
                    zoomHistory: e1.zoomHistory,
                    transition: e1.transition
                }), super.possiblyEvaluate(t1, e1);
            }
            evaluate(t1, e1, r, n) {
                return e1 = o({}, e1, {
                    zoom: Math.floor(e1.zoom)
                }), super.evaluate(t1, e1, r, n);
            }
        }(Wo.paint.properties["line-width"].specification);
        function tl(t1, e1) {
            return e1 > 0 ? e1 + 2 * t1 : t1;
        }
        Qo.useIntegerZoom = !0;
        const el = vi([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), rl = vi([
            {
                name: "a_projected_pos",
                components: 3,
                type: "Float32"
            }
        ], 4);
        vi([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const nl = vi([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }
        ]);
        vi([
            {
                type: "Int16",
                name: "anchorPointX"
            },
            {
                type: "Int16",
                name: "anchorPointY"
            },
            {
                type: "Int16",
                name: "x1"
            },
            {
                type: "Int16",
                name: "y1"
            },
            {
                type: "Int16",
                name: "x2"
            },
            {
                type: "Int16",
                name: "y2"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const il = vi([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), al = vi([
            {
                name: "a_pos",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        function sl(t1, e1, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e1, r) {
                    const n = e1.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), Wn.applyArabicShaping && (t1 = Wn.applyArabicShaping(t1)), t1;
                }(t1.text, e1, r);
            }), t1;
        }
        vi([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), vi([
            {
                type: "Int16",
                name: "anchorX"
            },
            {
                type: "Int16",
                name: "anchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            }
        ]), vi([
            {
                type: "Int16",
                name: "anchorX"
            },
            {
                type: "Int16",
                name: "anchorY"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                name: "textBoxScale"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            }
        ]), vi([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), vi([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            },
            {
                type: "Int16",
                name: "tileUnitDistanceFromAnchor"
            }
        ]);
        const ol = {
            "!": "\uFE15",
            "#": "\uFF03",
            $: "\uFF04",
            "%": "\uFF05",
            "&": "\uFF06",
            "(": "\uFE35",
            ")": "\uFE36",
            "*": "\uFF0A",
            "+": "\uFF0B",
            ",": "\uFE10",
            "-": "\uFE32",
            ".": "\u30FB",
            "/": "\uFF0F",
            ":": "\uFE13",
            ";": "\uFE14",
            "<": "\uFE3F",
            "=": "\uFF1D",
            ">": "\uFE40",
            "?": "\uFE16",
            "@": "\uFF20",
            "[": "\uFE47",
            "\\": "\uFF3C",
            "]": "\uFE48",
            "^": "\uFF3E",
            _: "\uFE33",
            "`": "\uFF40",
            "{": "\uFE37",
            "|": "\u2015",
            "}": "\uFE38",
            "~": "\uFF5E",
            "\xa2": "\uFFE0",
            "\xa3": "\uFFE1",
            "\xa5": "\uFFE5",
            "\xa6": "\uFFE4",
            "\xac": "\uFFE2",
            "\xaf": "\uFFE3",
            "\u2013": "\uFE32",
            "\u2014": "\uFE31",
            "\u2018": "\uFE43",
            "\u2019": "\uFE44",
            "\u201C": "\uFE41",
            "\u201D": "\uFE42",
            "\u2026": "\uFE19",
            "\u2027": "\u30FB",
            "\u20A9": "\uFFE6",
            "\u3001": "\uFE11",
            "\u3002": "\uFE12",
            "\u3008": "\uFE3F",
            "\u3009": "\uFE40",
            "\u300A": "\uFE3D",
            "\u300B": "\uFE3E",
            "\u300C": "\uFE41",
            "\u300D": "\uFE42",
            "\u300E": "\uFE43",
            "\u300F": "\uFE44",
            "\u3010": "\uFE3B",
            "\u3011": "\uFE3C",
            "\u3014": "\uFE39",
            "\u3015": "\uFE3A",
            "\u3016": "\uFE17",
            "\u3017": "\uFE18",
            "\uFF01": "\uFE15",
            "\uFF08": "\uFE35",
            "\uFF09": "\uFE36",
            "\uFF0C": "\uFE10",
            "\uFF0D": "\uFE32",
            "\uFF0E": "\u30FB",
            "\uFF1A": "\uFE13",
            "\uFF1B": "\uFE14",
            "\uFF1C": "\uFE3F",
            "\uFF1E": "\uFE40",
            "\uFF1F": "\uFE16",
            "\uFF3B": "\uFE47",
            "\uFF3D": "\uFE48",
            "\uFF3F": "\uFE33",
            "\uFF5B": "\uFE37",
            "\uFF5C": "\u2015",
            "\uFF5D": "\uFE38",
            "\uFF5F": "\uFE35",
            "\uFF60": "\uFE36",
            "\uFF61": "\uFE12",
            "\uFF62": "\uFE41",
            "\uFF63": "\uFE42"
        };
        var ll = 24, ul = pl, cl = function(t1, e1, r, n, i) {
            var a, s, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = t1[e1 + h];
            for(h += p, a = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; a = 256 * a + t1[e1 + h], h += p, c -= 8);
            for(s = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; s = 256 * s + t1[e1 + h], h += p, c -= 8);
            if (0 === a) a = 1 - u;
            else {
                if (a === l) return s ? NaN : 1 / 0 * (f ? -1 : 1);
                s += Math.pow(2, n), a -= u;
            }
            return (f ? -1 : 1) * s * Math.pow(2, a - n);
        }, hl = function(t1, e1, r, n, i, a) {
            var s, o, l, u = 8 * a - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : a - 1, d = n ? 1 : -1, y = e1 < 0 || 0 === e1 && 1 / e1 < 0 ? 1 : 0;
            for(e1 = Math.abs(e1), isNaN(e1) || e1 === 1 / 0 ? (o = isNaN(e1) ? 1 : 0, s = c) : (s = Math.floor(Math.log(e1) / Math.LN2), e1 * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (e1 += s + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (s++, l /= 2), s + h >= c ? (o = 0, s = c) : s + h >= 1 ? (o = (e1 * l - 1) * Math.pow(2, i), s += h) : (o = e1 * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; t1[r + f] = 255 & o, f += d, o /= 256, i -= 8);
            for(s = s << i | o, u += i; u > 0; t1[r + f] = 255 & s, f += d, s /= 256, u -= 8);
            t1[r + f - d] |= 128 * y;
        };
        function pl(t1) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        pl.Varint = 0, pl.Fixed64 = 1, pl.Bytes = 2, pl.Fixed32 = 5;
        var fl, dl = 4294967296, yl = 1 / dl, ml = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function gl(t1) {
            return t1.type === pl.Bytes ? t1.readVarint() + t1.pos : t1.pos + 1;
        }
        function xl(t1, e1, r) {
            return r ? 4294967296 * e1 + (t1 >>> 0) : 4294967296 * (e1 >>> 0) + (t1 >>> 0);
        }
        function vl(t1, e1, r) {
            var n = e1 <= 16383 ? 1 : e1 <= 2097151 ? 2 : e1 <= 268435455 ? 3 : Math.floor(Math.log(e1) / (7 * Math.LN2));
            r.realloc(n);
            for(var i = r.pos - 1; i >= t1; i--)r.buf[i + n] = r.buf[i];
        }
        function bl(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeVarint(t1[r]);
        }
        function wl(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSVarint(t1[r]);
        }
        function _l(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFloat(t1[r]);
        }
        function Al(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeDouble(t1[r]);
        }
        function kl(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeBoolean(t1[r]);
        }
        function Sl(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFixed32(t1[r]);
        }
        function Il(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSFixed32(t1[r]);
        }
        function Ml(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFixed64(t1[r]);
        }
        function zl(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSFixed64(t1[r]);
        }
        function Bl(t1, e1) {
            return (t1[e1] | t1[e1 + 1] << 8 | t1[e1 + 2] << 16) + 16777216 * t1[e1 + 3];
        }
        function Cl(t1, e1, r) {
            t1[r] = e1, t1[r + 1] = e1 >>> 8, t1[r + 2] = e1 >>> 16, t1[r + 3] = e1 >>> 24;
        }
        function Pl(t1, e1) {
            return (t1[e1] | t1[e1 + 1] << 8 | t1[e1 + 2] << 16) + (t1[e1 + 3] << 24);
        }
        function Vl(t1, e1, r) {
            1 === t1 && r.readMessage(El, e1);
        }
        function El(t1, e1, r) {
            if (3 === t1) {
                const { id: t1, bitmap: n, width: i, height: a, left: s, top: o, advance: l } = r.readMessage(Fl, {});
                e1.push({
                    id: t1,
                    bitmap: new zs({
                        width: i + 6,
                        height: a + 6
                    }, n),
                    metrics: {
                        width: i,
                        height: a,
                        left: s,
                        top: o,
                        advance: l
                    }
                });
            }
        }
        function Fl(t1, e1, r) {
            1 === t1 ? e1.id = r.readVarint() : 2 === t1 ? e1.bitmap = r.readBytes() : 3 === t1 ? e1.width = r.readVarint() : 4 === t1 ? e1.height = r.readVarint() : 5 === t1 ? e1.left = r.readSVarint() : 6 === t1 ? e1.top = r.readSVarint() : 7 === t1 && (e1.advance = r.readVarint());
        }
        function Tl(t1) {
            let e1 = 0, r = 0;
            for (const n of t1)e1 += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e1)=>e1.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e1 / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, a = 0;
            for (const e1 of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e1.w > r.w || e1.h > r.h)) {
                    if (e1.x = r.x, e1.y = r.y, a = Math.max(a, e1.y + e1.h), i = Math.max(i, e1.x + e1.w), e1.w === r.w && e1.h === r.h) {
                        const e1 = n.pop();
                        t1 < n.length && (n[t1] = e1);
                    } else e1.h === r.h ? (r.x += e1.w, r.w -= e1.w) : e1.w === r.w ? (r.y += e1.h, r.h -= e1.h) : (n.push({
                        x: r.x + e1.w,
                        y: r.y,
                        w: r.w - e1.w,
                        h: e1.h
                    }), r.y += e1.h, r.h -= e1.h);
                    break;
                }
            }
            return {
                w: i,
                h: a,
                fill: e1 / (i * a) || 0
            };
        }
        pl.prototype = {
            destroy: function() {
                this.buf = null;
            },
            readFields: function(t1, e1, r) {
                for(r = r || this.length; this.pos < r;){
                    var n = this.readVarint(), i = n >> 3, a = this.pos;
                    this.type = 7 & n, t1(i, e1, this), this.pos === a && this.skip(n);
                }
                return e1;
            },
            readMessage: function(t1, e1) {
                return this.readFields(t1, e1, this.readVarint() + this.pos);
            },
            readFixed32: function() {
                var t1 = Bl(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readSFixed32: function() {
                var t1 = Pl(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readFixed64: function() {
                var t1 = Bl(this.buf, this.pos) + Bl(this.buf, this.pos + 4) * dl;
                return this.pos += 8, t1;
            },
            readSFixed64: function() {
                var t1 = Bl(this.buf, this.pos) + Pl(this.buf, this.pos + 4) * dl;
                return this.pos += 8, t1;
            },
            readFloat: function() {
                var t1 = cl(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4, t1;
            },
            readDouble: function() {
                var t1 = cl(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8, t1;
            },
            readVarint: function(t1) {
                var e1, r, n = this.buf;
                return e1 = 127 & (r = n[this.pos++]), r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e1 : function(t1, e1, r) {
                    var n, i, a = r.buf;
                    if (n = (112 & (i = a[r.pos++])) >> 4, i < 128) return xl(t1, n, e1);
                    if (n |= (127 & (i = a[r.pos++])) << 3, i < 128) return xl(t1, n, e1);
                    if (n |= (127 & (i = a[r.pos++])) << 10, i < 128) return xl(t1, n, e1);
                    if (n |= (127 & (i = a[r.pos++])) << 17, i < 128) return xl(t1, n, e1);
                    if (n |= (127 & (i = a[r.pos++])) << 24, i < 128) return xl(t1, n, e1);
                    if (n |= (1 & (i = a[r.pos++])) << 31, i < 128) return xl(t1, n, e1);
                    throw new Error("Expected varint not more than 10 bytes");
                }(e1 |= (15 & (r = n[this.pos])) << 28, t1, this))));
            },
            readVarint64: function() {
                return this.readVarint(!0);
            },
            readSVarint: function() {
                var t1 = this.readVarint();
                return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
            },
            readBoolean: function() {
                return Boolean(this.readVarint());
            },
            readString: function() {
                var t1 = this.readVarint() + this.pos, e1 = this.pos;
                return this.pos = t1, t1 - e1 >= 12 && ml ? function(t1, e1, r) {
                    return ml.decode(t1.subarray(e1, r));
                }(this.buf, e1, t1) : function(t1, e1, r) {
                    for(var n = "", i = e1; i < r;){
                        var a, s, o, l = t1[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                        if (i + c > r) break;
                        1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (a = t1[i + 1])) && (u = (31 & l) << 6 | 63 & a) <= 127 && (u = null) : 3 === c ? (s = t1[i + 2], 128 == (192 & (a = t1[i + 1])) && 128 == (192 & s) && ((u = (15 & l) << 12 | (63 & a) << 6 | 63 & s) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (s = t1[i + 2], o = t1[i + 3], 128 == (192 & (a = t1[i + 1])) && 128 == (192 & s) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & a) << 12 | (63 & s) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
                    }
                    return n;
                }(this.buf, e1, t1);
            },
            readBytes: function() {
                var t1 = this.readVarint() + this.pos, e1 = this.buf.subarray(this.pos, t1);
                return this.pos = t1, e1;
            },
            readPackedVarint: function(t1, e1) {
                if (this.type !== pl.Bytes) return t1.push(this.readVarint(e1));
                var r = gl(this);
                for(t1 = t1 || []; this.pos < r;)t1.push(this.readVarint(e1));
                return t1;
            },
            readPackedSVarint: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readSVarint());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSVarint());
                return t1;
            },
            readPackedBoolean: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readBoolean());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readBoolean());
                return t1;
            },
            readPackedFloat: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readFloat());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFloat());
                return t1;
            },
            readPackedDouble: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readDouble());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readDouble());
                return t1;
            },
            readPackedFixed32: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readFixed32());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFixed32());
                return t1;
            },
            readPackedSFixed32: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readSFixed32());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSFixed32());
                return t1;
            },
            readPackedFixed64: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readFixed64());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFixed64());
                return t1;
            },
            readPackedSFixed64: function(t1) {
                if (this.type !== pl.Bytes) return t1.push(this.readSFixed64());
                var e1 = gl(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSFixed64());
                return t1;
            },
            skip: function(t1) {
                var e1 = 7 & t1;
                if (e1 === pl.Varint) for(; this.buf[this.pos++] > 127;);
                else if (e1 === pl.Bytes) this.pos = this.readVarint() + this.pos;
                else if (e1 === pl.Fixed32) this.pos += 4;
                else {
                    if (e1 !== pl.Fixed64) throw new Error("Unimplemented type: " + e1);
                    this.pos += 8;
                }
            },
            writeTag: function(t1, e1) {
                this.writeVarint(t1 << 3 | e1);
            },
            realloc: function(t1) {
                for(var e1 = this.length || 16; e1 < this.pos + t1;)e1 *= 2;
                if (e1 !== this.length) {
                    var r = new Uint8Array(e1);
                    r.set(this.buf), this.buf = r, this.length = e1;
                }
            },
            finish: function() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            },
            writeFixed32: function(t1) {
                this.realloc(4), Cl(this.buf, t1, this.pos), this.pos += 4;
            },
            writeSFixed32: function(t1) {
                this.realloc(4), Cl(this.buf, t1, this.pos), this.pos += 4;
            },
            writeFixed64: function(t1) {
                this.realloc(8), Cl(this.buf, -1 & t1, this.pos), Cl(this.buf, Math.floor(t1 * yl), this.pos + 4), this.pos += 8;
            },
            writeSFixed64: function(t1) {
                this.realloc(8), Cl(this.buf, -1 & t1, this.pos), Cl(this.buf, Math.floor(t1 * yl), this.pos + 4), this.pos += 8;
            },
            writeVarint: function(t1) {
                (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e1) {
                    var r, n;
                    if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (n = ~(-t1 / 4294967296), 4294967295 ^ (r = ~(-t1 % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -18446744073709552000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e1.realloc(10), function(t1, e1, r) {
                        r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                    }(r, 0, e1), function(t1, e1) {
                        var r = (7 & t1) << 4;
                        e1.buf[e1.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1)))));
                    }(n, e1);
                }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
            },
            writeSVarint: function(t1) {
                this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
            },
            writeBoolean: function(t1) {
                this.writeVarint(Boolean(t1));
            },
            writeString: function(t1) {
                t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                var e1 = this.pos;
                this.pos = function(t1, e1, r) {
                    for(var n, i, a = 0; a < e1.length; a++){
                        if ((n = e1.charCodeAt(a)) > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || a + 1 === e1.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                continue;
                            }
                            if (n < 56320) {
                                t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                continue;
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                        n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                    }
                    return r;
                }(this.buf, t1, this.pos);
                var r = this.pos - e1;
                r >= 128 && vl(e1, r, this), this.pos = e1 - 1, this.writeVarint(r), this.pos += r;
            },
            writeFloat: function(t1) {
                this.realloc(4), hl(this.buf, t1, this.pos, !0, 23, 4), this.pos += 4;
            },
            writeDouble: function(t1) {
                this.realloc(8), hl(this.buf, t1, this.pos, !0, 52, 8), this.pos += 8;
            },
            writeBytes: function(t1) {
                var e1 = t1.length;
                this.writeVarint(e1), this.realloc(e1);
                for(var r = 0; r < e1; r++)this.buf[this.pos++] = t1[r];
            },
            writeRawMessage: function(t1, e1) {
                this.pos++;
                var r = this.pos;
                t1(e1, this);
                var n = this.pos - r;
                n >= 128 && vl(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            },
            writeMessage: function(t1, e1, r) {
                this.writeTag(t1, pl.Bytes), this.writeRawMessage(e1, r);
            },
            writePackedVarint: function(t1, e1) {
                e1.length && this.writeMessage(t1, bl, e1);
            },
            writePackedSVarint: function(t1, e1) {
                e1.length && this.writeMessage(t1, wl, e1);
            },
            writePackedBoolean: function(t1, e1) {
                e1.length && this.writeMessage(t1, kl, e1);
            },
            writePackedFloat: function(t1, e1) {
                e1.length && this.writeMessage(t1, _l, e1);
            },
            writePackedDouble: function(t1, e1) {
                e1.length && this.writeMessage(t1, Al, e1);
            },
            writePackedFixed32: function(t1, e1) {
                e1.length && this.writeMessage(t1, Sl, e1);
            },
            writePackedSFixed32: function(t1, e1) {
                e1.length && this.writeMessage(t1, Il, e1);
            },
            writePackedFixed64: function(t1, e1) {
                e1.length && this.writeMessage(t1, Ml, e1);
            },
            writePackedSFixed64: function(t1, e1) {
                e1.length && this.writeMessage(t1, zl, e1);
            },
            writeBytesField: function(t1, e1) {
                this.writeTag(t1, pl.Bytes), this.writeBytes(e1);
            },
            writeFixed32Field: function(t1, e1) {
                this.writeTag(t1, pl.Fixed32), this.writeFixed32(e1);
            },
            writeSFixed32Field: function(t1, e1) {
                this.writeTag(t1, pl.Fixed32), this.writeSFixed32(e1);
            },
            writeFixed64Field: function(t1, e1) {
                this.writeTag(t1, pl.Fixed64), this.writeFixed64(e1);
            },
            writeSFixed64Field: function(t1, e1) {
                this.writeTag(t1, pl.Fixed64), this.writeSFixed64(e1);
            },
            writeVarintField: function(t1, e1) {
                this.writeTag(t1, pl.Varint), this.writeVarint(e1);
            },
            writeSVarintField: function(t1, e1) {
                this.writeTag(t1, pl.Varint), this.writeSVarint(e1);
            },
            writeStringField: function(t1, e1) {
                this.writeTag(t1, pl.Bytes), this.writeString(e1);
            },
            writeFloatField: function(t1, e1) {
                this.writeTag(t1, pl.Fixed32), this.writeFloat(e1);
            },
            writeDoubleField: function(t1, e1) {
                this.writeTag(t1, pl.Fixed64), this.writeDouble(e1);
            },
            writeBooleanField: function(t1, e1) {
                this.writeVarintField(t1, Boolean(e1));
            }
        };
        class Ll {
            constructor(t1, { pixelRatio: e1, version: r, stretchX: n, stretchY: i, content: a }){
                this.paddedRect = t1, this.pixelRatio = e1, this.stretchX = n, this.stretchY = i, this.content = a, this.version = r;
            }
            get tl() {
                return [
                    this.paddedRect.x + 1,
                    this.paddedRect.y + 1
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - 1,
                    this.paddedRect.y + this.paddedRect.h - 1
                ];
            }
            get tlbr() {
                return this.tl.concat(this.br);
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2) / this.pixelRatio,
                    (this.paddedRect.h - 2) / this.pixelRatio
                ];
            }
        }
        class Dl {
            constructor(t1, e1){
                const r = {}, n = {};
                this.haveRenderCallbacks = [];
                const i = [];
                this.addImages(t1, r, i), this.addImages(e1, n, i);
                const { w: a, h: s } = Tl(i), o = new Bs({
                    width: a || 1,
                    height: s || 1
                });
                for(const e1 in t1){
                    const n = t1[e1], i = r[e1].paddedRect;
                    Bs.copy(n.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: i.x + 1,
                        y: i.y + 1
                    }, n.data);
                }
                for(const t1 in e1){
                    const r = e1[t1], i = n[t1].paddedRect, a = i.x + 1, s = i.y + 1, l = r.data.width, u = r.data.height;
                    Bs.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: s
                    }, r.data), Bs.copy(r.data, o, {
                        x: 0,
                        y: u - 1
                    }, {
                        x: a,
                        y: s - 1
                    }, {
                        width: l,
                        height: 1
                    }), Bs.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: s + u
                    }, {
                        width: l,
                        height: 1
                    }), Bs.copy(r.data, o, {
                        x: l - 1,
                        y: 0
                    }, {
                        x: a - 1,
                        y: s
                    }, {
                        width: 1,
                        height: u
                    }), Bs.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: a + l,
                        y: s
                    }, {
                        width: 1,
                        height: u
                    });
                }
                this.image = o, this.iconPositions = r, this.patternPositions = n;
            }
            addImages(t1, e1, r) {
                for(const n in t1){
                    const i = t1[n], a = {
                        x: 0,
                        y: 0,
                        w: i.data.width + 2,
                        h: i.data.height + 2
                    };
                    r.push(a), e1[n] = new Ll(a, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
                }
            }
            patchUpdatedImages(t1, e1) {
                t1.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for(const r in t1.updatedImages)this.patchUpdatedImage(this.iconPositions[r], t1.getImage(r), e1), this.patchUpdatedImage(this.patternPositions[r], t1.getImage(r), e1);
            }
            patchUpdatedImage(t1, e1, r) {
                if (!t1 || !e1) return;
                if (t1.version === e1.version) return;
                t1.version = e1.version;
                const [n, i] = t1.tl;
                r.update(e1.data, void 0, {
                    x: n,
                    y: i
                });
            }
        }
        Mn("ImagePosition", Ll), Mn("ImageAtlas", Dl), t1.WritingMode = void 0, (fl = t1.WritingMode || (t1.WritingMode = {}))[fl.none = 0] = "none", fl[fl.horizontal = 1] = "horizontal", fl[fl.vertical = 2] = "vertical", fl[fl.horizontalOnly = 3] = "horizontalOnly";
        const $l = -17;
        class Rl {
            constructor(){
                this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t1, e1) {
                const r = new Rl;
                return r.scale = t1 || 1, r.fontStack = e1, r;
            }
            static forImage(t1) {
                const e1 = new Rl;
                return e1.imageName = t1, e1;
            }
        }
        class Ol {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e1) {
                const r = new Ol;
                for(let n = 0; n < t1.sections.length; n++){
                    const i = t1.sections[n];
                    i.image ? r.addImageSection(i) : r.addTextSection(i, e1);
                }
                return r;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCharCode(t1) {
                return this.text.charCodeAt(t1);
            }
            verticalizePunctuation() {
                this.text = function(t1) {
                    let e1 = "";
                    for(let r = 0; r < t1.length; r++){
                        const n = t1.charCodeAt(r + 1) || null, i = t1.charCodeAt(r - 1) || null;
                        e1 += n && Dn(n) && !ol[t1[r + 1]] || i && Dn(i) && !ol[t1[r - 1]] || !ol[t1[r]] ? t1[r] : ol[t1[r]];
                    }
                    return e1;
                }(this.text);
            }
            trim() {
                let t1 = 0;
                for(let e1 = 0; e1 < this.text.length && ql[this.text.charCodeAt(e1)]; e1++)t1++;
                let e1 = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && ql[this.text.charCodeAt(r)]; r--)e1--;
                this.text = this.text.substring(t1, e1), this.sectionIndex = this.sectionIndex.slice(t1, e1);
            }
            substring(t1, e1) {
                const r = new Ol;
                return r.text = this.text.substring(t1, e1), r.sectionIndex = this.sectionIndex.slice(t1, e1), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e1)=>Math.max(t1, this.sections[e1].scale), 0);
            }
            addTextSection(t1, e1) {
                this.text += t1.text, this.sections.push(Rl.forText(t1.scale, t1.fontStack || e1));
                const r = this.sections.length - 1;
                for(let e1 = 0; e1 < t1.text.length; ++e1)this.sectionIndex.push(r);
            }
            addImageSection(t1) {
                const e1 = t1.image ? t1.image.name : "";
                if (0 === e1.length) return void d("Can't add FormattedSection with an empty image.");
                const r = this.getNextImageSectionCharCode();
                r ? (this.text += String.fromCharCode(r), this.sections.push(Rl.forImage(e1)), this.sectionIndex.push(this.sections.length - 1)) : d("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function Ul(e1, r, n, i, a, s, o, l, u, c, h, p, f, d, y, m) {
            const g = Ol.fromFeature(e1, a);
            let x;
            p === t1.WritingMode.vertical && g.verticalizePunctuation();
            const { processBidirectionalText: v, processStyledBidirectionalText: b } = Wn;
            if (v && 1 === g.sections.length) {
                x = [];
                const t1 = v(g.toString(), Xl(g, c, s, r, i, d, y));
                for (const e1 of t1){
                    const t1 = new Ol;
                    t1.text = e1, t1.sections = g.sections;
                    for(let r = 0; r < e1.length; r++)t1.sectionIndex.push(0);
                    x.push(t1);
                }
            } else if (b) {
                x = [];
                const t1 = b(g.text, g.sectionIndex, Xl(g, c, s, r, i, d, y));
                for (const e1 of t1){
                    const t1 = new Ol;
                    t1.text = e1[0], t1.sectionIndex = e1[1], t1.sections = g.sections, x.push(t1);
                }
            } else x = function(t1, e1) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e1)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(g, Xl(g, c, s, r, i, d, y));
            const w = [], _ = {
                positionedLines: w,
                text: g.toString(),
                top: h[1],
                bottom: h[1],
                left: h[0],
                right: h[0],
                writingMode: p,
                iconsInText: !1,
                verticalizable: !1
            };
            return function(e1, r, n, i, a, s, o, l, u, c, h, p) {
                let f = 0, d = $l, y = 0, m = 0;
                const g = "right" === l ? 1 : "left" === l ? 0 : .5;
                let x = 0;
                for (const o of a){
                    o.trim();
                    const a = o.getMaxScale(), l = (a - 1) * ll, b = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    e1.positionedLines[x] = b;
                    const w = b.positionedGlyphs;
                    let _ = 0;
                    if (!o.length()) {
                        d += s, ++x;
                        continue;
                    }
                    for(let s = 0; s < o.length(); s++){
                        const y = o.getSection(s), m = o.getSectionIndex(s), g = o.getCharCode(s);
                        let x = 0, b = null, A = null, k = null, S = ll;
                        const I = !(u === t1.WritingMode.horizontal || !h && !Ln(g) || h && (ql[g] || (v = g, Vn.Arabic(v) || Vn["Arabic Supplement"](v) || Vn["Arabic Extended-A"](v) || Vn["Arabic Presentation Forms-A"](v) || Vn["Arabic Presentation Forms-B"](v))));
                        if (y.imageName) {
                            const t1 = i[y.imageName];
                            if (!t1) continue;
                            k = y.imageName, e1.iconsInText = e1.iconsInText || !0, A = t1.paddedRect;
                            const r = t1.displaySize;
                            y.scale = y.scale * ll / p, b = {
                                width: r[0],
                                height: r[1],
                                left: 1,
                                top: -3,
                                advance: I ? r[1] : r[0]
                            }, x = l + (ll - r[1] * y.scale), S = b.advance;
                            const n = I ? r[0] * y.scale - ll * a : r[1] * y.scale - ll * a;
                            n > 0 && n > _ && (_ = n);
                        } else {
                            const t1 = n[y.fontStack], e1 = t1 && t1[g];
                            if (e1 && e1.rect) A = e1.rect, b = e1.metrics;
                            else {
                                const t1 = r[y.fontStack], e1 = t1 && t1[g];
                                if (!e1) continue;
                                b = e1.metrics;
                            }
                            x = (a - y.scale) * ll;
                        }
                        I ? (e1.verticalizable = !0, w.push({
                            glyph: g,
                            imageName: k,
                            x: f,
                            y: d + x,
                            vertical: I,
                            scale: y.scale,
                            fontStack: y.fontStack,
                            sectionIndex: m,
                            metrics: b,
                            rect: A
                        }), f += S * y.scale + c) : (w.push({
                            glyph: g,
                            imageName: k,
                            x: f,
                            y: d + x,
                            vertical: I,
                            scale: y.scale,
                            fontStack: y.fontStack,
                            sectionIndex: m,
                            metrics: b,
                            rect: A
                        }), f += b.advance * y.scale + c);
                    }
                    0 !== w.length && (y = Math.max(f - c, y), Hl(w, 0, w.length - 1, g, _)), f = 0;
                    const A = s * a + _;
                    b.lineOffset = Math.max(_, l), d += A, m = Math.max(A, m), ++x;
                }
                var v;
                const b = d - $l, { horizontalAlign: w, verticalAlign: _ } = Yl(o);
                (function(t1, e1, r, n, i, a, s, o, l) {
                    const u = (e1 - r) * i;
                    let c = 0;
                    c = a !== s ? -o * n - $l : (-n * l + .5) * s;
                    for (const e1 of t1)for (const t1 of e1.positionedGlyphs)t1.x += u, t1.y += c;
                })(e1.positionedLines, g, w, _, y, m, s, b, a.length), e1.top += -_ * b, e1.bottom = e1.top + b, e1.left += -w * y, e1.right = e1.left + y;
            }(_, r, n, i, x, o, l, u, p, c, f, m), !function(t1) {
                for (const e1 of t1)if (0 !== e1.positionedGlyphs.length) return !1;
                return !0;
            }(w) && _;
        }
        const ql = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, jl = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function Nl(t1, e1, r, n, i, a) {
            if (e1.imageName) {
                const t1 = n[e1.imageName];
                return t1 ? t1.displaySize[0] * e1.scale * ll / a + i : 0;
            }
            {
                const n = r[e1.fontStack], a = n && n[t1];
                return a ? a.metrics.advance * e1.scale + i : 0;
            }
        }
        function Zl(t1, e1, r, n) {
            const i = Math.pow(t1 - e1, 2);
            return n ? t1 < e1 ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function Kl(t1, e1, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e1 && 65289 !== e1 || (n += 50), n;
        }
        function Gl(t1, e1, r, n, i, a) {
            let s = null, o = Zl(e1, r, i, a);
            for (const t1 of n){
                const n = Zl(e1 - t1.x, r, i, a) + t1.badness;
                n <= o && (s = t1, o = n);
            }
            return {
                index: t1,
                x: e1,
                priorBreak: s,
                badness: o
            };
        }
        function Jl(t1) {
            return t1 ? Jl(t1.priorBreak).concat(t1.index) : [];
        }
        function Xl(t1, e1, r, n, i, a, s) {
            if ("point" !== a) return [];
            if (!t1) return [];
            const o = [], l = function(t1, e1, r, n, i, a) {
                let s = 0;
                for(let r = 0; r < t1.length(); r++){
                    const o = t1.getSection(r);
                    s += Nl(t1.getCharCode(r), o, n, i, e1, a);
                }
                return s / Math.max(1, Math.ceil(s / r));
            }(t1, e1, r, n, i, s), u = t1.text.indexOf("\u200B") >= 0;
            let c = 0;
            for(let r = 0; r < t1.length(); r++){
                const a = t1.getSection(r), p = t1.getCharCode(r);
                if (ql[p] || (c += Nl(p, a, n, i, e1, s)), r < t1.length() - 1) {
                    const e1 = !((h = p) < 11904 || !(Vn["Bopomofo Extended"](h) || Vn.Bopomofo(h) || Vn["CJK Compatibility Forms"](h) || Vn["CJK Compatibility Ideographs"](h) || Vn["CJK Compatibility"](h) || Vn["CJK Radicals Supplement"](h) || Vn["CJK Strokes"](h) || Vn["CJK Symbols and Punctuation"](h) || Vn["CJK Unified Ideographs Extension A"](h) || Vn["CJK Unified Ideographs"](h) || Vn["Enclosed CJK Letters and Months"](h) || Vn["Halfwidth and Fullwidth Forms"](h) || Vn.Hiragana(h) || Vn["Ideographic Description Characters"](h) || Vn["Kangxi Radicals"](h) || Vn["Katakana Phonetic Extensions"](h) || Vn.Katakana(h) || Vn["Vertical Forms"](h) || Vn["Yi Radicals"](h) || Vn["Yi Syllables"](h)));
                    (jl[p] || e1 || a.imageName) && o.push(Gl(r + 1, c, l, o, Kl(p, t1.getCharCode(r + 1), e1 && u), !1));
                }
            }
            var h;
            return Jl(Gl(t1.length(), c, l, o, 0, !0));
        }
        function Yl(t1) {
            let e1 = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e1 = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e1 = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e1,
                verticalAlign: r
            };
        }
        function Hl(t1, e1, r, n, i) {
            if (!n && !i) return;
            const a = t1[r], s = (t1[r].x + a.metrics.advance * a.scale) * n;
            for(let n = e1; n <= r; n++)t1[n].x -= s, t1[n].y += i;
        }
        function Wl(t1, e1, r) {
            const { horizontalAlign: n, verticalAlign: i } = Yl(r), a = e1[0] - t1.displaySize[0] * n, s = e1[1] - t1.displaySize[1] * i;
            return {
                image: t1,
                top: s,
                bottom: s + t1.displaySize[1],
                left: a,
                right: a + t1.displaySize[0]
            };
        }
        function Ql(t1, e1, r, n, i, a) {
            const s = t1.image;
            let o;
            if (s.content) {
                const t1 = s.content, e1 = s.pixelRatio || 1;
                o = [
                    t1[0] / e1,
                    t1[1] / e1,
                    s.displaySize[0] - t1[2] / e1,
                    s.displaySize[1] - t1[3] / e1
                ];
            }
            const l = e1.left * a, u = e1.right * a;
            let c, h, p, f;
            "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - s.displaySize[0]) / 2, h = f + s.displaySize[0]);
            const d = e1.top * a, y = e1.bottom * a;
            return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - s.displaySize[1]) / 2, p = c + s.displaySize[1]), {
                image: s,
                top: c,
                right: h,
                bottom: p,
                left: f,
                collisionPadding: o
            };
        }
        const tu = 128;
        function eu(t1, e1) {
            const { expression: r } = e1;
            if ("constant" === r.kind) return {
                kind: "constant",
                layoutSize: r.evaluate(new Qn(t1 + 1))
            };
            if ("source" === r.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e1, interpolationType: n } = r;
                let i = 0;
                for(; i < e1.length && e1[i] <= t1;)i++;
                i = Math.max(0, i - 1);
                let a = i;
                for(; a < e1.length && e1[a] < t1 + 1;)a++;
                a = Math.min(e1.length - 1, a);
                const s = e1[i], o = e1[a];
                return "composite" === r.kind ? {
                    kind: "composite",
                    minZoom: s,
                    maxZoom: o,
                    interpolationType: n
                } : {
                    kind: "camera",
                    minZoom: s,
                    maxZoom: o,
                    minSize: r.evaluate(new Qn(s)),
                    maxSize: r.evaluate(new Qn(o)),
                    interpolationType: n
                };
            }
        }
        class ru extends S {
            constructor(t1, e1, r, n){
                super(t1, e1), this.angle = r, void 0 !== n && (this.segment = n);
            }
            clone() {
                return new ru(this.x, this.y, this.angle, this.segment);
            }
        }
        function nu(t1, e1, r, n, i) {
            if (void 0 === e1.segment) return !0;
            let a = e1, s = e1.segment + 1, o = 0;
            for(; o > -r / 2;){
                if (s--, s < 0) return !1;
                o -= t1[s].dist(a), a = t1[s];
            }
            o += t1[s].dist(t1[s + 1]), s++;
            const l = [];
            let u = 0;
            for(; o < r / 2;){
                const e1 = t1[s], r = t1[s + 1];
                if (!r) return !1;
                let a = t1[s - 1].angleTo(e1) - e1.angleTo(r);
                for(a = Math.abs((a + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: o,
                    angleDelta: a
                }), u += a; o - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                s++, o += e1.dist(r);
            }
            return !0;
        }
        function iu(t1) {
            let e1 = 0;
            for(let r = 0; r < t1.length - 1; r++)e1 += t1[r].dist(t1[r + 1]);
            return e1;
        }
        function au(t1, e1, r) {
            return t1 ? .6 * e1 * r : 0;
        }
        function su(t1, e1) {
            return Math.max(t1 ? t1.right - t1.left : 0, e1 ? e1.right - e1.left : 0);
        }
        function ou(t1, e1, r, n, i, a) {
            const s = au(r, i, a), o = su(r, n) * a;
            let l = 0;
            const u = iu(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], a = n.dist(i);
                if (l + a > u) {
                    const c = (u - l) / a, h = Se(n.x, i.x, c), p = Se(n.y, i.y, c), f = new ru(h, p, i.angleTo(n), r);
                    return f._round(), !s || nu(t1, f, o, s, e1) ? f : void 0;
                }
                l += a;
            }
        }
        function lu(t1, e1, r, n, i, a, s, o, l) {
            const u = au(n, a, s), c = su(n, i), h = c * s, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e1 - h < e1 / 4 && (e1 = h + e1 / 4), uu(t1, p ? e1 / 2 * o % e1 : (c / 2 + 2 * a) * s * o % e1, e1, u, r, h, p, !1, l);
        }
        function uu(t1, e1, r, n, i, a, s, o, l) {
            const u = a / 2, c = iu(t1);
            let h = 0, p = e1 - r, f = [];
            for(let e1 = 0; e1 < t1.length - 1; e1++){
                const s = t1[e1], o = t1[e1 + 1], d = s.dist(o), y = o.angleTo(s);
                for(; p + r < h + d;){
                    p += r;
                    const m = (p - h) / d, g = Se(s.x, o.x, m), x = Se(s.y, o.y, m);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new ru(g, x, y, e1);
                        r._round(), n && !nu(t1, r, a, n, i) || f.push(r);
                    }
                }
                h += d;
            }
            return o || f.length || s || (f = uu(t1, h / 2, r, n, i, a, s, !0, l)), f;
        }
        function cu(t1, e1, r, n, i) {
            const a = [];
            for(let s = 0; s < t1.length; s++){
                const o = t1[s];
                let l;
                for(let t1 = 0; t1 < o.length - 1; t1++){
                    let s = o[t1], u = o[t1 + 1];
                    s.x < e1 && u.x < e1 || (s.x < e1 ? s = new S(e1, s.y + (e1 - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x < e1 && (u = new S(e1, s.y + (e1 - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y < r && u.y < r || (s.y < r ? s = new S(s.x + (r - s.y) / (u.y - s.y) * (u.x - s.x), r)._round() : u.y < r && (u = new S(s.x + (r - s.y) / (u.y - s.y) * (u.x - s.x), r)._round()), s.x >= n && u.x >= n || (s.x >= n ? s = new S(n, s.y + (n - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x >= n && (u = new S(n, s.y + (n - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y >= i && u.y >= i || (s.y >= i ? s = new S(s.x + (i - s.y) / (u.y - s.y) * (u.x - s.x), i)._round() : u.y >= i && (u = new S(s.x + (i - s.y) / (u.y - s.y) * (u.x - s.x), i)._round()), l && s.equals(l[l.length - 1]) || (l = [
                        s
                    ], a.push(l)), l.push(u)))));
                }
            }
            return a;
        }
        function hu(t1, e1, r, n) {
            const i = [], a = t1.image, s = a.pixelRatio, o = a.paddedRect.w - 2, l = a.paddedRect.h - 2, u = t1.right - t1.left, c = t1.bottom - t1.top, h = a.stretchX || [
                [
                    0,
                    o
                ]
            ], p = a.stretchY || [
                [
                    0,
                    l
                ]
            ], f = (t1, e1)=>t1 + e1[1] - e1[0], d = h.reduce(f, 0), y = p.reduce(f, 0), m = o - d, g = l - y;
            let x = 0, v = d, b = 0, w = y, _ = 0, A = m, k = 0, I = g;
            if (a.content && n) {
                const t1 = a.content;
                x = pu(h, 0, t1[0]), b = pu(p, 0, t1[1]), v = pu(h, t1[0], t1[2]), w = pu(p, t1[1], t1[3]), _ = t1[0] - x, k = t1[1] - b, A = t1[2] - t1[0] - v, I = t1[3] - t1[1] - w;
            }
            const M = (n, i, o, l)=>{
                const h = du(n.stretch - x, v, u, t1.left), p = yu(n.fixed - _, A, n.stretch, d), f = du(i.stretch - b, w, c, t1.top), m = yu(i.fixed - k, I, i.stretch, y), g = du(o.stretch - x, v, u, t1.left), M = yu(o.fixed - _, A, o.stretch, d), z = du(l.stretch - b, w, c, t1.top), B = yu(l.fixed - k, I, l.stretch, y), C = new S(h, f), P = new S(g, f), V = new S(g, z), E = new S(h, z), F = new S(p / s, m / s), T = new S(M / s, B / s), L = e1 * Math.PI / 180;
                if (L) {
                    const t1 = Math.sin(L), e1 = Math.cos(L), r = [
                        e1,
                        -t1,
                        t1,
                        e1
                    ];
                    C._matMult(r), P._matMult(r), E._matMult(r), V._matMult(r);
                }
                const D = n.stretch + n.fixed, $ = i.stretch + i.fixed;
                return {
                    tl: C,
                    tr: P,
                    bl: E,
                    br: V,
                    tex: {
                        x: a.paddedRect.x + 1 + D,
                        y: a.paddedRect.y + 1 + $,
                        w: o.stretch + o.fixed - D,
                        h: l.stretch + l.fixed - $
                    },
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: F,
                    pixelOffsetBR: T,
                    minFontScaleX: A / s / u,
                    minFontScaleY: I / s / c,
                    isSDF: r
                };
            };
            if (n && (a.stretchX || a.stretchY)) {
                const t1 = fu(h, m, d), e1 = fu(p, g, y);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], a = t1[r + 1];
                    for(let t1 = 0; t1 < e1.length - 1; t1++)i.push(M(n, e1[t1], a, e1[t1 + 1]));
                }
            } else i.push(M({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: o + 1
            }, {
                fixed: 0,
                stretch: l + 1
            }));
            return i;
        }
        function pu(t1, e1, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e1, Math.min(r, i[1])) - Math.max(e1, Math.min(r, i[0]));
            return n;
        }
        function fu(t1, e1, r) {
            const n = [
                {
                    fixed: -1,
                    stretch: 0
                }
            ];
            for (const [e1, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e1 - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e1 - t1.stretch,
                    stretch: t1.stretch + (r - e1)
                });
            }
            return n.push({
                fixed: e1 + 1,
                stretch: r
            }), n;
        }
        function du(t1, e1, r, n) {
            return t1 / e1 * r + n;
        }
        function yu(t1, e1, r, n) {
            return t1 - e1 * r / n;
        }
        Mn("Anchor", ru);
        class mu {
            constructor(t1, e1, r, n, i, a, s, o, l, u){
                if (this.boxStartIndex = t1.length, l) {
                    let t1 = a.top, e1 = a.bottom;
                    const r = a.collisionPadding;
                    r && (t1 -= r[1], e1 += r[3]);
                    let n = e1 - t1;
                    n > 0 && (n = Math.max(10, n), this.circleDiameter = n);
                } else {
                    let l = a.top * s - o[0], c = a.bottom * s + o[2], h = a.left * s - o[3], p = a.right * s + o[1];
                    const f = a.collisionPadding;
                    if (f && (h -= f[0] * s, l -= f[1] * s, p += f[2] * s, c += f[3] * s), u) {
                        const t1 = new S(h, l), e1 = new S(p, l), r = new S(h, c), n = new S(p, c), i = u * Math.PI / 180;
                        t1._rotate(i), e1._rotate(i), r._rotate(i), n._rotate(i), h = Math.min(t1.x, e1.x, r.x, n.x), p = Math.max(t1.x, e1.x, r.x, n.x), l = Math.min(t1.y, e1.y, r.y, n.y), c = Math.max(t1.y, e1.y, r.y, n.y);
                    }
                    t1.emplaceBack(e1.x, e1.y, h, l, p, c, r, n, i);
                }
                this.boxEndIndex = t1.length;
            }
        }
        class gu {
            constructor(t1 = [], e1 = xu){
                if (this.data = t1, this.length = this.data.length, this.compare = e1, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this.length++, this._up(this.length - 1);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e1 = this.data.pop();
                return this.length--, this.length > 0 && (this.data[0] = e1, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e1, compare: r } = this, n = e1[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, a = e1[i];
                    if (r(n, a) >= 0) break;
                    e1[t1] = a, t1 = i;
                }
                e1[t1] = n;
            }
            _down(t1) {
                const { data: e1, compare: r } = this, n = this.length >> 1, i = e1[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1), a = e1[n];
                    const s = n + 1;
                    if (s < this.length && r(e1[s], a) < 0 && (n = s, a = e1[s]), r(a, i) >= 0) break;
                    e1[t1] = a, t1 = n;
                }
                e1[t1] = i;
            }
        }
        function xu(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function vu(t1, e1 = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, a = -1 / 0, s = -1 / 0;
            const o = t1[0];
            for(let t1 = 0; t1 < o.length; t1++){
                const e1 = o[t1];
                (!t1 || e1.x < n) && (n = e1.x), (!t1 || e1.y < i) && (i = e1.y), (!t1 || e1.x > a) && (a = e1.x), (!t1 || e1.y > s) && (s = e1.y);
            }
            const l = Math.min(a - n, s - i);
            let u = l / 2;
            const c = new gu([], bu);
            if (0 === l) return new S(n, i);
            for(let e1 = n; e1 < a; e1 += l)for(let r = i; r < s; r += l)c.push(new wu(e1 + u, r + u, u, t1));
            let h = function(t1) {
                let e1 = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, a = i.length, s = a - 1; t1 < a; s = t1++){
                    const a = i[t1], o = i[s], l = a.x * o.y - o.x * a.y;
                    r += (a.x + o.x) * l, n += (a.y + o.y) * l, e1 += 3 * l;
                }
                return new wu(r / e1, n / e1, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e1 || (u = n.h / 2, c.push(new wu(n.p.x - u, n.p.y - u, u, t1)), c.push(new wu(n.p.x + u, n.p.y - u, u, t1)), c.push(new wu(n.p.x - u, n.p.y + u, u, t1)), c.push(new wu(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function bu(t1, e1) {
            return e1.max - t1.max;
        }
        function wu(t1, e1, r, n) {
            this.p = new S(t1, e1), this.h = r, this.d = function(t1, e1) {
                let r = !1, n = 1 / 0;
                for(let i = 0; i < e1.length; i++){
                    const a = e1[i];
                    for(let e1 = 0, i = a.length, s = i - 1; e1 < i; s = e1++){
                        const i = a[e1], o = a[s];
                        i.y > t1.y != o.y > t1.y && t1.x < (o.x - i.x) * (t1.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, rs(t1, i, o));
                    }
                }
                return (r ? 1 : -1) * Math.sqrt(n);
            }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
        }
        const _u = Number.POSITIVE_INFINITY;
        function Au(t1, e1) {
            return e1[1] !== _u ? function(t1, e1, r) {
                let n = 0, i = 0;
                switch(e1 = Math.abs(e1), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = 7 - r;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e1;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e1;
                }
                return [
                    n,
                    i
                ];
            }(t1, e1[0], e1[1]) : function(t1, e1) {
                let r = 0, n = 0;
                e1 < 0 && (e1 = 0);
                const i = e1 / Math.sqrt(2);
                switch(t1){
                    case "top-right":
                    case "top-left":
                        n = i - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        n = 7 - i;
                        break;
                    case "bottom":
                        n = 7 - e1;
                        break;
                    case "top":
                        n = e1 - 7;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        r = -i;
                        break;
                    case "top-left":
                    case "bottom-left":
                        r = i;
                        break;
                    case "left":
                        r = e1;
                        break;
                    case "right":
                        r = -e1;
                }
                return [
                    r,
                    n
                ];
            }(t1, e1[0]);
        }
        function ku(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function Su(e1, r, n, i, a, s, o, l, u, c, h) {
            let p = s.textMaxSize.evaluate(r, {});
            void 0 === p && (p = o);
            const f = e1.layers[0].layout, y = f.get("icon-offset").evaluate(r, {}, h), m = zu(n.horizontal), g = o / 24, x = e1.tilePixelRatio * g, v = e1.tilePixelRatio * p / 24, b = e1.tilePixelRatio * l, w = e1.tilePixelRatio * f.get("symbol-spacing"), _ = f.get("text-padding") * e1.tilePixelRatio, A = function(t1, e1, r, n = 1) {
                const i = t1.get("icon-padding").evaluate(e1, {}, r), a = i && i.values;
                return [
                    a[0] * n,
                    a[1] * n,
                    a[2] * n,
                    a[3] * n
                ];
            }(f, r, h, e1.tilePixelRatio), k = f.get("text-max-angle") / 180 * Math.PI, S = "viewport" !== f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"), I = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"), M = f.get("symbol-placement"), z = w / 2, B = f.get("icon-text-fit");
            let C;
            i && "none" !== B && (e1.allowVerticalPlacement && n.vertical && (C = Ql(i, n.vertical, B, f.get("icon-text-fit-padding"), y, g)), m && (i = Ql(i, m, B, f.get("icon-text-fit-padding"), y, g)));
            const P = (l, p)=>{
                p.x < 0 || p.x >= qa || p.y < 0 || p.y >= qa || function(e1, r, n, i, a, s, o, l, u, c, h, p, f, y, m, g, x, v, b, w, _, A, k, S, I) {
                    const M = e1.addToLineVertexArray(r, n);
                    let z, B, C, P, V = 0, E = 0, F = 0, T = 0, L = -1, D = -1;
                    const $ = {};
                    let R = xa.exports(""), O = 0, U = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [O, U] = l.layout.get("text-offset").evaluate(_, {}, S).map((t1)=>t1 * ll) : (O = l.layout.get("text-radial-offset").evaluate(_, {}, S) * ll, U = _u), e1.allowVerticalPlacement && i.vertical) {
                        const t1 = l.layout.get("text-rotate").evaluate(_, {}, S) + 90;
                        C = new mu(u, r, c, h, p, i.vertical, f, y, m, t1), o && (P = new mu(u, r, c, h, p, o, x, v, m, t1));
                    }
                    if (a) {
                        const n = l.layout.get("icon-rotate").evaluate(_, {}), i = "none" !== l.layout.get("icon-text-fit"), s = hu(a, n, k, i), f = o ? hu(o, n, k, i) : void 0;
                        B = new mu(u, r, c, h, p, a, x, v, !1, n), V = 4 * s.length;
                        const y = e1.iconSizeData;
                        let m = null;
                        "source" === y.kind ? (m = [
                            tu * l.layout.get("icon-size").evaluate(_, {})
                        ], m[0] > Iu && d(`${e1.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === y.kind && (m = [
                            tu * A.compositeIconSizes[0].evaluate(_, {}, S),
                            tu * A.compositeIconSizes[1].evaluate(_, {}, S)
                        ], (m[0] > Iu || m[1] > Iu) && d(`${e1.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e1.addSymbols(e1.icon, s, m, w, b, _, t1.WritingMode.none, r, M.lineStartIndex, M.lineLength, -1, S), L = e1.icon.placedSymbolArray.length - 1, f && (E = 4 * f.length, e1.addSymbols(e1.icon, f, m, w, b, _, t1.WritingMode.vertical, r, M.lineStartIndex, M.lineLength, -1, S), D = e1.icon.placedSymbolArray.length - 1);
                    }
                    const q = Object.keys(i.horizontal);
                    for (const n of q){
                        const a = i.horizontal[n];
                        if (!z) {
                            R = xa.exports(a.text);
                            const t1 = l.layout.get("text-rotate").evaluate(_, {}, S);
                            z = new mu(u, r, c, h, p, a, f, y, m, t1);
                        }
                        const o = 1 === a.positionedLines.length;
                        if (F += Mu(e1, r, a, s, l, m, _, g, M, i.vertical ? t1.WritingMode.horizontal : t1.WritingMode.horizontalOnly, o ? q : [
                            n
                        ], $, L, A, S), o) break;
                    }
                    i.vertical && (T += Mu(e1, r, i.vertical, s, l, m, _, g, M, t1.WritingMode.vertical, [
                        "vertical"
                    ], $, D, A, S));
                    const j = z ? z.boxStartIndex : e1.collisionBoxArray.length, N = z ? z.boxEndIndex : e1.collisionBoxArray.length, Z = C ? C.boxStartIndex : e1.collisionBoxArray.length, K = C ? C.boxEndIndex : e1.collisionBoxArray.length, G = B ? B.boxStartIndex : e1.collisionBoxArray.length, J = B ? B.boxEndIndex : e1.collisionBoxArray.length, X = P ? P.boxStartIndex : e1.collisionBoxArray.length, Y = P ? P.boxEndIndex : e1.collisionBoxArray.length;
                    let H = -1;
                    const W = (t1, e1)=>t1 && t1.circleDiameter ? Math.max(t1.circleDiameter, e1) : e1;
                    H = W(z, H), H = W(C, H), H = W(B, H), H = W(P, H);
                    const Q = H > -1 ? 1 : 0;
                    Q && (H *= I / ll), e1.glyphOffsetArray.length >= Du.MAX_GLYPHS && d("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== _.sortKey && e1.addToSortKeyRanges(e1.symbolInstances.length, _.sortKey), e1.symbolInstances.emplaceBack(r.x, r.y, $.right >= 0 ? $.right : -1, $.center >= 0 ? $.center : -1, $.left >= 0 ? $.left : -1, $.vertical || -1, L, D, R, j, N, Z, K, G, J, X, Y, c, F, T, V, E, Q, 0, f, O, U, H);
                }(e1, p, l, n, i, a, C, e1.layers[0], e1.collisionBoxArray, r.index, r.sourceLayerIndex, e1.index, x, [
                    _,
                    _,
                    _,
                    _
                ], S, u, b, A, I, y, r, s, c, h, o);
            };
            if ("line" === M) for (const t1 of cu(r.geometry, 0, 0, qa, qa)){
                const r = lu(t1, w, k, n.vertical || m, i, 24, v, e1.overscaling, qa);
                for (const n of r){
                    const r = m;
                    r && Bu(e1, r.text, z, n) || P(t1, n);
                }
            }
            else if ("line-center" === M) {
                for (const t1 of r.geometry)if (t1.length > 1) {
                    const e1 = ou(t1, k, n.vertical || m, i, 24, v);
                    e1 && P(t1, e1);
                }
            } else if ("Polygon" === r.type) for (const t1 of ho(r.geometry, 0)){
                const e1 = vu(t1, 16);
                P(t1[0], new ru(e1.x, e1.y, 0));
            }
            else if ("LineString" === r.type) for (const t1 of r.geometry)P(t1, new ru(t1[0].x, t1[0].y, 0));
            else if ("Point" === r.type) for (const t1 of r.geometry)for (const e1 of t1)P([
                e1
            ], new ru(e1.x, e1.y, 0));
        }
        const Iu = 32640;
        function Mu(t1, e1, r, n, i, a, s, o, l, u, c, h, p, f, y) {
            const m = function(t1, e1, r, n, i, a, s, o) {
                const l = n.layout.get("text-rotate").evaluate(a, {}) * Math.PI / 180, u = [];
                for (const t1 of e1.positionedLines)for (const n of t1.positionedGlyphs){
                    if (!n.rect) continue;
                    const a = n.rect || {};
                    let c = 4, h = !0, p = 1, f = 0;
                    const d = (i || o) && n.vertical, y = n.metrics.advance * n.scale / 2;
                    if (o && e1.verticalizable) {
                        const e1 = (n.scale - 1) * ll, r = (ll - n.metrics.width * n.scale) / 2;
                        f = t1.lineOffset / 2 - (n.imageName ? -r : e1);
                    }
                    if (n.imageName) {
                        const t1 = s[n.imageName];
                        h = t1.sdf, p = t1.pixelRatio, c = 1 / p;
                    }
                    const m = i ? [
                        n.x + y,
                        n.y
                    ] : [
                        0,
                        0
                    ];
                    let g = i ? [
                        0,
                        0
                    ] : [
                        n.x + y + r[0],
                        n.y + r[1] - f
                    ], x = [
                        0,
                        0
                    ];
                    d && (x = g, g = [
                        0,
                        0
                    ]);
                    const v = (n.metrics.left - c) * n.scale - y + g[0], b = (-n.metrics.top - c) * n.scale + g[1], w = v + a.w * n.scale / p, _ = b + a.h * n.scale / p, A = new S(v, b), k = new S(w, b), I = new S(v, _), M = new S(w, _);
                    if (d) {
                        const t1 = new S(-y, y - $l), e1 = -Math.PI / 2, r = 12 - y, i = new S(22 - r, -(n.imageName ? r : 0)), a = new S(...x);
                        A._rotateAround(e1, t1)._add(i)._add(a), k._rotateAround(e1, t1)._add(i)._add(a), I._rotateAround(e1, t1)._add(i)._add(a), M._rotateAround(e1, t1)._add(i)._add(a);
                    }
                    if (l) {
                        const t1 = Math.sin(l), e1 = Math.cos(l), r = [
                            e1,
                            -t1,
                            t1,
                            e1
                        ];
                        A._matMult(r), k._matMult(r), I._matMult(r), M._matMult(r);
                    }
                    const z = new S(0, 0), B = new S(0, 0);
                    u.push({
                        tl: A,
                        tr: k,
                        bl: I,
                        br: M,
                        tex: a,
                        writingMode: e1.writingMode,
                        glyphOffset: m,
                        sectionIndex: n.sectionIndex,
                        isSDF: h,
                        pixelOffsetTL: z,
                        pixelOffsetBR: B,
                        minFontScaleX: 0,
                        minFontScaleY: 0
                    });
                }
                return u;
            }(0, r, o, i, a, s, n, t1.allowVerticalPlacement), g = t1.textSizeData;
            let x = null;
            "source" === g.kind ? (x = [
                tu * i.layout.get("text-size").evaluate(s, {})
            ], x[0] > Iu && d(`${t1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g.kind && (x = [
                tu * f.compositeTextSizes[0].evaluate(s, {}, y),
                tu * f.compositeTextSizes[1].evaluate(s, {}, y)
            ], (x[0] > Iu || x[1] > Iu) && d(`${t1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t1.addSymbols(t1.text, m, x, o, a, s, u, e1, l.lineStartIndex, l.lineLength, p, y);
            for (const e1 of c)h[e1] = t1.text.placedSymbolArray.length - 1;
            return 4 * m.length;
        }
        function zu(t1) {
            for(const e1 in t1)return t1[e1];
            return null;
        }
        function Bu(t1, e1, r, n) {
            const i = t1.compareText;
            if (e1 in i) {
                const t1 = i[e1];
                for(let e1 = t1.length - 1; e1 >= 0; e1--)if (n.dist(t1[e1]) < r) return !0;
            } else i[e1] = [];
            return i[e1].push(n), !1;
        }
        const Cu = _o.VectorTileFeature.types, Pu = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function Vu(t1, e1, r, n, i, a, s, o, l, u, c, h, p) {
            const f = o ? Math.min(Iu, Math.round(o[0])) : 0, d = o ? Math.min(Iu, Math.round(o[1])) : 0;
            t1.emplaceBack(e1, r, Math.round(32 * n), Math.round(32 * i), a, s, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function Eu(t1, e1, r) {
            t1.emplaceBack(e1.x, e1.y, r), t1.emplaceBack(e1.x, e1.y, r), t1.emplaceBack(e1.x, e1.y, r), t1.emplaceBack(e1.x, e1.y, r);
        }
        function Fu(t1) {
            for (const e1 of t1.sections)if (On(e1.text)) return !0;
            return !1;
        }
        class Tu {
            constructor(t1){
                this.layoutVertexArray = new sa, this.indexArray = new ha, this.programConfigurations = t1, this.segments = new ya, this.dynamicLayoutVertexArray = new oa, this.opacityVertexArray = new la, this.placedSymbolArray = new Ki;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t1, e1, r, n) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, el.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e1), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, rl.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, Pu, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
        }
        Mn("SymbolBuffers", Tu);
        class Lu {
            constructor(t1, e1, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e1, this.indexArray = new r, this.segments = new ya, this.collisionVertexArray = new ca;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, nl.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
        }
        Mn("CollisionBuffers", Lu);
        class Du {
            constructor(e1){
                this.collisionBoxArray = e1.collisionBoxArray, this.zoom = e1.zoom, this.overscaling = e1.overscaling, this.layers = e1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = e1.index, this.pixelRatio = e1.pixelRatio, this.sourceLayerIndex = e1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ds([]), this.placementViewportMatrix = ds([]);
                const r = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = eu(this.zoom, r["text-size"]), this.iconSizeData = eu(this.zoom, r["icon-size"]);
                const n = this.layers[0].layout, i = n.get("symbol-sort-key"), a = n.get("symbol-z-order");
                this.canOverlap = "never" !== qu(n, "text-overlap", "text-allow-overlap") || "never" !== qu(n, "icon-overlap", "icon-allow-overlap") || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a && !i.isConstant(), this.sortFeaturesByY = ("viewport-y" === a || "auto" === a && !this.sortFeaturesByKey) && this.canOverlap, "point" === n.get("symbol-placement") && (this.writingModes = n.get("text-writing-mode").map((e1)=>t1.WritingMode[e1])), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = e1.sourceID;
            }
            createArrays() {
                this.text = new Tu(new Ra(this.layers, this.zoom, (t1)=>/^text/.test(t1))), this.icon = new Tu(new Ra(this.layers, this.zoom, (t1)=>/^icon/.test(t1))), this.glyphOffsetArray = new Xi, this.lineVertexArray = new Yi, this.symbolInstances = new Ji;
            }
            calculateGlyphDependencies(t1, e1, r, n, i) {
                for(let a = 0; a < t1.length; a++)if (e1[t1.charCodeAt(a)] = !0, (r || n) && i) {
                    const r = ol[t1.charAt(a)];
                    r && (e1[r.charCodeAt(0)] = !0);
                }
            }
            populate(e1, r, n) {
                const i = this.layers[0], a = i.layout, s = a.get("text-font"), o = a.get("text-field"), l = a.get("icon-image"), u = ("constant" !== o.value.kind || o.value.value instanceof Dt && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== s.value.kind || s.value.value.length > 0), c = "constant" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0, h = a.get("symbol-sort-key");
                if (this.features = [], !u && !c) return;
                const p = r.iconDependencies, f = r.glyphDependencies, d = r.availableImages, y = new Qn(this.zoom);
                for (const { feature: r, id: o, index: l, sourceLayerIndex: m } of e1){
                    const e1 = i._featureFilter.needGeometry, g = Ka(r, e1);
                    if (!i._featureFilter.filter(y, g, n)) continue;
                    let x, v;
                    if (e1 || (g.geometry = Za(r)), u) {
                        const t1 = i.getValueAndResolveTokens("text-field", g, n, d), e1 = Dt.factory(t1);
                        Fu(e1) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Yn() || this.hasRTLText && Wn.isParsed()) && (x = sl(e1, i, g));
                    }
                    if (c) {
                        const t1 = i.getValueAndResolveTokens("icon-image", g, n, d);
                        v = t1 instanceof Rt ? t1 : Rt.fromString(t1);
                    }
                    if (!x && !v) continue;
                    const b = this.sortFeaturesByKey ? h.evaluate(g, {}, n) : void 0;
                    if (this.features.push({
                        id: o,
                        text: x,
                        icon: v,
                        index: l,
                        sourceLayerIndex: m,
                        geometry: g.geometry,
                        properties: r.properties,
                        type: Cu[r.type],
                        sortKey: b
                    }), v && (p[v.name] = !0), x) {
                        const e1 = s.evaluate(g, {}, n).join(","), r = "viewport" !== a.get("text-rotation-alignment") && "point" !== a.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t1.WritingMode.vertical) >= 0;
                        for (const t1 of x.sections)if (t1.image) p[t1.image.name] = !0;
                        else {
                            const n = En(x.toString()), i = t1.fontStack || e1, a = f[i] = f[i] || {};
                            this.calculateGlyphDependencies(t1.text, a, r, this.allowVerticalPlacement, n);
                        }
                    }
                }
                "line" === a.get("symbol-placement") && (this.features = function(t1) {
                    const e1 = {}, r = {}, n = [];
                    let i = 0;
                    function a(e1) {
                        n.push(t1[e1]), i++;
                    }
                    function s(t1, e1, i) {
                        const a = r[t1];
                        return delete r[t1], r[e1] = a, n[a].geometry[0].pop(), n[a].geometry[0] = n[a].geometry[0].concat(i[0]), a;
                    }
                    function o(t1, r, i) {
                        const a = e1[r];
                        return delete e1[r], e1[t1] = a, n[a].geometry[0].shift(), n[a].geometry[0] = i[0].concat(n[a].geometry[0]), a;
                    }
                    function l(t1, e1, r) {
                        const n = r ? e1[0][e1[0].length - 1] : e1[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            a(u);
                            continue;
                        }
                        const f = l(p, h), d = l(p, h, !0);
                        if (f in r && d in e1 && r[f] !== e1[d]) {
                            const t1 = o(f, d, h), i = s(f, d, n[t1].geometry);
                            delete e1[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else f in r ? s(f, d, h) : d in e1 ? o(f, d, h) : (a(u), e1[f] = i - 1, r[d] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), this.sortFeaturesByKey && this.features.sort((t1, e1)=>t1.sortKey - e1.sortKey);
            }
            update(t1, e1, r) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t1, e1, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t1, e1, this.layers, r));
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t1, e1) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) {
                    let r = t1.dist(e1[t1.segment + 1]), n = t1.dist(e1[t1.segment]);
                    const i = {};
                    for(let n = t1.segment + 1; n < e1.length; n++)i[n] = {
                        x: e1[n].x,
                        y: e1[n].y,
                        tileUnitDistanceFromAnchor: r
                    }, n < e1.length - 1 && (r += e1[n + 1].dist(e1[n]));
                    for(let r = t1.segment || 0; r >= 0; r--)i[r] = {
                        x: e1[r].x,
                        y: e1[r].y,
                        tileUnitDistanceFromAnchor: n
                    }, r > 0 && (n += e1[r - 1].dist(e1[r]));
                    for(let t1 = 0; t1 < e1.length; t1++){
                        const e1 = i[t1];
                        this.lineVertexArray.emplaceBack(e1.x, e1.y, e1.tileUnitDistanceFromAnchor);
                    }
                }
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(e1, r, n, i, a, s, o, l, u, c, h, p) {
                const f = e1.indexArray, d = e1.layoutVertexArray, y = e1.segments.prepareSegment(4 * r.length, d, f, this.canOverlap ? s.sortKey : void 0), m = this.glyphOffsetArray.length, g = y.vertexLength, x = this.allowVerticalPlacement && o === t1.WritingMode.vertical ? Math.PI / 2 : 0, v = s.text && s.text.sections;
                for(let t1 = 0; t1 < r.length; t1++){
                    const { tl: i, tr: a, bl: o, br: u, tex: c, pixelOffsetTL: h, pixelOffsetBR: m, minFontScaleX: g, minFontScaleY: b, glyphOffset: w, isSDF: _, sectionIndex: A } = r[t1], k = y.vertexLength, S = w[1];
                    Vu(d, l.x, l.y, i.x, S + i.y, c.x, c.y, n, _, h.x, h.y, g, b), Vu(d, l.x, l.y, a.x, S + a.y, c.x + c.w, c.y, n, _, m.x, h.y, g, b), Vu(d, l.x, l.y, o.x, S + o.y, c.x, c.y + c.h, n, _, h.x, m.y, g, b), Vu(d, l.x, l.y, u.x, S + u.y, c.x + c.w, c.y + c.h, n, _, m.x, m.y, g, b), Eu(e1.dynamicLayoutVertexArray, l, x), f.emplaceBack(k, k + 1, k + 2), f.emplaceBack(k + 1, k + 2, k + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w[0]), t1 !== r.length - 1 && A === r[t1 + 1].sectionIndex || e1.programConfigurations.populatePaintArrays(d.length, s, s.index, {}, p, v && v[A]);
                }
                e1.placedSymbolArray.emplaceBack(l.x, l.y, m, this.glyphOffsetArray.length - m, g, u, c, l.segment, n ? n[0] : 0, n ? n[1] : 0, i[0], i[1], o, 0, !1, 0, h);
            }
            _addCollisionDebugVertex(t1, e1, r, n, i, a) {
                return e1.emplaceBack(0, 0), t1.emplaceBack(r.x, r.y, n, i, Math.round(a.x), Math.round(a.y));
            }
            addCollisionDebugVertices(t1, e1, r, n, i, a, s) {
                const o = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray), l = o.vertexLength, u = i.layoutVertexArray, c = i.collisionVertexArray, h = s.anchorX, p = s.anchorY;
                this._addCollisionDebugVertex(u, c, a, h, p, new S(t1, e1)), this._addCollisionDebugVertex(u, c, a, h, p, new S(r, e1)), this._addCollisionDebugVertex(u, c, a, h, p, new S(r, n)), this._addCollisionDebugVertex(u, c, a, h, p, new S(t1, n)), o.vertexLength += 4;
                const f = i.indexArray;
                f.emplaceBack(l, l + 1), f.emplaceBack(l + 1, l + 2), f.emplaceBack(l + 2, l + 3), f.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t1, e1, r, n) {
                for(let i = t1; i < e1; i++){
                    const t1 = this.collisionBoxArray.get(i);
                    this.addCollisionDebugVertices(t1.x1, t1.y1, t1.x2, t1.y2, n ? this.textCollisionBox : this.iconCollisionBox, t1.anchorPoint, r);
                }
            }
            generateCollisionDebugBuffers() {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Lu(ua, il.members, pa), this.iconCollisionBox = new Lu(ua, il.members, pa);
                for(let t1 = 0; t1 < this.symbolInstances.length; t1++){
                    const e1 = this.symbolInstances.get(t1);
                    this.addDebugCollisionBoxes(e1.textBoxStartIndex, e1.textBoxEndIndex, e1, !0), this.addDebugCollisionBoxes(e1.verticalTextBoxStartIndex, e1.verticalTextBoxEndIndex, e1, !0), this.addDebugCollisionBoxes(e1.iconBoxStartIndex, e1.iconBoxEndIndex, e1, !1), this.addDebugCollisionBoxes(e1.verticalIconBoxStartIndex, e1.verticalIconBoxEndIndex, e1, !1);
                }
            }
            _deserializeCollisionBoxesForSymbol(t1, e1, r, n, i, a, s, o, l) {
                const u = {};
                for(let n = e1; n < r; n++){
                    const e1 = t1.get(n);
                    u.textBox = {
                        x1: e1.x1,
                        y1: e1.y1,
                        x2: e1.x2,
                        y2: e1.y2,
                        anchorPointX: e1.anchorPointX,
                        anchorPointY: e1.anchorPointY
                    }, u.textFeatureIndex = e1.featureIndex;
                    break;
                }
                for(let e1 = n; e1 < i; e1++){
                    const r = t1.get(e1);
                    u.verticalTextBox = {
                        x1: r.x1,
                        y1: r.y1,
                        x2: r.x2,
                        y2: r.y2,
                        anchorPointX: r.anchorPointX,
                        anchorPointY: r.anchorPointY
                    }, u.verticalTextFeatureIndex = r.featureIndex;
                    break;
                }
                for(let e1 = a; e1 < s; e1++){
                    const r = t1.get(e1);
                    u.iconBox = {
                        x1: r.x1,
                        y1: r.y1,
                        x2: r.x2,
                        y2: r.y2,
                        anchorPointX: r.anchorPointX,
                        anchorPointY: r.anchorPointY
                    }, u.iconFeatureIndex = r.featureIndex;
                    break;
                }
                for(let e1 = o; e1 < l; e1++){
                    const r = t1.get(e1);
                    u.verticalIconBox = {
                        x1: r.x1,
                        y1: r.y1,
                        x2: r.x2,
                        y2: r.y2,
                        anchorPointX: r.anchorPointX,
                        anchorPointY: r.anchorPointY
                    }, u.verticalIconFeatureIndex = r.featureIndex;
                    break;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e1 = 0; e1 < this.symbolInstances.length; e1++){
                    const r = this.symbolInstances.get(e1);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t1, e1) {
                const r = t1.placedSymbolArray.get(e1), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e1 = r.vertexStartIndex; e1 < n; e1 += 4)t1.indexArray.emplaceBack(e1, e1 + 1, e1 + 2), t1.indexArray.emplaceBack(e1 + 1, e1 + 2, e1 + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e1 = Math.sin(t1), r = Math.cos(t1), n = [], i = [], a = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    a.push(t1);
                    const s = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e1 * s.anchorX + r * s.anchorY)), i.push(s.featureIndex);
                }
                return a.sort((t1, e1)=>n[t1] - n[e1] || i[e1] - i[t1]), a;
            }
            addToSortKeyRanges(t1, e1) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e1 ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e1,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e1 = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e1.featureIndex), [
                            e1.rightJustifiedTextSymbolIndex,
                            e1.centerJustifiedTextSymbolIndex,
                            e1.leftJustifiedTextSymbolIndex
                        ].forEach((t1, e1, r)=>{
                            t1 >= 0 && r.indexOf(t1) === e1 && this.addIndicesForPlacedSymbol(this.text, t1);
                        }), e1.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e1.verticalPlacedTextSymbolIndex), e1.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e1.placedIconSymbolIndex), e1.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e1.verticalPlacedIconSymbolIndex);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        Mn("SymbolBucket", Du, {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), Du.MAX_GLYPHS = 65535, Du.addDynamicAttributes = Eu;
        const $u = new fi({
            "symbol-placement": new li(nt.layout_symbol["symbol-placement"]),
            "symbol-spacing": new li(nt.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new li(nt.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new ui(nt.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new li(nt.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new li(nt.layout_symbol["icon-allow-overlap"]),
            "icon-overlap": new li(nt.layout_symbol["icon-overlap"]),
            "icon-ignore-placement": new li(nt.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new li(nt.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new li(nt.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new ui(nt.layout_symbol["icon-size"]),
            "icon-text-fit": new li(nt.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new li(nt.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new ui(nt.layout_symbol["icon-image"]),
            "icon-rotate": new ui(nt.layout_symbol["icon-rotate"]),
            "icon-padding": new ui(nt.layout_symbol["icon-padding"]),
            "icon-keep-upright": new li(nt.layout_symbol["icon-keep-upright"]),
            "icon-offset": new ui(nt.layout_symbol["icon-offset"]),
            "icon-anchor": new ui(nt.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new li(nt.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new li(nt.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new li(nt.layout_symbol["text-rotation-alignment"]),
            "text-field": new ui(nt.layout_symbol["text-field"]),
            "text-font": new ui(nt.layout_symbol["text-font"]),
            "text-size": new ui(nt.layout_symbol["text-size"]),
            "text-max-width": new ui(nt.layout_symbol["text-max-width"]),
            "text-line-height": new li(nt.layout_symbol["text-line-height"]),
            "text-letter-spacing": new ui(nt.layout_symbol["text-letter-spacing"]),
            "text-justify": new ui(nt.layout_symbol["text-justify"]),
            "text-radial-offset": new ui(nt.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new li(nt.layout_symbol["text-variable-anchor"]),
            "text-anchor": new ui(nt.layout_symbol["text-anchor"]),
            "text-max-angle": new li(nt.layout_symbol["text-max-angle"]),
            "text-writing-mode": new li(nt.layout_symbol["text-writing-mode"]),
            "text-rotate": new ui(nt.layout_symbol["text-rotate"]),
            "text-padding": new li(nt.layout_symbol["text-padding"]),
            "text-keep-upright": new li(nt.layout_symbol["text-keep-upright"]),
            "text-transform": new ui(nt.layout_symbol["text-transform"]),
            "text-offset": new ui(nt.layout_symbol["text-offset"]),
            "text-allow-overlap": new li(nt.layout_symbol["text-allow-overlap"]),
            "text-overlap": new li(nt.layout_symbol["text-overlap"]),
            "text-ignore-placement": new li(nt.layout_symbol["text-ignore-placement"]),
            "text-optional": new li(nt.layout_symbol["text-optional"])
        });
        var Ru = {
            paint: new fi({
                "icon-opacity": new ui(nt.paint_symbol["icon-opacity"]),
                "icon-color": new ui(nt.paint_symbol["icon-color"]),
                "icon-halo-color": new ui(nt.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new ui(nt.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new ui(nt.paint_symbol["icon-halo-blur"]),
                "icon-translate": new li(nt.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new li(nt.paint_symbol["icon-translate-anchor"]),
                "text-opacity": new ui(nt.paint_symbol["text-opacity"]),
                "text-color": new ui(nt.paint_symbol["text-color"], {
                    runtimeType: yt,
                    getOverride: (t1)=>t1.textColor,
                    hasOverride: (t1)=>!!t1.textColor
                }),
                "text-halo-color": new ui(nt.paint_symbol["text-halo-color"]),
                "text-halo-width": new ui(nt.paint_symbol["text-halo-width"]),
                "text-halo-blur": new ui(nt.paint_symbol["text-halo-blur"]),
                "text-translate": new li(nt.paint_symbol["text-translate"]),
                "text-translate-anchor": new li(nt.paint_symbol["text-translate-anchor"])
            }),
            layout: $u
        };
        class Ou {
            constructor(t1){
                if (void 0 === t1.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : ht, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e1 = this.defaultValue.property.overrides;
                    if (e1 && e1.hasOverride(t1.formattedSection)) return e1.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        Mn("FormatSectionOverride", Ou, {
            omit: [
                "defaultValue"
            ]
        });
        class Uu extends yi {
            constructor(t1){
                super(t1, Ru);
            }
            recalculate(t1, e1) {
                if (super.recalculate(t1, e1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                    const t1 = this.layout.get("text-writing-mode");
                    if (t1) {
                        const e1 = [];
                        for (const r of t1)e1.indexOf(r) < 0 && e1.push(r);
                        this.layout._values["text-writing-mode"] = e1;
                    } else this.layout._values["text-writing-mode"] = [
                        "horizontal"
                    ];
                }
                this._setPaintOverrides();
            }
            getValueAndResolveTokens(t1, e1, r, n) {
                const i = this.layout.get(t1).evaluate(e1, {}, r, n), a = this._unevaluatedLayout._values[t1];
                return a.isDataDriven() || Er(a.value) || !i ? i : function(t1, e1) {
                    return e1.replace(/{([^{}]+)}/g, (e1, r)=>r in t1 ? String(t1[r]) : "");
                }(e1.properties, i);
            }
            createBucket(t1) {
                return new Du(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                throw new Error("Should take a different path in FeatureIndex");
            }
            _setPaintOverrides() {
                for (const t1 of Ru.paint.overridableProperties){
                    if (!Uu.hasPaintOverride(this.layout, t1)) continue;
                    const e1 = this.paint.get(t1), r = new Ou(e1), n = new Vr(r, e1.property.specification);
                    let i = null;
                    i = "constant" === e1.value.kind || "source" === e1.value.kind ? new Tr("source", n) : new Lr("composite", n, e1.value.zoomStops), this.paint._values[t1] = new si(e1.property, i, e1.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e1, r) {
                return !(!this.layout || e1.isDataDriven() || r.isDataDriven()) && Uu.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e1) {
                const r = t1.get("text-field"), n = Ru.paint.properties[e1];
                let i = !1;
                const a = (t1)=>{
                    for (const e1 of t1)if (n.overrides && n.overrides.hasOverride(e1)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof Dt) a(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e1)=>{
                        i || (e1 instanceof Nt && qt(e1.value) === vt ? a(e1.value.sections) : e1 instanceof cr ? a(e1.sections) : e1.eachChild(t1));
                    }, e1 = r.value;
                    e1._styleExpression && t1(e1._styleExpression.expression);
                }
                return i;
            }
        }
        function qu(t1, e1, r) {
            let n = "never";
            const i = t1.get(e1);
            return i ? n = i : t1.get(r) && (n = "always"), n;
        }
        var ju = {
            paint: new fi({
                "background-color": new li(nt.paint_background["background-color"]),
                "background-pattern": new hi(nt.paint_background["background-pattern"]),
                "background-opacity": new li(nt.paint_background["background-opacity"])
            })
        }, Nu = {
            paint: new fi({
                "raster-opacity": new li(nt.paint_raster["raster-opacity"]),
                "raster-hue-rotate": new li(nt.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new li(nt.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new li(nt.paint_raster["raster-brightness-max"]),
                "raster-saturation": new li(nt.paint_raster["raster-saturation"]),
                "raster-contrast": new li(nt.paint_raster["raster-contrast"]),
                "raster-resampling": new li(nt.paint_raster["raster-resampling"]),
                "raster-fade-duration": new li(nt.paint_raster["raster-fade-duration"])
            })
        };
        class Zu extends yi {
            constructor(t1){
                super(t1, {}), this.onAdd = (t1)=>{
                    this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
                }, this.onRemove = (t1)=>{
                    this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
                }, this.implementation = t1;
            }
            is3D() {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {
                throw new Error("Custom layers cannot be serialized");
            }
        }
        const Ku = {
            circle: class extends yi {
                constructor(t1){
                    super(t1, cs);
                }
                createBucket(t1) {
                    return new Ja(t1);
                }
                queryRadius(t1) {
                    const e1 = t1;
                    return ss("circle-radius", this, e1) + ss("circle-stroke-width", this, e1) + os(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, a, s, o) {
                    const l = ls(t1, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, s), u = this.paint.get("circle-radius").evaluate(e1, r) + this.paint.get("circle-stroke-width").evaluate(e1, r), c = "map" === this.paint.get("circle-pitch-alignment"), h = c ? l : function(t1, e1) {
                        return t1.map((t1)=>_s(t1, e1));
                    }(l, o), p = c ? u * s : u;
                    for (const t1 of n)for (const e1 of t1){
                        const t1 = c ? e1 : _s(e1, o);
                        let r = p;
                        const n = bs([], [
                            e1.x,
                            e1.y,
                            0,
                            1
                        ], o);
                        if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r *= n[3] / a.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r *= a.cameraToCenterDistance / n[3]), Ya(h, t1, r)) return !0;
                    }
                    return !1;
                }
            },
            heatmap: class extends yi {
                constructor(t1){
                    super(t1, ks), this._updateColorRamp();
                }
                createBucket(t1) {
                    return new As(t1);
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = Cs({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                queryRadius() {
                    return 0;
                }
                queryIntersectsFeature() {
                    return !1;
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
            },
            hillshade: class extends yi {
                constructor(t1){
                    super(t1, Ps);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
            },
            fill: class extends yi {
                constructor(t1){
                    super(t1, xo);
                }
                recalculate(t1, e1) {
                    super.recalculate(t1, e1);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new mo(t1);
                }
                queryRadius() {
                    return os(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, a, s) {
                    return Ha(ls(t1, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, s), n);
                }
                isTileClipped() {
                    return !0;
                }
            },
            "fill-extrusion": class extends yi {
                constructor(t1){
                    super(t1, Oo);
                }
                createBucket(t1) {
                    return new Do(t1);
                }
                queryRadius() {
                    return os(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                    return !0;
                }
                queryIntersectsFeature(t1, e1, r, n, i, a, s, o) {
                    const l = ls(t1, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, s), u = this.paint.get("fill-extrusion-height").evaluate(e1, r), c = this.paint.get("fill-extrusion-base").evaluate(e1, r), h = function(t1, e1, r, n) {
                        const i = [];
                        for (const r of t1){
                            const t1 = [
                                r.x,
                                r.y,
                                0,
                                1
                            ];
                            bs(t1, t1, e1), i.push(new S(t1[0] / t1[3], t1[1] / t1[3]));
                        }
                        return i;
                    }(l, o), p = function(t1, e1, r, n) {
                        const i = [], a = [], s = n[8] * e1, o = n[9] * e1, l = n[10] * e1, u = n[11] * e1, c = n[8] * r, h = n[9] * r, p = n[10] * r, f = n[11] * r;
                        for (const e1 of t1){
                            const t1 = [], r = [];
                            for (const i of e1){
                                const e1 = i.x, a = i.y, d = n[0] * e1 + n[4] * a + n[12], y = n[1] * e1 + n[5] * a + n[13], m = n[2] * e1 + n[6] * a + n[14], g = n[3] * e1 + n[7] * a + n[15], x = m + l, v = g + u, b = d + c, w = y + h, _ = m + p, A = g + f, k = new S((d + s) / v, (y + o) / v);
                                k.z = x / v, t1.push(k);
                                const I = new S(b / A, w / A);
                                I.z = _ / A, r.push(I);
                            }
                            i.push(t1), a.push(r);
                        }
                        return [
                            i,
                            a
                        ];
                    }(n, c, u, o);
                    return function(t1, e1, r) {
                        let n = 1 / 0;
                        Ha(r, e1) && (n = qo(r, e1[0]));
                        for(let i = 0; i < e1.length; i++){
                            const a = e1[i], s = t1[i];
                            for(let t1 = 0; t1 < a.length - 1; t1++){
                                const e1 = a[t1], i = [
                                    e1,
                                    a[t1 + 1],
                                    s[t1 + 1],
                                    s[t1],
                                    e1
                                ];
                                Xa(r, i) && (n = Math.min(n, qo(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n;
                    }(p[0], p[1], h);
                }
            },
            line: class extends yi {
                constructor(t1){
                    super(t1, Wo), this.gradientVersion = 0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "line-gradient" === t1 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof ke, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                recalculate(t1, e1) {
                    super.recalculate(t1, e1), this.paint._values["line-floorwidth"] = Qo.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new Yo(t1);
                }
                queryRadius(t1) {
                    const e1 = t1, r = tl(ss("line-width", this, e1), ss("line-gap-width", this, e1)), n = ss("line-offset", this, e1);
                    return r / 2 + Math.abs(n) + os(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, a, s) {
                    const o = ls(t1, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, s), l = s / 2 * tl(this.paint.get("line-width").evaluate(e1, r), this.paint.get("line-gap-width").evaluate(e1, r)), u = this.paint.get("line-offset").evaluate(e1, r);
                    return u && (n = function(t1, e1) {
                        const r = [];
                        for(let n = 0; n < t1.length; n++){
                            const i = t1[n], a = [];
                            for(let t1 = 0; t1 < i.length; t1++){
                                const r = i[t1 - 1], n = i[t1], s = i[t1 + 1], o = 0 === t1 ? new S(0, 0) : n.sub(r)._unit()._perp(), l = t1 === i.length - 1 ? new S(0, 0) : s.sub(n)._unit()._perp(), u = o._add(l)._unit(), c = u.x * l.x + u.y * l.y;
                                0 !== c && u._mult(1 / c), a.push(u._mult(e1)._add(n));
                            }
                            r.push(a);
                        }
                        return r;
                    }(n, u * s)), function(t1, e1, r) {
                        for(let n = 0; n < e1.length; n++){
                            const i = e1[n];
                            if (t1.length >= 3) {
                                for(let e1 = 0; e1 < i.length; e1++)if (is(t1, i[e1])) return !0;
                            }
                            if (Wa(t1, i, r)) return !0;
                        }
                        return !1;
                    }(o, n, l);
                }
                isTileClipped() {
                    return !0;
                }
            },
            symbol: Uu,
            background: class extends yi {
                constructor(t1){
                    super(t1, ju);
                }
            },
            raster: class extends yi {
                constructor(t1){
                    super(t1, Nu);
                }
            }
        };
        class Gu {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                delete this._channel, this._callback = ()=>{};
            }
        }
        const Ju = 6371008.8;
        class Xu {
            constructor(t1, e1){
                if (isNaN(t1) || isNaN(e1)) throw new Error(`Invalid LngLat object: (${t1}, ${e1})`);
                if (this.lng = +t1, this.lat = +e1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new Xu(s(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e1 = Math.PI / 180, r = this.lat * e1, n = t1.lat * e1, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e1);
                return Ju * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e1 = 360 * t1 / 40075017, r = e1 / Math.cos(Math.PI / 180 * this.lat);
                return new Yu(new Xu(this.lng - r, this.lat - e1), new Xu(this.lng + r, this.lat + e1));
            }
            static convert(t1) {
                if (t1 instanceof Xu) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new Xu(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new Xu(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        class Yu {
            constructor(t1, e1){
                t1 && (e1 ? this.setSouthWest(t1).setNorthEast(e1) : 4 === t1.length ? this.setSouthWest([
                    t1[0],
                    t1[1]
                ]).setNorthEast([
                    t1[2],
                    t1[3]
                ]) : this.setSouthWest(t1[0]).setNorthEast(t1[1]));
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof Xu ? new Xu(t1.lng, t1.lat) : Xu.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof Xu ? new Xu(t1.lng, t1.lat) : Xu.convert(t1), this;
            }
            extend(t1) {
                const e1 = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof Xu) n = t1, i = t1;
                else {
                    if (!(t1 instanceof Yu)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(Yu.convert(t1)) : this.extend(Xu.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e1 || r ? (e1.lng = Math.min(n.lng, e1.lng), e1.lat = Math.min(n.lat, e1.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Xu(n.lng, n.lat), this._ne = new Xu(i.lng, i.lat)), this;
            }
            getCenter() {
                return new Xu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new Xu(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new Xu(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e1, lat: r } = Xu.convert(t1);
                let n = this._sw.lng <= e1 && e1 <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e1 && e1 >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                return t1 instanceof Yu ? t1 : t1 ? new Yu(t1) : t1;
            }
        }
        const Hu = 2 * Math.PI * Ju;
        function Wu(t1) {
            return Hu * Math.cos(t1 * Math.PI / 180);
        }
        function Qu(t1) {
            return (180 + t1) / 360;
        }
        function tc(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function ec(t1, e1) {
            return t1 / Wu(e1);
        }
        function rc(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        class nc {
            constructor(t1, e1, r = 0){
                this.x = +t1, this.y = +e1, this.z = +r;
            }
            static fromLngLat(t1, e1 = 0) {
                const r = Xu.convert(t1);
                return new nc(Qu(r.lng), tc(r.lat), ec(e1, r.lat));
            }
            toLngLat() {
                return new Xu(360 * this.x - 180, rc(this.y));
            }
            toAltitude() {
                return this.z * Wu(rc(this.y));
            }
            meterInMercatorCoordinateUnits() {
                var t1;
                return 1 / Hu * (t1 = rc(this.y), 1 / Math.cos(t1 * Math.PI / 180));
            }
        }
        function ic(t1, e1, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
            return [
                t1 * n - 2 * Math.PI * 6378137 / 2,
                e1 * n - 2 * Math.PI * 6378137 / 2
            ];
        }
        class ac {
            constructor(t1, e1, r){
                if (t1 < 0 || t1 > 25 || r < 0 || r >= Math.pow(2, t1) || e1 < 0 || e1 >= Math.pow(2, t1)) throw new Error(`x=${e1}, y=${r}, z=${t1} outside of bounds. 0<=x<${Math.pow(2, t1)}, 0<=y<${Math.pow(2, t1)} 0<=z<=25 `);
                this.z = t1, this.x = e1, this.y = r, this.key = lc(0, t1, t1, e1, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            url(t1, e1, r) {
                const n = (a = this.y, s = this.z, o = ic(256 * (i = this.x), 256 * (a = Math.pow(2, s) - a - 1), s), l = ic(256 * (i + 1), 256 * (a + 1), s), o[0] + "," + o[1] + "," + l[0] + "," + l[1]);
                var i, a, s, o, l;
                const u = function(t1, e1, r) {
                    let n, i = "";
                    for(let a = t1; a > 0; a--)n = 1 << a - 1, i += (e1 & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e1 > 1 ? "@2x" : "").replace(/{quadkey}/g, u).replace(/{bbox-epsg-3857}/g, n);
            }
            isChildOf(t1) {
                const e1 = this.z - t1.z;
                return e1 > 0 && t1.x === this.x >> e1 && t1.y === this.y >> e1;
            }
            getTilePoint(t1) {
                const e1 = Math.pow(2, this.z);
                return new S((t1.x * e1 - this.x) * qa, (t1.y * e1 - this.y) * qa);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class sc {
            constructor(t1, e1){
                this.wrap = t1, this.canonical = e1, this.key = lc(t1, e1.z, e1.z, e1.x, e1.y);
            }
        }
        class oc {
            constructor(t1, e1, r, n, i){
                if (t1 < r) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t1}; z = ${r}`);
                this.overscaledZ = t1, this.wrap = e1, this.canonical = new ac(r, +n, +i), this.key = lc(e1, t1, r, n, i);
            }
            clone() {
                return new oc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                if (t1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t1}; overscaledZ = ${this.overscaledZ}`);
                const e1 = this.canonical.z - t1;
                return t1 > this.canonical.z ? new oc(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new oc(t1, this.wrap, t1, this.canonical.x >> e1, this.canonical.y >> e1);
            }
            calculateScaledKey(t1, e1) {
                if (t1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t1}; overscaledZ = ${this.overscaledZ}`);
                const r = this.canonical.z - t1;
                return t1 > this.canonical.z ? lc(this.wrap * +e1, t1, this.canonical.z, this.canonical.x, this.canonical.y) : lc(this.wrap * +e1, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e1 = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.x === this.canonical.x >> e1 && t1.canonical.y === this.canonical.y >> e1;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new oc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e1 = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new oc(e1, this.wrap, e1, r, n),
                    new oc(e1, this.wrap, e1, r + 1, n),
                    new oc(e1, this.wrap, e1, r, n + 1),
                    new oc(e1, this.wrap, e1, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new oc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new oc(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new sc(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t1) {
                return this.canonical.getTilePoint(new nc(t1.x - this.wrap, t1.y));
            }
        }
        function lc(t1, e1, r, n, i) {
            (t1 *= 2) < 0 && (t1 = -1 * t1 - 1);
            const a = 1 << r;
            return (a * a * t1 + a * i + n).toString(36) + r.toString(36) + e1.toString(36);
        }
        Mn("CanonicalTileID", ac), Mn("OverscaledTileID", oc, {
            omit: [
                "posMatrix"
            ]
        });
        class uc {
            constructor(t1, e1, r){
                if (this.uid = t1, e1.height !== e1.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return void d(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e1.height;
                const n = this.dim = e1.height - 2;
                this.data = new Uint32Array(e1.data.buffer), this.encoding = r || "mapbox";
                for(let t1 = 0; t1 < n; t1++)this.data[this._idx(-1, t1)] = this.data[this._idx(0, t1)], this.data[this._idx(n, t1)] = this.data[this._idx(n - 1, t1)], this.data[this._idx(t1, -1)] = this.data[this._idx(t1, 0)], this.data[this._idx(t1, n)] = this.data[this._idx(t1, n - 1)];
                this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n, -1)] = this.data[this._idx(n - 1, 0)], this.data[this._idx(-1, n)] = this.data[this._idx(0, n - 1)], this.data[this._idx(n, n)] = this.data[this._idx(n - 1, n - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
                for(let t1 = 0; t1 < n; t1++)for(let e1 = 0; e1 < n; e1++){
                    const r = this.get(t1, e1);
                    r > this.max && (this.max = r), r < this.min && (this.min = r);
                }
            }
            get(t1, e1) {
                const r = new Uint8Array(this.data.buffer), n = 4 * this._idx(t1, e1);
                return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r[n], r[n + 1], r[n + 2]);
            }
            getUnpackVector() {
                return "terrarium" === this.encoding ? [
                    256,
                    1,
                    1 / 256,
                    32768
                ] : [
                    6553.6,
                    25.6,
                    .1,
                    1e4
                ];
            }
            _idx(t1, e1) {
                if (t1 < -1 || t1 >= this.dim + 1 || e1 < -1 || e1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e1 + 1) * this.stride + (t1 + 1);
            }
            _unpackMapbox(t1, e1, r) {
                return (256 * t1 * 256 + 256 * e1 + r) / 10 - 1e4;
            }
            _unpackTerrarium(t1, e1, r) {
                return 256 * t1 + e1 + r / 256 - 32768;
            }
            getPixels() {
                return new Bs({
                    width: this.stride,
                    height: this.stride
                }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t1, e1, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e1 * this.dim, i = e1 * this.dim + this.dim, a = r * this.dim, s = r * this.dim + this.dim;
                switch(e1){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        a = s - 1;
                        break;
                    case 1:
                        s = a + 1;
                }
                const o = -e1 * this.dim, l = -r * this.dim;
                for(let e1 = a; e1 < s; e1++)for(let r = n; r < i; r++)this.data[this._idx(r, e1)] = t1.data[this._idx(r + o, e1 + l)];
            }
        }
        Mn("DEMData", uc);
        class cc {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e1 = 0; e1 < t1.length; e1++){
                    const r = t1[e1];
                    this._stringToNumber[r] = e1, this._numberToString[e1] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                if (t1 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t1} can't be >= this._numberToString.length ${this._numberToString.length}`);
                return this._numberToString[t1];
            }
        }
        class hc {
            constructor(t1, e1, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, t1._z = e1, t1._x = r, t1._y = n, this.properties = t1.properties, this.id = i;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    geometry: this.geometry
                };
                for(const e1 in this)"_geometry" !== e1 && "_vectorTileFeature" !== e1 && (t1[e1] = this[e1]);
                return t1;
            }
        }
        class pc {
            constructor(t1, e1){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new Sn(qa, 16, 0), this.grid3D = new Sn(qa, 16, 0), this.featureIndexArray = new Wi, this.promoteId = e1;
            }
            insert(t1, e1, r, n, i, a) {
                const s = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i);
                const o = a ? this.grid3D : this.grid;
                for(let t1 = 0; t1 < e1.length; t1++){
                    const r = e1[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e1 = r[t1];
                        n[0] = Math.min(n[0], e1.x), n[1] = Math.min(n[1], e1.y), n[2] = Math.max(n[2], e1.x), n[3] = Math.max(n[3], e1.y);
                    }
                    n[0] < qa && n[1] < qa && n[2] >= 0 && n[3] >= 0 && o.insert(s, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                return this.vtLayers || (this.vtLayers = new _o.VectorTile(new ul(this.rawTileData)).layers, this.sourceLayerCoder = new cc(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                    "_geojsonTileLayer"
                ])), this.vtLayers;
            }
            query(t1, e1, r, n) {
                this.loadVTLayers();
                const i = t1.params || {}, a = qa / t1.tileSize / t1.scale, s = Jr(i.filter), o = t1.queryGeometry, l = t1.queryPadding * a, u = dc(o), c = this.grid.query(u.minX - l, u.minY - l, u.maxX + l, u.maxY + l), h = dc(t1.cameraQueryGeometry), p = this.grid3D.query(h.minX - l, h.minY - l, h.maxX + l, h.maxY + l, (e1, r, n, i)=>(function(t1, e1, r, n, i) {
                        for (const a of t1)if (e1 <= a.x && r <= a.y && n >= a.x && i >= a.y) return !0;
                        const a = [
                            new S(e1, r),
                            new S(e1, i),
                            new S(n, i),
                            new S(n, r)
                        ];
                        if (t1.length > 2) {
                            for (const e1 of a)if (is(t1, e1)) return !0;
                        }
                        for(let e1 = 0; e1 < t1.length - 1; e1++)if (as(t1[e1], t1[e1 + 1], a)) return !0;
                        return !1;
                    })(t1.cameraQueryGeometry, e1 - l, r - l, n + l, i + l));
                for (const t1 of p)c.push(t1);
                c.sort(yc);
                const f = {};
                let d;
                for(let l = 0; l < c.length; l++){
                    const u = c[l];
                    if (u === d) continue;
                    d = u;
                    const h = this.featureIndexArray.get(u);
                    let p = null;
                    this.loadMatchingFeature(f, h.bucketIndex, h.sourceLayerIndex, h.featureIndex, s, i.layers, i.availableImages, e1, r, n, (e1, r, n)=>(p || (p = Za(e1)), r.queryIntersectsFeature(o, e1, n, p, this.z, t1.transform, a, t1.pixelPosMatrix)));
                }
                return f;
            }
            loadMatchingFeature(t1, e1, r, n, i, a, s, l, u, c, h) {
                const p = this.bucketLayerIDs[e1];
                if (a && !function(t1, e1) {
                    for(let r = 0; r < t1.length; r++)if (e1.indexOf(t1[r]) >= 0) return !0;
                    return !1;
                }(a, p)) return;
                const f = this.sourceLayerCoder.decode(r), d = this.vtLayers[f].feature(n);
                if (i.needGeometry) {
                    const t1 = Ka(d, !0);
                    if (!i.filter(new Qn(this.tileID.overscaledZ), t1, this.tileID.canonical)) return;
                } else if (!i.filter(new Qn(this.tileID.overscaledZ), d)) return;
                const y = this.getId(d, f);
                for(let e1 = 0; e1 < p.length; e1++){
                    const r = p[e1];
                    if (a && a.indexOf(r) < 0) continue;
                    const i = l[r];
                    if (!i) continue;
                    let f = {};
                    y && c && (f = c.getState(i.sourceLayer || "_geojsonTileLayer", y));
                    const m = o({}, u[r]);
                    m.paint = fc(m.paint, i.paint, d, f, s), m.layout = fc(m.layout, i.layout, d, f, s);
                    const g = !h || h(d, i, f);
                    if (!g) continue;
                    const x = new hc(d, this.z, this.x, this.y, y);
                    x.layer = m;
                    let v = t1[r];
                    void 0 === v && (v = t1[r] = []), v.push({
                        featureIndex: n,
                        feature: x,
                        intersectionZ: g
                    });
                }
            }
            lookupSymbolFeatures(t1, e1, r, n, i, a, s, o) {
                const l = {};
                this.loadVTLayers();
                const u = Jr(i);
                for (const i of t1)this.loadMatchingFeature(l, r, n, i, u, a, s, o, e1);
                return l;
            }
            hasLayer(t1) {
                for (const e1 of this.bucketLayerIDs)for (const r of e1)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e1) {
                let r = t1.id;
                return this.promoteId && (r = t1.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e1]], "boolean" == typeof r && (r = Number(r))), r;
            }
        }
        function fc(t1, e1, r, n, i) {
            return c(t1, (t1, a)=>{
                const s = e1 instanceof oi ? e1.get(a) : null;
                return s && s.evaluate ? s.evaluate(r, n, i) : s;
            });
        }
        function dc(t1) {
            let e1 = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const a of t1)e1 = Math.min(e1, a.x), r = Math.min(r, a.y), n = Math.max(n, a.x), i = Math.max(i, a.y);
            return {
                minX: e1,
                minY: r,
                maxX: n,
                maxY: i
            };
        }
        function yc(t1, e1) {
            return e1 - t1;
        }
        var mc;
        Mn("FeatureIndex", pc, {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        }), t1.PerformanceMarkers = void 0, (mc = t1.PerformanceMarkers || (t1.PerformanceMarkers = {})).create = "create", mc.load = "load", mc.fullLoad = "fullLoad";
        let gc = null, xc = [];
        const vc = 1e3 / 30, bc = {
            mark (t1) {
                performance.mark(t1);
            },
            frame (t1) {
                const e1 = t1;
                null != gc && xc.push(e1 - gc), gc = e1;
            },
            clearMetrics () {
                gc = null, xc = [], performance.clearMeasures("loadTime"), performance.clearMeasures("fullLoadTime");
                for(const e1 in t1.PerformanceMarkers)performance.clearMarks(t1.PerformanceMarkers[e1]);
            },
            getPerformanceMetrics () {
                performance.measure("loadTime", t1.PerformanceMarkers.create, t1.PerformanceMarkers.load), performance.measure("fullLoadTime", t1.PerformanceMarkers.create, t1.PerformanceMarkers.fullLoad);
                const e1 = performance.getEntriesByName("loadTime")[0].duration, r = performance.getEntriesByName("fullLoadTime")[0].duration, n = xc.length, i = 1 / (xc.reduce((t1, e1)=>t1 + e1, 0) / n / 1e3), a = xc.filter((t1)=>t1 > vc).reduce((t1, e1)=>t1 + (e1 - vc) / vc, 0);
                return {
                    loadTime: e1,
                    fullLoadTime: r,
                    fps: i,
                    percentDroppedFrames: a / (n + a) * 100
                };
            }
        };
        t1.AJAXError = q, t1.ARRAY_TYPE = ps, t1.Actor = class {
            constructor(t1, e1, r){
                this.target = t1, this.parent = e1, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, u([
                    "receive",
                    "process"
                ], this), this.invoker = new Gu(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = g() ? t1 : window;
            }
            send(t1, e1, r, n, i = !1) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (this.callbacks[a] = r);
                const s = _(this.globalScope) ? void 0 : [];
                return this.target.postMessage({
                    id: a,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Bn(e1, s)
                }, s), {
                    cancel: ()=>{
                        r && delete this.callbacks[a], this.target.postMessage({
                            id: a,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e1 = t1.data, r = e1.id;
                if (r && (!e1.targetMapId || this.mapId === e1.targetMapId)) {
                    if ("<cancel>" === e1.type) {
                        delete this.tasks[r];
                        const t1 = this.cancelCallbacks[r];
                        delete this.cancelCallbacks[r], t1 && t1();
                    } else g() || e1.mustQueue ? (this.tasks[r] = e1, this.taskQueue.push(r), this.invoker.trigger()) : this.processTask(r, e1);
                }
            }
            process() {
                if (!this.taskQueue.length) return;
                const t1 = this.taskQueue.shift(), e1 = this.tasks[t1];
                delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), e1 && this.processTask(t1, e1);
            }
            processTask(t1, e1) {
                if ("<response>" === e1.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e1.error ? r(Cn(e1.error)) : r(null, Cn(e1.data)));
                } else {
                    let r = !1;
                    const n = _(this.globalScope) ? void 0 : [], i = e1.hasCallback ? (e1, i)=>{
                        r = !0, delete this.cancelCallbacks[t1], this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e1 ? Bn(e1) : null,
                            data: Bn(i, n)
                        }, n);
                    } : (t1)=>{
                        r = !0;
                    };
                    let a = null;
                    const s = Cn(e1.data);
                    if (this.parent[e1.type]) a = this.parent[e1.type](e1.sourceMapId, s, i);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e1.type.split(".");
                        a = this.parent.getWorkerSource(e1.sourceMapId, t1[0], s.source)[t1[1]](s, i);
                    } else i(new Error(`Could not find function ${e1.type}`));
                    !r && a && a.cancel && (this.cancelCallbacks[t1] = a.cancel);
                }
            }
            remove() {
                this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }, t1.AlphaImage = zs, t1.CanonicalTileID = ac, t1.CollisionBoxArray = Ni, t1.CollisionCircleLayoutArray = class extends Vi {
        }, t1.Color = Ft, t1.DEMData = uc, t1.DataConstantProperty = li, t1.DictionaryCoder = cc, t1.EXTENT = qa, t1.ErrorEvent = et, t1.EvaluationParameters = Qn, t1.Event = tt, t1.Evented = rt, t1.FeatureIndex = pc, t1.FillBucket = mo, t1.FillExtrusionBucket = Do, t1.GeoJSONFeature = hc, t1.ImageAtlas = Dl, t1.ImagePosition = Ll, t1.LineBucket = Yo, t1.LineStripIndexArray = class extends Ui {
        }, t1.LngLat = Xu, t1.LngLatBounds = Yu, t1.MercatorCoordinate = nc, t1.ONE_EM = ll, t1.OverscaledTileID = oc, t1.PerformanceUtils = bc, t1.PosArray = Qi, t1.Properties = fi, t1.QuadTriangleArray = class extends Fi {
        }, t1.RGBAImage = Bs, t1.RasterBoundsArray = class extends _i {
        }, t1.RequestPerformance = class {
            constructor(t1){
                this._marks = {
                    start: [
                        t1.url,
                        "start"
                    ].join("#"),
                    end: [
                        t1.url,
                        "end"
                    ].join("#"),
                    measure: t1.url.toString()
                }, performance.mark(this._marks.start);
            }
            finish() {
                performance.mark(this._marks.end);
                let t1 = performance.getEntriesByName(this._marks.measure);
                return 0 === t1.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t1 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t1;
            }
        }, t1.ResourceType = U, t1.SegmentVector = ya, t1.SymbolBucket = Du, t1.Transitionable = ri, t1.TriangleIndexArray = ha, t1.Uniform1f = za, t1.Uniform1i = class extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = 0;
            }
            set(t1) {
                this.current !== t1 && (this.current = t1, this.gl.uniform1i(this.location, t1));
            }
        }, t1.Uniform2f = class extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = [
                    0,
                    0
                ];
            }
            set(t1) {
                t1[0] === this.current[0] && t1[1] === this.current[1] || (this.current = t1, this.gl.uniform2f(this.location, t1[0], t1[1]));
            }
        }, t1.Uniform3f = class extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1) {
                t1[0] === this.current[0] && t1[1] === this.current[1] && t1[2] === this.current[2] || (this.current = t1, this.gl.uniform3f(this.location, t1[0], t1[1], t1[2]));
            }
        }, t1.Uniform4f = Ba, t1.UniformColor = Ca, t1.UniformMatrix4f = class extends Ma {
            constructor(t1, e1){
                super(t1, e1), this.current = Pa;
            }
            set(t1) {
                if (t1[12] !== this.current[12] || t1[0] !== this.current[0]) return this.current = t1, void this.gl.uniformMatrix4fv(this.location, !1, t1);
                for(let e1 = 1; e1 < 16; e1++)if (t1[e1] !== this.current[e1]) {
                    this.current = t1, this.gl.uniformMatrix4fv(this.location, !1, t1);
                    break;
                }
            }
        }, t1.UnwrappedTileID = sc, t1.ValidationError = it, t1.ZoomHistory = Pn, t1.add = function(t1, e1, r) {
            return t1[0] = e1[0] + r[0], t1[1] = e1[1] + r[1], t1[2] = e1[2] + r[2], t1;
        }, t1.addDynamicAttributes = Eu, t1.asyncAll = function(t1, e1, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let a = null;
            t1.forEach((t1, s)=>{
                e1(t1, (t1, e1)=>{
                    t1 && (a = t1), i[s] = e1, 0 == --n && r(a, i);
                });
            });
        }, t1.bezier = n, t1.bindAll = u, t1.cacheEntryPossiblyAdded = function(t1) {
            F++, F > V && (t1.getActor().send("enforceCacheSizeLimit", P), F = 0);
        }, t1.clamp = a, t1.clearTileCache = function(t1) {
            const e1 = caches.delete(z);
            t1 && e1.catch(t1).then(()=>t1());
        }, t1.clipLine = cu, t1.clone = function(t1) {
            var e1 = new ps(16);
            return e1[0] = t1[0], e1[1] = t1[1], e1[2] = t1[2], e1[3] = t1[3], e1[4] = t1[4], e1[5] = t1[5], e1[6] = t1[6], e1[7] = t1[7], e1[8] = t1[8], e1[9] = t1[9], e1[10] = t1[10], e1[11] = t1[11], e1[12] = t1[12], e1[13] = t1[13], e1[14] = t1[14], e1[15] = t1[15], e1;
        }, t1.clone$1 = p, t1.clone$2 = function(t1) {
            var e1 = new ps(3);
            return e1[0] = t1[0], e1[1] = t1[1], e1[2] = t1[2], e1;
        }, t1.collisionCircleLayout = al, t1.config = M, t1.copy = function(t1, e1) {
            return t1[0] = e1[0], t1[1] = e1[1], t1[2] = e1[2], t1[3] = e1[3], t1[4] = e1[4], t1[5] = e1[5], t1[6] = e1[6], t1[7] = e1[7], t1[8] = e1[8], t1[9] = e1[9], t1[10] = e1[10], t1[11] = e1[11], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15], t1;
        }, t1.create = function() {
            var t1 = new ps(16);
            return ps != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
        }, t1.create$1 = fs, t1.createExpression = Fr, t1.createFilter = Jr, t1.createLayout = vi, t1.createStyleLayer = function(t1) {
            return "custom" === t1.type ? new Zu(t1) : new Ku[t1.type](t1);
        }, t1.cross = function(t1, e1, r) {
            var n = e1[0], i = e1[1], a = e1[2], s = r[0], o = r[1], l = r[2];
            return t1[0] = i * l - a * o, t1[1] = a * s - n * l, t1[2] = n * o - i * s, t1;
        }, t1.dot = function(t1, e1) {
            return t1[0] * e1[0] + t1[1] * e1[1] + t1[2] * e1[2];
        }, t1.dot$1 = function(t1, e1) {
            return t1[0] * e1[0] + t1[1] * e1[1] + t1[2] * e1[2] + t1[3] * e1[3];
        }, t1.ease = i, t1.emitValidationErrors = kn, t1.enforceCacheSizeLimit = function(t1) {
            E(), B && B.then((e1)=>{
                e1.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e1.delete(r[n]);
                });
            });
        }, t1.equals = function(t1, e1) {
            var r = t1[0], n = t1[1], i = t1[2], a = t1[3], s = t1[4], o = t1[5], l = t1[6], u = t1[7], c = t1[8], h = t1[9], p = t1[10], f = t1[11], d = t1[12], y = t1[13], m = t1[14], g = t1[15], x = e1[0], v = e1[1], b = e1[2], w = e1[3], _ = e1[4], A = e1[5], k = e1[6], S = e1[7], I = e1[8], M = e1[9], z = e1[10], B = e1[11], C = e1[12], P = e1[13], V = e1[14], E = e1[15];
            return Math.abs(r - x) <= hs * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(n - v) <= hs * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(i - b) <= hs * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(a - w) <= hs * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(s - _) <= hs * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(o - A) <= hs * Math.max(1, Math.abs(o), Math.abs(A)) && Math.abs(l - k) <= hs * Math.max(1, Math.abs(l), Math.abs(k)) && Math.abs(u - S) <= hs * Math.max(1, Math.abs(u), Math.abs(S)) && Math.abs(c - I) <= hs * Math.max(1, Math.abs(c), Math.abs(I)) && Math.abs(h - M) <= hs * Math.max(1, Math.abs(h), Math.abs(M)) && Math.abs(p - z) <= hs * Math.max(1, Math.abs(p), Math.abs(z)) && Math.abs(f - B) <= hs * Math.max(1, Math.abs(f), Math.abs(B)) && Math.abs(d - C) <= hs * Math.max(1, Math.abs(d), Math.abs(C)) && Math.abs(y - P) <= hs * Math.max(1, Math.abs(y), Math.abs(P)) && Math.abs(m - V) <= hs * Math.max(1, Math.abs(m), Math.abs(V)) && Math.abs(g - E) <= hs * Math.max(1, Math.abs(g), Math.abs(E));
        }, t1.evaluateSizeForFeature = function(t1, { uSize: e1, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t1.kind ? n / tu : "composite" === t1.kind ? Se(n / tu, i / tu, r) : e1;
        }, t1.evaluateSizeForZoom = function(t1, e1) {
            let r = 0, n = 0;
            if ("constant" === t1.kind) n = t1.layoutSize;
            else if ("source" !== t1.kind) {
                const { interpolationType: i, minZoom: s, maxZoom: o } = t1, l = i ? a(Ne.interpolationFactor(i, e1, s, o), 0, 1) : 0;
                "camera" === t1.kind ? n = Se(t1.minSize, t1.maxSize, l) : r = l;
            }
            return {
                uSizeT: r,
                uSize: n
            };
        }, t1.evaluateVariableOffset = Au, t1.evented = Xn, t1.exported = k, t1.exported$1 = T, t1.extend = o, t1.filterObject = h, t1.fromRotation = function(t1, e1) {
            var r = Math.sin(e1), n = Math.cos(e1);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, t1.fromScaling = function(t1, e1) {
            return t1[0] = e1[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e1[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e1[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, t1.getAnchorAlignment = Yl, t1.getAnchorJustification = ku, t1.getArrayBuffer = K, t1.getImage = H, t1.getJSON = function(t1, e1) {
            return Z(o(t1, {
                type: "json"
            }), e1);
        }, t1.getOverlapMode = qu, t1.getRTLTextPluginStatus = Yn, t1.getReferrer = j, t1.getVideo = function(t1, e1) {
            const r = window.document.createElement("video");
            r.muted = !0, r.onloadstart = function() {
                e1(null, r);
            };
            for(let e1 = 0; e1 < t1.length; e1++){
                const n = window.document.createElement("source");
                G(t1[e1]) || (r.crossOrigin = "Anonymous"), n.src = t1[e1], r.appendChild(n);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.identity = ds, t1.invert = function(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], a = e1[3], s = e1[4], o = e1[5], l = e1[6], u = e1[7], c = e1[8], h = e1[9], p = e1[10], f = e1[11], d = e1[12], y = e1[13], m = e1[14], g = e1[15], x = r * o - n * s, v = r * l - i * s, b = r * u - a * s, w = n * l - i * o, _ = n * u - a * o, A = i * u - a * l, k = c * y - h * d, S = c * m - p * d, I = c * g - f * d, M = h * m - p * y, z = h * g - f * y, B = p * g - f * m, C = x * B - v * z + b * M + w * I - _ * S + A * k;
            return C ? (t1[0] = (o * B - l * z + u * M) * (C = 1 / C), t1[1] = (i * z - n * B - a * M) * C, t1[2] = (y * A - m * _ + g * w) * C, t1[3] = (p * _ - h * A - f * w) * C, t1[4] = (l * I - s * B - u * S) * C, t1[5] = (r * B - i * I + a * S) * C, t1[6] = (m * b - d * A - g * v) * C, t1[7] = (c * A - p * b + f * v) * C, t1[8] = (s * z - o * I + u * k) * C, t1[9] = (n * I - r * z - a * k) * C, t1[10] = (d * _ - y * b + g * x) * C, t1[11] = (h * b - c * _ - f * x) * C, t1[12] = (o * S - s * M - l * k) * C, t1[13] = (r * M - n * S + i * k) * C, t1[14] = (y * v - d * w - m * x) * C, t1[15] = (c * w - h * v + p * x) * C, t1) : null;
        }, t1.isImageBitmap = A, t1.isSafari = _, t1.isWorker = g, t1.keysDifference = function(t1, e1) {
            const r = [];
            for(const n in t1)n in e1 || r.push(n);
            return r;
        }, t1.lazyLoadRTLTextPlugin = function() {
            Wn.isLoading() || Wn.isLoaded() || "deferred" !== Yn() || Hn();
        }, t1.makeRequest = Z, t1.mapObject = c, t1.mercatorXfromLng = Qu, t1.mercatorYfromLat = tc, t1.mercatorZfromAltitude = ec, t1.mul = gs, t1.mul$1 = function(t1, e1, r) {
            return t1[0] = e1[0] * r[0], t1[1] = e1[1] * r[1], t1[2] = e1[2] * r[2], t1[3] = e1[3] * r[3], t1;
        }, t1.multiply = ys, t1.nextPowerOfTwo = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }, t1.normalize = function(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], a = r * r + n * n + i * i;
            return a > 0 && (a = 1 / Math.sqrt(a)), t1[0] = e1[0] * a, t1[1] = e1[1] * a, t1[2] = e1[2] * a, t1;
        }, t1.number = Se, t1.ortho = function(t1, e1, r, n, i, a, s) {
            var o = 1 / (e1 - r), l = 1 / (n - i), u = 1 / (a - s);
            return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e1 + r) * o, t1[13] = (i + n) * l, t1[14] = (s + a) * u, t1[15] = 1, t1;
        }, t1.parseCacheControl = x, t1.parseGlyphPbf = function(t1) {
            return new ul(t1).readFields(Vl, []);
        }, t1.pbf = ul, t1.performSymbolLayout = function(e1) {
            e1.bucket.createArrays(), e1.bucket.tilePixelRatio = qa / (512 * e1.bucket.overscaling), e1.bucket.compareText = {}, e1.bucket.iconsNeedLinear = !1;
            const r = e1.bucket.layers[0].layout, n = e1.bucket.layers[0]._unevaluatedLayout._values, i = {
                layoutIconSize: n["icon-size"].possiblyEvaluate(new Qn(e1.bucket.zoom + 1), e1.canonical),
                layoutTextSize: n["text-size"].possiblyEvaluate(new Qn(e1.bucket.zoom + 1), e1.canonical),
                textMaxSize: n["text-size"].possiblyEvaluate(new Qn(18))
            };
            if ("composite" === e1.bucket.textSizeData.kind) {
                const { minZoom: t1, maxZoom: r } = e1.bucket.textSizeData;
                i.compositeTextSizes = [
                    n["text-size"].possiblyEvaluate(new Qn(t1), e1.canonical),
                    n["text-size"].possiblyEvaluate(new Qn(r), e1.canonical)
                ];
            }
            if ("composite" === e1.bucket.iconSizeData.kind) {
                const { minZoom: t1, maxZoom: r } = e1.bucket.iconSizeData;
                i.compositeIconSizes = [
                    n["icon-size"].possiblyEvaluate(new Qn(t1), e1.canonical),
                    n["icon-size"].possiblyEvaluate(new Qn(r), e1.canonical)
                ];
            }
            const a = r.get("text-line-height") * ll, s = "viewport" !== r.get("text-rotation-alignment") && "point" !== r.get("symbol-placement"), o = r.get("text-keep-upright"), l = r.get("text-size");
            for (const n of e1.bucket.features){
                const u = r.get("text-font").evaluate(n, {}, e1.canonical).join(","), c = l.evaluate(n, {}, e1.canonical), h = i.layoutTextSize.evaluate(n, {}, e1.canonical), p = i.layoutIconSize.evaluate(n, {}, e1.canonical), f = {
                    horizontal: {},
                    vertical: void 0
                }, y = n.text;
                let m, g = [
                    0,
                    0
                ];
                if (y) {
                    const i = y.toString(), l = r.get("text-letter-spacing").evaluate(n, {}, e1.canonical) * ll, p = Fn(i) ? l : 0, d = r.get("text-anchor").evaluate(n, {}, e1.canonical), m = r.get("text-variable-anchor");
                    if (!m) {
                        const t1 = r.get("text-radial-offset").evaluate(n, {}, e1.canonical);
                        g = t1 ? Au(d, [
                            t1 * ll,
                            _u
                        ]) : r.get("text-offset").evaluate(n, {}, e1.canonical).map((t1)=>t1 * ll);
                    }
                    let x = s ? "center" : r.get("text-justify").evaluate(n, {}, e1.canonical);
                    const v = r.get("symbol-placement"), b = "point" === v ? r.get("text-max-width").evaluate(n, {}, e1.canonical) * ll : 0, w = ()=>{
                        e1.bucket.allowVerticalPlacement && En(i) && (f.vertical = Ul(y, e1.glyphMap, e1.glyphPositions, e1.imagePositions, u, b, a, d, "left", p, g, t1.WritingMode.vertical, !0, v, h, c));
                    };
                    if (!s && m) {
                        const r = "auto" === x ? m.map((t1)=>ku(t1)) : [
                            x
                        ];
                        let n = !1;
                        for(let i = 0; i < r.length; i++){
                            const s = r[i];
                            if (!f.horizontal[s]) {
                                if (n) f.horizontal[s] = f.horizontal[0];
                                else {
                                    const r = Ul(y, e1.glyphMap, e1.glyphPositions, e1.imagePositions, u, b, a, "center", s, p, g, t1.WritingMode.horizontal, !1, v, h, c);
                                    r && (f.horizontal[s] = r, n = 1 === r.positionedLines.length);
                                }
                            }
                        }
                        w();
                    } else {
                        "auto" === x && (x = ku(d));
                        const r = Ul(y, e1.glyphMap, e1.glyphPositions, e1.imagePositions, u, b, a, d, x, p, g, t1.WritingMode.horizontal, !1, v, h, c);
                        r && (f.horizontal[x] = r), w(), En(i) && s && o && (f.vertical = Ul(y, e1.glyphMap, e1.glyphPositions, e1.imagePositions, u, b, a, d, x, p, g, t1.WritingMode.vertical, !1, v, h, c));
                    }
                }
                let x = !1;
                if (n.icon && n.icon.name) {
                    const t1 = e1.imageMap[n.icon.name];
                    t1 && (m = Wl(e1.imagePositions[n.icon.name], r.get("icon-offset").evaluate(n, {}, e1.canonical), r.get("icon-anchor").evaluate(n, {}, e1.canonical)), x = !!t1.sdf, void 0 === e1.bucket.sdfIcons ? e1.bucket.sdfIcons = x : e1.bucket.sdfIcons !== x && d("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t1.pixelRatio !== e1.bucket.pixelRatio || 0 !== r.get("icon-rotate").constantOr(1)) && (e1.bucket.iconsNeedLinear = !0));
                }
                const v = zu(f.horizontal) || f.vertical;
                e1.bucket.iconsInText = !!v && v.iconsInText, (v || m) && Su(e1.bucket, n, f, m, e1.imageMap, i, h, p, g, x, e1.canonical);
            }
            e1.showCollisionBoxes && e1.bucket.generateCollisionDebugBuffers();
        }, t1.perspective = function(t1, e1, r, n, i) {
            var a, s = 1 / Math.tan(e1 / 2);
            return t1[0] = s / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = s, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = (i + n) * (a = 1 / (n - i)), t1[14] = 2 * i * n * a) : (t1[10] = -1, t1[14] = -2 * n), t1;
        }, t1.pick = function(t1, e1) {
            const r = {};
            for(let n = 0; n < e1.length; n++){
                const i = e1[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.plugin = Wn, t1.pointGeometry = S, t1.polygonIntersectsPolygon = Xa, t1.potpack = Tl, t1.refProperties = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.register = Mn, t1.registerForPluginStateChange = function(t1) {
            return t1({
                pluginStatus: Zn,
                pluginURL: Kn
            }), Xn.on("pluginStateChange", t1), t1;
        }, t1.renderColorRamp = Cs, t1.rotateX = function(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), a = e1[4], s = e1[5], o = e1[6], l = e1[7], u = e1[8], c = e1[9], h = e1[10], p = e1[11];
            return e1 !== t1 && (t1[0] = e1[0], t1[1] = e1[1], t1[2] = e1[2], t1[3] = e1[3], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[4] = a * i + u * n, t1[5] = s * i + c * n, t1[6] = o * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - a * n, t1[9] = c * i - s * n, t1[10] = h * i - o * n, t1[11] = p * i - l * n, t1;
        }, t1.rotateZ = function(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), a = e1[0], s = e1[1], o = e1[2], l = e1[3], u = e1[4], c = e1[5], h = e1[6], p = e1[7];
            return e1 !== t1 && (t1[8] = e1[8], t1[9] = e1[9], t1[10] = e1[10], t1[11] = e1[11], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[0] = a * i + u * n, t1[1] = s * i + c * n, t1[2] = o * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - a * n, t1[5] = c * i - s * n, t1[6] = h * i - o * n, t1[7] = p * i - l * n, t1;
        }, t1.scale = function(t1, e1, r) {
            var n = r[0], i = r[1], a = r[2];
            return t1[0] = e1[0] * n, t1[1] = e1[1] * n, t1[2] = e1[2] * n, t1[3] = e1[3] * n, t1[4] = e1[4] * i, t1[5] = e1[5] * i, t1[6] = e1[6] * i, t1[7] = e1[7] * i, t1[8] = e1[8] * a, t1[9] = e1[9] * a, t1[10] = e1[10] * a, t1[11] = e1[11] * a, t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15], t1;
        }, t1.scale$1 = function(t1, e1, r) {
            return t1[0] = e1[0] * r, t1[1] = e1[1] * r, t1[2] = e1[2] * r, t1;
        }, t1.setCacheLimits = function(t1, e1) {
            P = t1, V = e1;
        }, t1.setRTLTextPlugin = function(t1, e1, r = !1) {
            if (Zn === Un || Zn === qn || Zn === jn) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Kn = k.resolveURL(t1), Zn = Un, Nn = e1, Jn(), r || Hn();
        }, t1.spec = nt, t1.sphericalToCartesian = function([t1, e1, r]) {
            return e1 += 90, e1 *= Math.PI / 180, r *= Math.PI / 180, {
                x: t1 * Math.cos(e1) * Math.sin(r),
                y: t1 * Math.sin(e1) * Math.sin(r),
                z: t1 * Math.cos(r)
            };
        }, t1.sqrLen = function(t1) {
            var e1 = t1[0], r = t1[1];
            return e1 * e1 + r * r;
        }, t1.sub = function(t1, e1, r) {
            return t1[0] = e1[0] - r[0], t1[1] = e1[1] - r[1], t1[2] = e1[2] - r[2], t1;
        }, t1.toEvaluationFeature = Ka, t1.transformMat3 = function(t1, e1, r) {
            var n = e1[0], i = e1[1], a = e1[2];
            return t1[0] = n * r[0] + i * r[3] + a * r[6], t1[1] = n * r[1] + i * r[4] + a * r[7], t1[2] = n * r[2] + i * r[5] + a * r[8], t1;
        }, t1.transformMat4 = bs, t1.transformMat4$1 = function(t1, e1, r) {
            var n = e1[0], i = e1[1];
            return t1[0] = r[0] * n + r[4] * i + r[12], t1[1] = r[1] * n + r[5] * i + r[13], t1;
        }, t1.translate = function(t1, e1, r) {
            var n, i, a, s, o, l, u, c, h, p, f, d, y = r[0], m = r[1], g = r[2];
            return e1 === t1 ? (t1[12] = e1[0] * y + e1[4] * m + e1[8] * g + e1[12], t1[13] = e1[1] * y + e1[5] * m + e1[9] * g + e1[13], t1[14] = e1[2] * y + e1[6] * m + e1[10] * g + e1[14], t1[15] = e1[3] * y + e1[7] * m + e1[11] * g + e1[15]) : (i = e1[1], a = e1[2], s = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = e1[9], f = e1[10], d = e1[11], t1[0] = n = e1[0], t1[1] = i, t1[2] = a, t1[3] = s, t1[4] = o, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = f, t1[11] = d, t1[12] = n * y + o * m + h * g + e1[12], t1[13] = i * y + l * m + p * g + e1[13], t1[14] = a * y + u * m + f * g + e1[14], t1[15] = s * y + c * m + d * g + e1[15]), t1;
        }, t1.triggerPluginCompletionEvent = Gn, t1.unicodeBlockLookup = Vn, t1.uniqueId = function() {
            return l++;
        }, t1.validateCustomStyleLayer = function(t1) {
            const e1 = [], r = t1.id;
            return void 0 === r && e1.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e1.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e1.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e1;
        }, t1.validateLight = wn, t1.validateStyle = bn, t1.vectorTile = _o, t1.warnOnce = d, t1.wrap = s;
    });
    define([
        "./shared"
    ], function(e1) {
        "use strict";
        function t1(e1) {
            const o = typeof e1;
            if ("number" === o || "boolean" === o || "string" === o || null == e1) return JSON.stringify(e1);
            if (Array.isArray(e1)) {
                let o = "[";
                for (const i of e1)o += `${t1(i)},`;
                return `${o}]`;
            }
            const i = Object.keys(e1).sort();
            let r = "{";
            for(let o = 0; o < i.length; o++)r += `${JSON.stringify(i[o])}:${t1(e1[i[o]])},`;
            return `${r}}`;
        }
        function o(o) {
            let i = "";
            for (const r of e1.refProperties)i += `/${t1(o[r])}`;
            return i;
        }
        class i {
            constructor(e1){
                this.keyCache = {}, e1 && this.replace(e1);
            }
            replace(e1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e1, []);
            }
            update(t1, i) {
                for (const o of t1){
                    this._layerConfigs[o.id] = o;
                    const t1 = this._layers[o.id] = e1.createStyleLayer(o);
                    t1._featureFilter = e1.createFilter(t1.filter), this.keyCache[o.id] && delete this.keyCache[o.id];
                }
                for (const e1 of i)delete this.keyCache[e1], delete this._layerConfigs[e1], delete this._layers[e1];
                this.familiesBySource = {};
                const r = function(e1, t1) {
                    const i = {};
                    for(let r = 0; r < e1.length; r++){
                        const n = t1 && t1[e1[r].id] || o(e1[r]);
                        t1 && (t1[e1[r].id] = n);
                        let s = i[n];
                        s || (s = i[n] = []), s.push(e1[r]);
                    }
                    const r = [];
                    for(const e1 in i)r.push(i[e1]);
                    return r;
                }(Object.values(this._layerConfigs), this.keyCache);
                for (const e1 of r){
                    const t1 = e1.map((e1)=>this._layers[e1.id]), o = t1[0];
                    if ("none" === o.visibility) continue;
                    const i = o.source || "";
                    let r = this.familiesBySource[i];
                    r || (r = this.familiesBySource[i] = {});
                    const n = o.sourceLayer || "_geojsonTileLayer";
                    let s = r[n];
                    s || (s = r[n] = []), s.push(t1);
                }
            }
        }
        class r {
            constructor(t1){
                const o = {}, i = [];
                for(const e1 in t1){
                    const r = t1[e1], n = o[e1] = {};
                    for(const e1 in r){
                        const t1 = r[+e1];
                        if (!t1 || 0 === t1.bitmap.width || 0 === t1.bitmap.height) continue;
                        const o = {
                            x: 0,
                            y: 0,
                            w: t1.bitmap.width + 2,
                            h: t1.bitmap.height + 2
                        };
                        i.push(o), n[e1] = {
                            rect: o,
                            metrics: t1.metrics
                        };
                    }
                }
                const { w: r, h: n } = e1.potpack(i), s = new e1.AlphaImage({
                    width: r || 1,
                    height: n || 1
                });
                for(const i in t1){
                    const r = t1[i];
                    for(const t1 in r){
                        const n = r[+t1];
                        if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height) continue;
                        const a = o[i][t1].rect;
                        e1.AlphaImage.copy(n.bitmap, s, {
                            x: 0,
                            y: 0
                        }, {
                            x: a.x + 1,
                            y: a.y + 1
                        }, n.bitmap);
                    }
                }
                this.image = s, this.positions = o;
            }
        }
        e1.register("GlyphAtlas", r);
        class n {
            constructor(t1){
                this.tileID = new e1.OverscaledTileID(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.uid = t1.uid, this.zoom = t1.zoom, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.collectResourceTiming, this.returnDependencies = !!t1.returnDependencies, this.promoteId = t1.promoteId;
            }
            parse(t1, o, i, n, a) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new e1.CollisionBoxArray;
                const l = new e1.DictionaryCoder(Object.keys(t1.layers).sort()), c = new e1.FeatureIndex(this.tileID, this.promoteId);
                c.bucketLayerIDs = [];
                const u = {}, h = {
                    featureIndex: c,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    availableImages: i
                }, p = o.familiesBySource[this.source];
                for(const o in p){
                    const r = t1.layers[o];
                    if (!r) continue;
                    1 === r.version && e1.warnOnce(`Vector tile source "${this.source}" layer "${o}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const n = l.encode(o), a = [];
                    for(let e1 = 0; e1 < r.length; e1++){
                        const t1 = r.feature(e1), i = c.getId(t1, o);
                        a.push({
                            feature: t1,
                            id: i,
                            index: e1,
                            sourceLayerIndex: n
                        });
                    }
                    for (const t1 of p[o]){
                        const o = t1[0];
                        o.source !== this.source && e1.warnOnce(`layer.source = ${o.source} does not equal this.source = ${this.source}`), o.minzoom && this.zoom < Math.floor(o.minzoom) || o.maxzoom && this.zoom >= o.maxzoom || "none" !== o.visibility && (s(t1, this.zoom, i), (u[o.id] = o.createBucket({
                            index: c.bucketLayerIDs.length,
                            layers: t1,
                            zoom: this.zoom,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: n,
                            sourceID: this.source
                        })).populate(a, h, this.tileID.canonical), c.bucketLayerIDs.push(t1.map((e1)=>e1.id)));
                    }
                }
                let f, d, g, m;
                const y = e1.mapObject(h.glyphDependencies, (e1)=>Object.keys(e1).map(Number));
                Object.keys(y).length ? n.send("getGlyphs", {
                    uid: this.uid,
                    stacks: y
                }, (e1, t1)=>{
                    f || (f = e1, d = t1, w.call(this));
                }) : d = {};
                const v = Object.keys(h.iconDependencies);
                v.length ? n.send("getImages", {
                    icons: v,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                }, (e1, t1)=>{
                    f || (f = e1, g = t1, w.call(this));
                }) : g = {};
                const x = Object.keys(h.patternDependencies);
                function w() {
                    if (f) return a(f);
                    if (d && g && m) {
                        const t1 = new r(d), o = new e1.ImageAtlas(g, m);
                        for(const r in u){
                            const n = u[r];
                            n instanceof e1.SymbolBucket ? (s(n.layers, this.zoom, i), e1.performSymbolLayout({
                                bucket: n,
                                glyphMap: d,
                                glyphPositions: t1.positions,
                                imageMap: g,
                                imagePositions: o.iconPositions,
                                showCollisionBoxes: this.showCollisionBoxes,
                                canonical: this.tileID.canonical
                            })) : n.hasPattern && (n instanceof e1.LineBucket || n instanceof e1.FillBucket || n instanceof e1.FillExtrusionBucket) && (s(n.layers, this.zoom, i), n.addFeatures(h, this.tileID.canonical, o.patternPositions));
                        }
                        this.status = "done", a(null, {
                            buckets: Object.values(u).filter((e1)=>!e1.isEmpty()),
                            featureIndex: c,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t1.image,
                            imageAtlas: o,
                            glyphMap: this.returnDependencies ? d : null,
                            iconMap: this.returnDependencies ? g : null,
                            glyphPositions: this.returnDependencies ? t1.positions : null
                        });
                    }
                }
                x.length ? n.send("getImages", {
                    icons: x,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                }, (e1, t1)=>{
                    f || (f = e1, m = t1, w.call(this));
                }) : m = {}, w.call(this);
            }
        }
        function s(t1, o, i) {
            const r = new e1.EvaluationParameters(o);
            for (const e1 of t1)e1.recalculate(r, i);
        }
        function a(t1, o) {
            const i = e1.getArrayBuffer(t1.request, (t1, i, r, n)=>{
                t1 ? o(t1) : i && o(null, {
                    vectorTile: new e1.vectorTile.VectorTile(new e1.pbf(i)),
                    rawData: i,
                    cacheControl: r,
                    expires: n
                });
            });
            return ()=>{
                i.cancel(), o();
            };
        }
        class l {
            constructor(e1, t1, o, i){
                this.actor = e1, this.layerIndex = t1, this.availableImages = o, this.loadVectorData = i || a, this.loading = {}, this.loaded = {};
            }
            loadTile(t1, o) {
                const i = t1.uid;
                this.loading || (this.loading = {});
                const r = !!(t1 && t1.request && t1.request.collectResourceTiming) && new e1.RequestPerformance(t1.request), s = this.loading[i] = new n(t1);
                s.abort = this.loadVectorData(t1, (t1, n)=>{
                    if (delete this.loading[i], t1 || !n) return s.status = "done", this.loaded[i] = s, o(t1);
                    const a = n.rawData, l = {};
                    n.expires && (l.expires = n.expires), n.cacheControl && (l.cacheControl = n.cacheControl);
                    const c = {};
                    if (r) {
                        const e1 = r.finish();
                        e1 && (c.resourceTiming = JSON.parse(JSON.stringify(e1)));
                    }
                    s.vectorTile = n.vectorTile, s.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, (t1, i)=>{
                        if (t1 || !i) return o(t1);
                        o(null, e1.extend({
                            rawTileData: a.slice(0)
                        }, i, l, c));
                    }), this.loaded = this.loaded || {}, this.loaded[i] = s;
                });
            }
            reloadTile(e1, t1) {
                const o = this.loaded, i = e1.uid, r = this;
                if (o && o[i]) {
                    const n = o[i];
                    n.showCollisionBoxes = e1.showCollisionBoxes;
                    const s = (e1, o)=>{
                        const i = n.reloadCallback;
                        i && (delete n.reloadCallback, n.parse(n.vectorTile, r.layerIndex, this.availableImages, r.actor, i)), t1(e1, o);
                    };
                    "parsing" === n.status ? n.reloadCallback = s : "done" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s());
                }
            }
            abortTile(e1, t1) {
                const o = this.loading, i = e1.uid;
                o && o[i] && o[i].abort && (o[i].abort(), delete o[i]), t1();
            }
            removeTile(e1, t1) {
                const o = this.loaded, i = e1.uid;
                o && o[i] && delete o[i], t1();
            }
        }
        class c {
            constructor(){
                this.loaded = {};
            }
            loadTile(t1, o) {
                const { uid: i, encoding: r, rawImageData: n } = t1, s = e1.isImageBitmap(n) ? this.getImageData(n) : n, a = new e1.DEMData(i, s, r);
                this.loaded = this.loaded || {}, this.loaded[i] = a, o(null, a);
            }
            getImageData(t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t1.width, t1.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t1.width, this.offscreenCanvas.height = t1.height, this.offscreenCanvasContext.drawImage(t1, 0, 0, t1.width, t1.height);
                const o = this.offscreenCanvasContext.getImageData(-1, -1, t1.width + 2, t1.height + 2);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e1.RGBAImage({
                    width: o.width,
                    height: o.height
                }, o.data);
            }
            removeTile(e1) {
                const t1 = this.loaded, o = e1.uid;
                t1 && t1[o] && delete t1[o];
            }
        }
        var u = function e1(t1, o) {
            var i, r = t1 && t1.type;
            if ("FeatureCollection" === r) for(i = 0; i < t1.features.length; i++)e1(t1.features[i], o);
            else if ("GeometryCollection" === r) for(i = 0; i < t1.geometries.length; i++)e1(t1.geometries[i], o);
            else if ("Feature" === r) e1(t1.geometry, o);
            else if ("Polygon" === r) h(t1.coordinates, o);
            else if ("MultiPolygon" === r) for(i = 0; i < t1.coordinates.length; i++)h(t1.coordinates[i], o);
            return t1;
        };
        function h(e1, t1) {
            if (0 !== e1.length) {
                p(e1[0], t1);
                for(var o = 1; o < e1.length; o++)p(e1[o], !t1);
            }
        }
        function p(e1, t1) {
            for(var o = 0, i = 0, r = 0, n = e1.length, s = n - 1; r < n; s = r++){
                var a = (e1[r][0] - e1[s][0]) * (e1[s][1] + e1[r][1]), l = o + a;
                i += Math.abs(o) >= Math.abs(a) ? o - l + a : a - l + o, o = l;
            }
            o + i >= 0 != !!t1 && e1.reverse();
        }
        const f = e1.vectorTile.VectorTileFeature.prototype.toGeoJSON;
        class d {
            constructor(t1){
                this._feature = t1, this.extent = e1.EXTENT, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t1 = [];
                    for (const o of this._feature.geometry)t1.push([
                        new e1.pointGeometry(o[0], o[1])
                    ]);
                    return t1;
                }
                {
                    const t1 = [];
                    for (const o of this._feature.geometry){
                        const i = [];
                        for (const t1 of o)i.push(new e1.pointGeometry(t1[0], t1[1]));
                        t1.push(i);
                    }
                    return t1;
                }
            }
            toGeoJSON(e1, t1, o) {
                return f.call(this, e1, t1, o);
            }
        }
        class g {
            constructor(t1){
                this.layers = {
                    _geojsonTileLayer: this
                }, this.name = "_geojsonTileLayer", this.extent = e1.EXTENT, this.length = t1.length, this._features = t1;
            }
            feature(e1) {
                return new d(this._features[e1]);
            }
        }
        var m = {
            exports: {}
        }, y = e1.pointGeometry, v = e1.vectorTile.VectorTileFeature, x = w;
        function w(e1, t1) {
            this.options = t1 || {}, this.features = e1, this.length = e1.length;
        }
        function S(e1, t1) {
            this.id = "number" == typeof e1.id ? e1.id : void 0, this.type = e1.type, this.rawGeometry = 1 === e1.type ? [
                e1.geometry
            ] : e1.geometry, this.properties = e1.tags, this.extent = t1 || 4096;
        }
        w.prototype.feature = function(e1) {
            return new S(this.features[e1], this.options.extent);
        }, S.prototype.loadGeometry = function() {
            var e1 = this.rawGeometry;
            this.geometry = [];
            for(var t1 = 0; t1 < e1.length; t1++){
                for(var o = e1[t1], i = [], r = 0; r < o.length; r++)i.push(new y(o[r][0], o[r][1]));
                this.geometry.push(i);
            }
            return this.geometry;
        }, S.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for(var e1 = this.geometry, t1 = 1 / 0, o = -1 / 0, i = 1 / 0, r = -1 / 0, n = 0; n < e1.length; n++)for(var s = e1[n], a = 0; a < s.length; a++){
                var l = s[a];
                t1 = Math.min(t1, l.x), o = Math.max(o, l.x), i = Math.min(i, l.y), r = Math.max(r, l.y);
            }
            return [
                t1,
                i,
                o,
                r
            ];
        }, S.prototype.toGeoJSON = v.prototype.toGeoJSON;
        var M = e1.pbf, I = x;
        function b(e1) {
            var t1 = new M;
            return function(e1, t1) {
                for(var o in e1.layers)t1.writeMessage(3, k, e1.layers[o]);
            }(e1, t1), t1.finish();
        }
        function k(e1, t1) {
            var o;
            t1.writeVarintField(15, e1.version || 1), t1.writeStringField(1, e1.name || ""), t1.writeVarintField(5, e1.extent || 4096);
            var i = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
            };
            for(o = 0; o < e1.length; o++)i.feature = e1.feature(o), t1.writeMessage(2, P, i);
            var r = i.keys;
            for(o = 0; o < r.length; o++)t1.writeStringField(3, r[o]);
            var n = i.values;
            for(o = 0; o < n.length; o++)t1.writeMessage(4, L, n[o]);
        }
        function P(e1, t1) {
            var o = e1.feature;
            void 0 !== o.id && t1.writeVarintField(1, o.id), t1.writeMessage(2, T, e1), t1.writeVarintField(3, o.type), t1.writeMessage(4, D, o);
        }
        function T(e1, t1) {
            var o = e1.feature, i = e1.keys, r = e1.values, n = e1.keycache, s = e1.valuecache;
            for(var a in o.properties){
                var l = o.properties[a], c = n[a];
                if (null !== l) {
                    void 0 === c && (i.push(a), n[a] = c = i.length - 1), t1.writeVarint(c);
                    var u = typeof l;
                    "string" !== u && "boolean" !== u && "number" !== u && (l = JSON.stringify(l));
                    var h = u + ":" + l, p = s[h];
                    void 0 === p && (r.push(l), s[h] = p = r.length - 1), t1.writeVarint(p);
                }
            }
        }
        function C(e1, t1) {
            return (t1 << 3) + (7 & e1);
        }
        function _(e1) {
            return e1 << 1 ^ e1 >> 31;
        }
        function D(e1, t1) {
            for(var o = e1.loadGeometry(), i = e1.type, r = 0, n = 0, s = o.length, a = 0; a < s; a++){
                var l = o[a], c = 1;
                1 === i && (c = l.length), t1.writeVarint(C(1, c));
                for(var u = 3 === i ? l.length - 1 : l.length, h = 0; h < u; h++){
                    1 === h && 1 !== i && t1.writeVarint(C(2, u - 1));
                    var p = l[h].x - r, f = l[h].y - n;
                    t1.writeVarint(_(p)), t1.writeVarint(_(f)), r += p, n += f;
                }
                3 === i && t1.writeVarint(C(7, 1));
            }
        }
        function L(e1, t1) {
            var o = typeof e1;
            "string" === o ? t1.writeStringField(1, e1) : "boolean" === o ? t1.writeBooleanField(7, e1) : "number" === o && (e1 % 1 != 0 ? t1.writeDoubleField(3, e1) : e1 < 0 ? t1.writeSVarintField(6, e1) : t1.writeVarintField(5, e1));
        }
        function z(e1, t1, o, i, r, n) {
            if (r - i <= o) return;
            const s = i + r >> 1;
            O(e1, t1, s, i, r, n % 2), z(e1, t1, o, i, s - 1, n + 1), z(e1, t1, o, s + 1, r, n + 1);
        }
        function O(e1, t1, o, i, r, n) {
            for(; r > i;){
                if (r - i > 600) {
                    const s = r - i + 1, a = o - i + 1, l = Math.log(s), c = .5 * Math.exp(2 * l / 3), u = .5 * Math.sqrt(l * c * (s - c) / s) * (a - s / 2 < 0 ? -1 : 1);
                    O(e1, t1, o, Math.max(i, Math.floor(o - a * c / s + u)), Math.min(r, Math.floor(o + (s - a) * c / s + u)), n);
                }
                const s = t1[2 * o + n];
                let a = i, l = r;
                for(E(e1, t1, i, o), t1[2 * r + n] > s && E(e1, t1, i, r); a < l;){
                    for(E(e1, t1, a, l), a++, l--; t1[2 * a + n] < s;)a++;
                    for(; t1[2 * l + n] > s;)l--;
                }
                t1[2 * i + n] === s ? E(e1, t1, i, l) : (l++, E(e1, t1, l, r)), l <= o && (i = l + 1), o <= l && (r = l - 1);
            }
        }
        function E(e1, t1, o, i) {
            F(e1, o, i), F(t1, 2 * o, 2 * i), F(t1, 2 * o + 1, 2 * i + 1);
        }
        function F(e1, t1, o) {
            const i = e1[t1];
            e1[t1] = e1[o], e1[o] = i;
        }
        function N(e1, t1, o, i) {
            const r = e1 - o, n = t1 - i;
            return r * r + n * n;
        }
        m.exports = b, m.exports.fromVectorTileJs = b, m.exports.fromGeojsonVt = function(e1, t1) {
            t1 = t1 || {};
            var o = {};
            for(var i in e1)o[i] = new I(e1[i].features, t1), o[i].name = i, o[i].version = t1.version, o[i].extent = t1.extent;
            return b({
                layers: o
            });
        }, m.exports.GeoJSONWrapper = I;
        const A = (e1)=>e1[0], B = (e1)=>e1[1];
        class J {
            constructor(e1, t1 = A, o = B, i = 64, r = Float64Array){
                this.nodeSize = i, this.points = e1;
                const n = e1.length < 65536 ? Uint16Array : Uint32Array, s = this.ids = new n(e1.length), a = this.coords = new r(2 * e1.length);
                for(let i = 0; i < e1.length; i++)s[i] = i, a[2 * i] = t1(e1[i]), a[2 * i + 1] = o(e1[i]);
                z(s, a, i, 0, s.length - 1, 0);
            }
            range(e1, t1, o, i) {
                return function(e1, t1, o, i, r, n, s) {
                    const a = [
                        0,
                        e1.length - 1,
                        0
                    ], l = [];
                    let c, u;
                    for(; a.length;){
                        const h = a.pop(), p = a.pop(), f = a.pop();
                        if (p - f <= s) {
                            for(let s = f; s <= p; s++)c = t1[2 * s], u = t1[2 * s + 1], c >= o && c <= r && u >= i && u <= n && l.push(e1[s]);
                            continue;
                        }
                        const d = Math.floor((f + p) / 2);
                        c = t1[2 * d], u = t1[2 * d + 1], c >= o && c <= r && u >= i && u <= n && l.push(e1[d]);
                        const g = (h + 1) % 2;
                        (0 === h ? o <= c : i <= u) && (a.push(f), a.push(d - 1), a.push(g)), (0 === h ? r >= c : n >= u) && (a.push(d + 1), a.push(p), a.push(g));
                    }
                    return l;
                }(this.ids, this.coords, e1, t1, o, i, this.nodeSize);
            }
            within(e1, t1, o) {
                return function(e1, t1, o, i, r, n) {
                    const s = [
                        0,
                        e1.length - 1,
                        0
                    ], a = [], l = r * r;
                    for(; s.length;){
                        const c = s.pop(), u = s.pop(), h = s.pop();
                        if (u - h <= n) {
                            for(let r = h; r <= u; r++)N(t1[2 * r], t1[2 * r + 1], o, i) <= l && a.push(e1[r]);
                            continue;
                        }
                        const p = Math.floor((h + u) / 2), f = t1[2 * p], d = t1[2 * p + 1];
                        N(f, d, o, i) <= l && a.push(e1[p]);
                        const g = (c + 1) % 2;
                        (0 === c ? o - r <= f : i - r <= d) && (s.push(h), s.push(p - 1), s.push(g)), (0 === c ? o + r >= f : i + r >= d) && (s.push(p + 1), s.push(u), s.push(g));
                    }
                    return a;
                }(this.ids, this.coords, e1, t1, o, this.nodeSize);
            }
        }
        const Z = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e1)=>e1
        }, G = Math.fround || (j = new Float32Array(1), (e1)=>(j[0] = +e1, j[0]));
        var j;
        class Y {
            constructor(e1){
                this.options = H(Object.create(Z), e1), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e1) {
                const { log: t1, minZoom: o, maxZoom: i, nodeSize: r } = this.options;
                t1 && console.time("total time");
                const n = `prepare ${e1.length} points`;
                t1 && console.time(n), this.points = e1;
                let s = [];
                for(let t1 = 0; t1 < e1.length; t1++)e1[t1].geometry && s.push(X(e1[t1], t1));
                this.trees[i + 1] = new J(s, K, Q, r, Float32Array), t1 && console.timeEnd(n);
                for(let e1 = i; e1 >= o; e1--){
                    const o = +Date.now();
                    s = this._cluster(s, e1), this.trees[e1] = new J(s, K, Q, r, Float32Array), t1 && console.log("z%d: %d clusters in %dms", e1, s.length, +Date.now() - o);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e1, t1) {
                let o = ((e1[0] + 180) % 360 + 360) % 360 - 180;
                const i = Math.max(-90, Math.min(90, e1[1]));
                let r = 180 === e1[2] ? 180 : ((e1[2] + 180) % 360 + 360) % 360 - 180;
                const n = Math.max(-90, Math.min(90, e1[3]));
                if (e1[2] - e1[0] >= 360) o = -180, r = 180;
                else if (o > r) {
                    const e1 = this.getClusters([
                        o,
                        i,
                        180,
                        n
                    ], t1), s = this.getClusters([
                        -180,
                        i,
                        r,
                        n
                    ], t1);
                    return e1.concat(s);
                }
                const s = this.trees[this._limitZoom(t1)], a = s.range($(o), q(n), $(r), q(i)), l = [];
                for (const e1 of a){
                    const t1 = s.points[e1];
                    l.push(t1.numPoints ? R(t1) : this.points[t1.index]);
                }
                return l;
            }
            getChildren(e1) {
                const t1 = this._getOriginId(e1), o = this._getOriginZoom(e1), i = "No cluster with the specified id.", r = this.trees[o];
                if (!r) throw new Error(i);
                const n = r.points[t1];
                if (!n) throw new Error(i);
                const s = this.options.radius / (this.options.extent * Math.pow(2, o - 1)), a = r.within(n.x, n.y, s), l = [];
                for (const t1 of a){
                    const o = r.points[t1];
                    o.parentId === e1 && l.push(o.numPoints ? R(o) : this.points[o.index]);
                }
                if (0 === l.length) throw new Error(i);
                return l;
            }
            getLeaves(e1, t1, o) {
                const i = [];
                return this._appendLeaves(i, e1, t1 = t1 || 10, o = o || 0, 0), i;
            }
            getTile(e1, t1, o) {
                const i = this.trees[this._limitZoom(e1)], r = Math.pow(2, e1), { extent: n, radius: s } = this.options, a = s / n, l = (o - a) / r, c = (o + 1 + a) / r, u = {
                    features: []
                };
                return this._addTileFeatures(i.range((t1 - a) / r, l, (t1 + 1 + a) / r, c), i.points, t1, o, r, u), 0 === t1 && this._addTileFeatures(i.range(1 - a / r, l, 1, c), i.points, r, o, r, u), t1 === r - 1 && this._addTileFeatures(i.range(0, l, a / r, c), i.points, -1, o, r, u), u.features.length ? u : null;
            }
            getClusterExpansionZoom(e1) {
                let t1 = this._getOriginZoom(e1) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const o = this.getChildren(e1);
                    if (t1++, 1 !== o.length) break;
                    e1 = o[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e1, t1, o, i, r) {
                const n = this.getChildren(t1);
                for (const t1 of n){
                    const n = t1.properties;
                    if (n && n.cluster ? r + n.point_count <= i ? r += n.point_count : r = this._appendLeaves(e1, n.cluster_id, o, i, r) : r < i ? r++ : e1.push(t1), e1.length === o) break;
                }
                return r;
            }
            _addTileFeatures(e1, t1, o, i, r, n) {
                for (const s of e1){
                    const e1 = t1[s], a = e1.numPoints;
                    let l, c, u;
                    if (a) l = W(e1), c = e1.x, u = e1.y;
                    else {
                        const t1 = this.points[e1.index];
                        l = t1.properties, c = $(t1.geometry.coordinates[0]), u = q(t1.geometry.coordinates[1]);
                    }
                    const h = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (c * r - o)),
                                Math.round(this.options.extent * (u * r - i))
                            ]
                        ],
                        tags: l
                    };
                    let p;
                    a ? p = e1.id : this.options.generateId ? p = e1.index : this.points[e1.index].id && (p = this.points[e1.index].id), void 0 !== p && (h.id = p), n.features.push(h);
                }
            }
            _limitZoom(e1) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e1), this.options.maxZoom + 1));
            }
            _cluster(e1, t1) {
                const o = [], { radius: i, extent: r, reduce: n, minPoints: s } = this.options, a = i / (r * Math.pow(2, t1));
                for(let i = 0; i < e1.length; i++){
                    const r = e1[i];
                    if (r.zoom <= t1) continue;
                    r.zoom = t1;
                    const l = this.trees[t1 + 1], c = l.within(r.x, r.y, a), u = r.numPoints || 1;
                    let h = u;
                    for (const e1 of c){
                        const o = l.points[e1];
                        o.zoom > t1 && (h += o.numPoints || 1);
                    }
                    if (h > u && h >= s) {
                        let e1 = r.x * u, s = r.y * u, a = n && u > 1 ? this._map(r, !0) : null;
                        const p = (i << 5) + (t1 + 1) + this.points.length;
                        for (const o of c){
                            const i = l.points[o];
                            if (i.zoom <= t1) continue;
                            i.zoom = t1;
                            const c = i.numPoints || 1;
                            e1 += i.x * c, s += i.y * c, i.parentId = p, n && (a || (a = this._map(r, !0)), n(a, this._map(i)));
                        }
                        r.parentId = p, o.push(V(e1 / h, s / h, p, h, a));
                    } else if (o.push(r), h > 1) for (const e1 of c){
                        const i = l.points[e1];
                        i.zoom <= t1 || (i.zoom = t1, o.push(i));
                    }
                }
                return o;
            }
            _getOriginId(e1) {
                return e1 - this.points.length >> 5;
            }
            _getOriginZoom(e1) {
                return (e1 - this.points.length) % 32;
            }
            _map(e1, t1) {
                if (e1.numPoints) return t1 ? H({}, e1.properties) : e1.properties;
                const o = this.points[e1.index].properties, i = this.options.map(o);
                return t1 && i === o ? H({}, i) : i;
            }
        }
        function V(e1, t1, o, i, r) {
            return {
                x: G(e1),
                y: G(t1),
                zoom: 1 / 0,
                id: o,
                parentId: -1,
                numPoints: i,
                properties: r
            };
        }
        function X(e1, t1) {
            const [o, i] = e1.geometry.coordinates;
            return {
                x: G($(o)),
                y: G(q(i)),
                zoom: 1 / 0,
                index: t1,
                parentId: -1
            };
        }
        function R(e1) {
            var t1;
            return {
                type: "Feature",
                id: e1.id,
                properties: W(e1),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (t1 = e1.x, 360 * (t1 - .5)),
                        U(e1.y)
                    ]
                }
            };
        }
        function W(e1) {
            const t1 = e1.numPoints, o = t1 >= 1e4 ? `${Math.round(t1 / 1e3)}k` : t1 >= 1e3 ? Math.round(t1 / 100) / 10 + "k" : t1;
            return H(H({}, e1.properties), {
                cluster: !0,
                cluster_id: e1.id,
                point_count: t1,
                point_count_abbreviated: o
            });
        }
        function $(e1) {
            return e1 / 360 + .5;
        }
        function q(e1) {
            const t1 = Math.sin(e1 * Math.PI / 180), o = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return o < 0 ? 0 : o > 1 ? 1 : o;
        }
        function U(e1) {
            const t1 = (180 - 360 * e1) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function H(e1, t1) {
            for(const o in t1)e1[o] = t1[o];
            return e1;
        }
        function K(e1) {
            return e1.x;
        }
        function Q(e1) {
            return e1.y;
        }
        function ee(e1, t1, o, i) {
            for(var r, n = i, s = o - t1 >> 1, a = o - t1, l = e1[t1], c = e1[t1 + 1], u = e1[o], h = e1[o + 1], p = t1 + 3; p < o; p += 3){
                var f = te(e1[p], e1[p + 1], l, c, u, h);
                if (f > n) r = p, n = f;
                else if (f === n) {
                    var d = Math.abs(p - s);
                    d < a && (r = p, a = d);
                }
            }
            n > i && (r - t1 > 3 && ee(e1, t1, r, i), e1[r + 2] = n, o - r > 3 && ee(e1, r, o, i));
        }
        function te(e1, t1, o, i, r, n) {
            var s = r - o, a = n - i;
            if (0 !== s || 0 !== a) {
                var l = ((e1 - o) * s + (t1 - i) * a) / (s * s + a * a);
                l > 1 ? (o = r, i = n) : l > 0 && (o += s * l, i += a * l);
            }
            return (s = e1 - o) * s + (a = t1 - i) * a;
        }
        function oe(e1, t1, o, i) {
            var r = {
                id: void 0 === e1 ? null : e1,
                type: t1,
                geometry: o,
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return function(e1) {
                var t1 = e1.geometry, o = e1.type;
                if ("Point" === o || "MultiPoint" === o || "LineString" === o) ie(e1, t1);
                else if ("Polygon" === o || "MultiLineString" === o) for(var i = 0; i < t1.length; i++)ie(e1, t1[i]);
                else if ("MultiPolygon" === o) for(i = 0; i < t1.length; i++)for(var r = 0; r < t1[i].length; r++)ie(e1, t1[i][r]);
            }(r), r;
        }
        function ie(e1, t1) {
            for(var o = 0; o < t1.length; o += 3)e1.minX = Math.min(e1.minX, t1[o]), e1.minY = Math.min(e1.minY, t1[o + 1]), e1.maxX = Math.max(e1.maxX, t1[o]), e1.maxY = Math.max(e1.maxY, t1[o + 1]);
        }
        function re(e1, t1, o, i) {
            if (t1.geometry) {
                var r = t1.geometry.coordinates, n = t1.geometry.type, s = Math.pow(o.tolerance / ((1 << o.maxZoom) * o.extent), 2), a = [], l = t1.id;
                if (o.promoteId ? l = t1.properties[o.promoteId] : o.generateId && (l = i || 0), "Point" === n) ne(r, a);
                else if ("MultiPoint" === n) for(var c = 0; c < r.length; c++)ne(r[c], a);
                else if ("LineString" === n) se(r, a, s, !1);
                else if ("MultiLineString" === n) {
                    if (o.lineMetrics) {
                        for(c = 0; c < r.length; c++)se(r[c], a = [], s, !1), e1.push(oe(l, "LineString", a, t1.properties));
                        return;
                    }
                    ae(r, a, s, !1);
                } else if ("Polygon" === n) ae(r, a, s, !0);
                else {
                    if ("MultiPolygon" !== n) {
                        if ("GeometryCollection" === n) {
                            for(c = 0; c < t1.geometry.geometries.length; c++)re(e1, {
                                id: l,
                                geometry: t1.geometry.geometries[c],
                                properties: t1.properties
                            }, o, i);
                            return;
                        }
                        throw new Error("Input data is not a valid GeoJSON object.");
                    }
                    for(c = 0; c < r.length; c++){
                        var u = [];
                        ae(r[c], u, s, !0), a.push(u);
                    }
                }
                e1.push(oe(l, n, a, t1.properties));
            }
        }
        function ne(e1, t1) {
            t1.push(le(e1[0])), t1.push(ce(e1[1])), t1.push(0);
        }
        function se(e1, t1, o, i) {
            for(var r, n, s = 0, a = 0; a < e1.length; a++){
                var l = le(e1[a][0]), c = ce(e1[a][1]);
                t1.push(l), t1.push(c), t1.push(0), a > 0 && (s += i ? (r * c - l * n) / 2 : Math.sqrt(Math.pow(l - r, 2) + Math.pow(c - n, 2))), r = l, n = c;
            }
            var u = t1.length - 3;
            t1[2] = 1, ee(t1, 0, u, o), t1[u + 2] = 1, t1.size = Math.abs(s), t1.start = 0, t1.end = t1.size;
        }
        function ae(e1, t1, o, i) {
            for(var r = 0; r < e1.length; r++){
                var n = [];
                se(e1[r], n, o, i), t1.push(n);
            }
        }
        function le(e1) {
            return e1 / 360 + .5;
        }
        function ce(e1) {
            var t1 = Math.sin(e1 * Math.PI / 180), o = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return o < 0 ? 0 : o > 1 ? 1 : o;
        }
        function ue(e1, t1, o, i, r, n, s, a) {
            if (i /= t1, n >= (o /= t1) && s < i) return e1;
            if (s < o || n >= i) return null;
            for(var l = [], c = 0; c < e1.length; c++){
                var u = e1[c], h = u.geometry, p = u.type, f = 0 === r ? u.minX : u.minY, d = 0 === r ? u.maxX : u.maxY;
                if (f >= o && d < i) l.push(u);
                else if (!(d < o || f >= i)) {
                    var g = [];
                    if ("Point" === p || "MultiPoint" === p) he(h, g, o, i, r);
                    else if ("LineString" === p) pe(h, g, o, i, r, !1, a.lineMetrics);
                    else if ("MultiLineString" === p) de(h, g, o, i, r, !1);
                    else if ("Polygon" === p) de(h, g, o, i, r, !0);
                    else if ("MultiPolygon" === p) for(var m = 0; m < h.length; m++){
                        var y = [];
                        de(h[m], y, o, i, r, !0), y.length && g.push(y);
                    }
                    if (g.length) {
                        if (a.lineMetrics && "LineString" === p) {
                            for(m = 0; m < g.length; m++)l.push(oe(u.id, p, g[m], u.tags));
                            continue;
                        }
                        "LineString" !== p && "MultiLineString" !== p || (1 === g.length ? (p = "LineString", g = g[0]) : p = "MultiLineString"), "Point" !== p && "MultiPoint" !== p || (p = 3 === g.length ? "Point" : "MultiPoint"), l.push(oe(u.id, p, g, u.tags));
                    }
                }
            }
            return l.length ? l : null;
        }
        function he(e1, t1, o, i, r) {
            for(var n = 0; n < e1.length; n += 3){
                var s = e1[n + r];
                s >= o && s <= i && (t1.push(e1[n]), t1.push(e1[n + 1]), t1.push(e1[n + 2]));
            }
        }
        function pe(e1, t1, o, i, r, n, s) {
            for(var a, l, c = fe(e1), u = 0 === r ? me : ye, h = e1.start, p = 0; p < e1.length - 3; p += 3){
                var f = e1[p], d = e1[p + 1], g = e1[p + 2], m = e1[p + 3], y = e1[p + 4], v = 0 === r ? f : d, x = 0 === r ? m : y, w = !1;
                s && (a = Math.sqrt(Math.pow(f - m, 2) + Math.pow(d - y, 2))), v < o ? x > o && (l = u(c, f, d, m, y, o), s && (c.start = h + a * l)) : v > i ? x < i && (l = u(c, f, d, m, y, i), s && (c.start = h + a * l)) : ge(c, f, d, g), x < o && v >= o && (l = u(c, f, d, m, y, o), w = !0), x > i && v <= i && (l = u(c, f, d, m, y, i), w = !0), !n && w && (s && (c.end = h + a * l), t1.push(c), c = fe(e1)), s && (h += a);
            }
            var S = e1.length - 3;
            f = e1[S], d = e1[S + 1], g = e1[S + 2], (v = 0 === r ? f : d) >= o && v <= i && ge(c, f, d, g), S = c.length - 3, n && S >= 3 && (c[S] !== c[0] || c[S + 1] !== c[1]) && ge(c, c[0], c[1], c[2]), c.length && t1.push(c);
        }
        function fe(e1) {
            var t1 = [];
            return t1.size = e1.size, t1.start = e1.start, t1.end = e1.end, t1;
        }
        function de(e1, t1, o, i, r, n) {
            for(var s = 0; s < e1.length; s++)pe(e1[s], t1, o, i, r, n, !1);
        }
        function ge(e1, t1, o, i) {
            e1.push(t1), e1.push(o), e1.push(i);
        }
        function me(e1, t1, o, i, r, n) {
            var s = (n - t1) / (i - t1);
            return e1.push(n), e1.push(o + (r - o) * s), e1.push(1), s;
        }
        function ye(e1, t1, o, i, r, n) {
            var s = (n - o) / (r - o);
            return e1.push(t1 + (i - t1) * s), e1.push(n), e1.push(1), s;
        }
        function ve(e1, t1) {
            for(var o = [], i = 0; i < e1.length; i++){
                var r, n = e1[i], s = n.type;
                if ("Point" === s || "MultiPoint" === s || "LineString" === s) r = xe(n.geometry, t1);
                else if ("MultiLineString" === s || "Polygon" === s) {
                    r = [];
                    for(var a = 0; a < n.geometry.length; a++)r.push(xe(n.geometry[a], t1));
                } else if ("MultiPolygon" === s) for(r = [], a = 0; a < n.geometry.length; a++){
                    for(var l = [], c = 0; c < n.geometry[a].length; c++)l.push(xe(n.geometry[a][c], t1));
                    r.push(l);
                }
                o.push(oe(n.id, s, r, n.tags));
            }
            return o;
        }
        function xe(e1, t1) {
            var o = [];
            o.size = e1.size, void 0 !== e1.start && (o.start = e1.start, o.end = e1.end);
            for(var i = 0; i < e1.length; i += 3)o.push(e1[i] + t1, e1[i + 1], e1[i + 2]);
            return o;
        }
        function we(e1, t1) {
            if (e1.transformed) return e1;
            var o, i, r, n = 1 << e1.z, s = e1.x, a = e1.y;
            for(o = 0; o < e1.features.length; o++){
                var l = e1.features[o], c = l.geometry, u = l.type;
                if (l.geometry = [], 1 === u) for(i = 0; i < c.length; i += 2)l.geometry.push(Se(c[i], c[i + 1], t1, n, s, a));
                else for(i = 0; i < c.length; i++){
                    var h = [];
                    for(r = 0; r < c[i].length; r += 2)h.push(Se(c[i][r], c[i][r + 1], t1, n, s, a));
                    l.geometry.push(h);
                }
            }
            return e1.transformed = !0, e1;
        }
        function Se(e1, t1, o, i, r, n) {
            return [
                Math.round(o * (e1 * i - r)),
                Math.round(o * (t1 * i - n))
            ];
        }
        function Me(e1, t1, o, i, r) {
            for(var n = t1 === r.maxZoom ? 0 : r.tolerance / ((1 << t1) * r.extent), s = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: 0,
                source: null,
                x: o,
                y: i,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            }, a = 0; a < e1.length; a++){
                s.numFeatures++, Ie(s, e1[a], n, r);
                var l = e1[a].minX, c = e1[a].minY, u = e1[a].maxX, h = e1[a].maxY;
                l < s.minX && (s.minX = l), c < s.minY && (s.minY = c), u > s.maxX && (s.maxX = u), h > s.maxY && (s.maxY = h);
            }
            return s;
        }
        function Ie(e1, t1, o, i) {
            var r = t1.geometry, n = t1.type, s = [];
            if ("Point" === n || "MultiPoint" === n) for(var a = 0; a < r.length; a += 3)s.push(r[a]), s.push(r[a + 1]), e1.numPoints++, e1.numSimplified++;
            else if ("LineString" === n) be(s, r, e1, o, !1, !1);
            else if ("MultiLineString" === n || "Polygon" === n) for(a = 0; a < r.length; a++)be(s, r[a], e1, o, "Polygon" === n, 0 === a);
            else if ("MultiPolygon" === n) for(var l = 0; l < r.length; l++){
                var c = r[l];
                for(a = 0; a < c.length; a++)be(s, c[a], e1, o, !0, 0 === a);
            }
            if (s.length) {
                var u = t1.tags || null;
                if ("LineString" === n && i.lineMetrics) {
                    for(var h in u = {}, t1.tags)u[h] = t1.tags[h];
                    u.mapbox_clip_start = r.start / r.size, u.mapbox_clip_end = r.end / r.size;
                }
                var p = {
                    geometry: s,
                    type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,
                    tags: u
                };
                null !== t1.id && (p.id = t1.id), e1.features.push(p);
            }
        }
        function be(e1, t1, o, i, r, n) {
            var s = i * i;
            if (i > 0 && t1.size < (r ? s : i)) o.numPoints += t1.length / 3;
            else {
                for(var a = [], l = 0; l < t1.length; l += 3)(0 === i || t1[l + 2] > s) && (o.numSimplified++, a.push(t1[l]), a.push(t1[l + 1])), o.numPoints++;
                r && function(e1, t1) {
                    for(var o = 0, i = 0, r = e1.length, n = r - 2; i < r; n = i, i += 2)o += (e1[i] - e1[n]) * (e1[i + 1] + e1[n + 1]);
                    if (o > 0 === t1) for(i = 0, r = e1.length; i < r / 2; i += 2){
                        var s = e1[i], a = e1[i + 1];
                        e1[i] = e1[r - 2 - i], e1[i + 1] = e1[r - 1 - i], e1[r - 2 - i] = s, e1[r - 1 - i] = a;
                    }
                }(a, n), e1.push(a);
            }
        }
        function ke(e1, t1) {
            var o = (t1 = this.options = function(e1, t1) {
                for(var o in t1)e1[o] = t1[o];
                return e1;
            }(Object.create(this.options), t1)).debug;
            if (o && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
            var i = function(e1, t1) {
                var o = [];
                if ("FeatureCollection" === e1.type) for(var i = 0; i < e1.features.length; i++)re(o, e1.features[i], t1, i);
                else re(o, "Feature" === e1.type ? e1 : {
                    geometry: e1
                }, t1);
                return o;
            }(e1, t1);
            this.tiles = {}, this.tileCoords = [], o && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = function(e1, t1) {
                var o = t1.buffer / t1.extent, i = e1, r = ue(e1, 1, -1 - o, o, 0, -1, 2, t1), n = ue(e1, 1, 1 - o, 2 + o, 0, -1, 2, t1);
                return (r || n) && (i = ue(e1, 1, -o, 1 + o, 0, -1, 2, t1) || [], r && (i = ve(r, 1).concat(i)), n && (i = i.concat(ve(n, -1)))), i;
            }(i, t1), i.length && this.splitTile(i, 0, 0, 0), o && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Pe(e1, t1, o) {
            return 32 * ((1 << e1) * o + t1) + e1;
        }
        function Te(e1, t1) {
            const o = e1.tileID.canonical;
            if (!this._geoJSONIndex) return t1(null, null);
            const i = this._geoJSONIndex.getTile(o.z, o.x, o.y);
            if (!i) return t1(null, null);
            const r = new g(i.features);
            let n = m.exports(r);
            0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t1(null, {
                vectorTile: r,
                rawData: n.buffer
            });
        }
        ke.prototype.options = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        }, ke.prototype.splitTile = function(e1, t1, o, i, r, n, s) {
            for(var a = [
                e1,
                t1,
                o,
                i
            ], l = this.options, c = l.debug; a.length;){
                i = a.pop(), o = a.pop(), t1 = a.pop(), e1 = a.pop();
                var u = 1 << t1, h = Pe(t1, o, i), p = this.tiles[h];
                if (!p && (c > 1 && console.time("creation"), p = this.tiles[h] = Me(e1, t1, o, i, l), this.tileCoords.push({
                    z: t1,
                    x: o,
                    y: i
                }), c)) {
                    c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, o, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd("creation"));
                    var f = "z" + t1;
                    this.stats[f] = (this.stats[f] || 0) + 1, this.total++;
                }
                if (p.source = e1, r) {
                    if (t1 === l.maxZoom || t1 === r) continue;
                    var d = 1 << r - t1;
                    if (o !== Math.floor(n / d) || i !== Math.floor(s / d)) continue;
                } else if (t1 === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;
                if (p.source = null, 0 !== e1.length) {
                    c > 1 && console.time("clipping");
                    var g, m, y, v, x, w, S = .5 * l.buffer / l.extent, M = .5 - S, I = .5 + S, b = 1 + S;
                    g = m = y = v = null, x = ue(e1, u, o - S, o + I, 0, p.minX, p.maxX, l), w = ue(e1, u, o + M, o + b, 0, p.minX, p.maxX, l), e1 = null, x && (g = ue(x, u, i - S, i + I, 1, p.minY, p.maxY, l), m = ue(x, u, i + M, i + b, 1, p.minY, p.maxY, l), x = null), w && (y = ue(w, u, i - S, i + I, 1, p.minY, p.maxY, l), v = ue(w, u, i + M, i + b, 1, p.minY, p.maxY, l), w = null), c > 1 && console.timeEnd("clipping"), a.push(g || [], t1 + 1, 2 * o, 2 * i), a.push(m || [], t1 + 1, 2 * o, 2 * i + 1), a.push(y || [], t1 + 1, 2 * o + 1, 2 * i), a.push(v || [], t1 + 1, 2 * o + 1, 2 * i + 1);
                }
            }
        }, ke.prototype.getTile = function(e1, t1, o) {
            var i = this.options, r = i.extent, n = i.debug;
            if (e1 < 0 || e1 > 24) return null;
            var s = 1 << e1, a = Pe(e1, t1 = (t1 % s + s) % s, o);
            if (this.tiles[a]) return we(this.tiles[a], r);
            n > 1 && console.log("drilling down to z%d-%d-%d", e1, t1, o);
            for(var l, c = e1, u = t1, h = o; !l && c > 0;)c--, u = Math.floor(u / 2), h = Math.floor(h / 2), l = this.tiles[Pe(c, u, h)];
            return l && l.source ? (n > 1 && console.log("found parent tile z%d-%d-%d", c, u, h), n > 1 && console.time("drilling down"), this.splitTile(l.source, c, u, h, e1, t1, o), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? we(this.tiles[a], r) : null) : null;
        };
        class Ce extends l {
            constructor(e1, t1, o, i){
                super(e1, t1, o, Te), i && (this.loadGeoJSON = i);
            }
            loadData(t1, o) {
                var i;
                null === (i = this._pendingRequest) || void 0 === i || i.cancel(), this._pendingCallback && this._pendingCallback(null, {
                    abandoned: !0
                });
                const r = !!(t1 && t1.request && t1.request.collectResourceTiming) && new e1.RequestPerformance(t1.request);
                this._pendingCallback = o, this._pendingRequest = this.loadGeoJSON(t1, (i, n)=>{
                    if (delete this._pendingCallback, delete this._pendingRequest, i || !n) return o(i);
                    if ("object" != typeof n) return o(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    {
                        u(n, !0);
                        try {
                            if (t1.filter) {
                                const o = e1.createExpression(t1.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === o.result) throw new Error(o.value.map((e1)=>`${e1.key}: ${e1.message}`).join(", "));
                                const i = n.features.filter((e1)=>o.value.evaluate({
                                        zoom: 0
                                    }, e1));
                                n = {
                                    type: "FeatureCollection",
                                    features: i
                                };
                            }
                            this._geoJSONIndex = t1.cluster ? new Y(function({ superclusterOptions: t1, clusterProperties: o }) {
                                if (!o || !t1) return t1;
                                const i = {}, r = {}, n = {
                                    accumulated: null,
                                    zoom: 0
                                }, s = {
                                    properties: null
                                }, a = Object.keys(o);
                                for (const t1 of a){
                                    const [n, s] = o[t1], a = e1.createExpression(s), l = e1.createExpression("string" == typeof n ? [
                                        n,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : n);
                                    i[t1] = a.value, r[t1] = l.value;
                                }
                                return t1.map = (e1)=>{
                                    s.properties = e1;
                                    const t1 = {};
                                    for (const e1 of a)t1[e1] = i[e1].evaluate(n, s);
                                    return t1;
                                }, t1.reduce = (e1, t1)=>{
                                    s.properties = t1;
                                    for (const t1 of a)n.accumulated = e1[t1], e1[t1] = r[t1].evaluate(n, s);
                                }, t1;
                            }(t1)).load(n.features) : function(e1, t1) {
                                return new ke(e1, t1);
                            }(n, t1.geojsonVtOptions);
                        } catch (i) {
                            return o(i);
                        }
                        this.loaded = {};
                        const s = {};
                        if (r) {
                            const e1 = r.finish();
                            e1 && (s.resourceTiming = {}, s.resourceTiming[t1.source] = JSON.parse(JSON.stringify(e1)));
                        }
                        o(null, s);
                    }
                });
            }
            reloadTile(e1, t1) {
                const o = this.loaded;
                return o && o[e1.uid] ? super.reloadTile(e1, t1) : this.loadTile(e1, t1);
            }
            loadGeoJSON(t1, o) {
                if (t1.request) return e1.getJSON(t1.request, o);
                if ("string" == typeof t1.data) try {
                    o(null, JSON.parse(t1.data));
                } catch (e1) {
                    o(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                }
                else o(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                return {
                    cancel: ()=>{}
                };
            }
            removeSource(e1, t1) {
                this._pendingCallback && this._pendingCallback(null, {
                    abandoned: !0
                }), t1();
            }
            getClusterExpansionZoom(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e1.clusterId));
                } catch (e1) {
                    t1(e1);
                }
            }
            getClusterChildren(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e1.clusterId));
                } catch (e1) {
                    t1(e1);
                }
            }
            getClusterLeaves(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e1.clusterId, e1.limit, e1.offset));
                } catch (e1) {
                    t1(e1);
                }
            }
        }
        class _e {
            constructor(t1){
                this.self = t1, this.actor = new e1.Actor(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = {
                    vector: l,
                    geojson: Ce
                }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e1, t1)=>{
                    if (this.workerSourceTypes[e1]) throw new Error(`Worker source with name "${e1}" already registered.`);
                    this.workerSourceTypes[e1] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e1.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
                    e1.plugin.applyArabicShaping = t1.applyArabicShaping, e1.plugin.processBidirectionalText = t1.processBidirectionalText, e1.plugin.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                };
            }
            setReferrer(e1, t1) {
                this.referrer = t1;
            }
            setImages(e1, t1, o) {
                this.availableImages[e1] = t1;
                for(const o in this.workerSources[e1]){
                    const i = this.workerSources[e1][o];
                    for(const e1 in i)i[e1].availableImages = t1;
                }
                o();
            }
            setLayers(e1, t1, o) {
                this.getLayerIndex(e1).replace(t1), o();
            }
            updateLayers(e1, t1, o) {
                this.getLayerIndex(e1).update(t1.layers, t1.removedIds), o();
            }
            loadTile(e1, t1, o) {
                this.getWorkerSource(e1, t1.type, t1.source).loadTile(t1, o);
            }
            loadDEMTile(e1, t1, o) {
                this.getDEMWorkerSource(e1, t1.source).loadTile(t1, o);
            }
            reloadTile(e1, t1, o) {
                this.getWorkerSource(e1, t1.type, t1.source).reloadTile(t1, o);
            }
            abortTile(e1, t1, o) {
                this.getWorkerSource(e1, t1.type, t1.source).abortTile(t1, o);
            }
            removeTile(e1, t1, o) {
                this.getWorkerSource(e1, t1.type, t1.source).removeTile(t1, o);
            }
            removeDEMTile(e1, t1) {
                this.getDEMWorkerSource(e1, t1.source).removeTile(t1);
            }
            removeSource(e1, t1, o) {
                if (!this.workerSources[e1] || !this.workerSources[e1][t1.type] || !this.workerSources[e1][t1.type][t1.source]) return;
                const i = this.workerSources[e1][t1.type][t1.source];
                delete this.workerSources[e1][t1.type][t1.source], void 0 !== i.removeSource ? i.removeSource(t1, o) : o();
            }
            loadWorkerSource(e1, t1, o) {
                try {
                    this.self.importScripts(t1.url), o();
                } catch (e1) {
                    o(e1.toString());
                }
            }
            syncRTLPluginState(t1, o, i) {
                try {
                    e1.plugin.setState(o);
                    const t1 = e1.plugin.getPluginURL();
                    if (e1.plugin.isLoaded() && !e1.plugin.isParsed() && null != t1) {
                        this.self.importScripts(t1);
                        const o = e1.plugin.isParsed();
                        i(o ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t1}`), o);
                    }
                } catch (e1) {
                    i(e1.toString());
                }
            }
            getAvailableImages(e1) {
                let t1 = this.availableImages[e1];
                return t1 || (t1 = []), t1;
            }
            getLayerIndex(e1) {
                let t1 = this.layerIndexes[e1];
                return t1 || (t1 = this.layerIndexes[e1] = new i), t1;
            }
            getWorkerSource(e1, t1, o) {
                if (this.workerSources[e1] || (this.workerSources[e1] = {}), this.workerSources[e1][t1] || (this.workerSources[e1][t1] = {}), !this.workerSources[e1][t1][o]) {
                    const i = {
                        send: (t1, o, i)=>{
                            this.actor.send(t1, o, i, e1);
                        }
                    };
                    this.workerSources[e1][t1][o] = new this.workerSourceTypes[t1](i, this.getLayerIndex(e1), this.getAvailableImages(e1));
                }
                return this.workerSources[e1][t1][o];
            }
            getDEMWorkerSource(e1, t1) {
                return this.demWorkerSources[e1] || (this.demWorkerSources[e1] = {}), this.demWorkerSources[e1][t1] || (this.demWorkerSources[e1][t1] = new c), this.demWorkerSources[e1][t1];
            }
            enforceCacheSizeLimit(t1, o) {
                e1.enforceCacheSizeLimit(o);
            }
        }
        return e1.isWorker() && (self.worker = new _e(self)), _e;
    });
    define([
        "./shared"
    ], function(t1) {
        "use strict";
        var e1 = i;
        function i(t1) {
            return !function(t1) {
                var e1;
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                    var t1, e1, i = new Blob([
                        ""
                    ], {
                        type: "text/javascript"
                    }), o = URL.createObjectURL(i);
                    try {
                        e1 = new Worker(o), t1 = !0;
                    } catch (e1) {
                        t1 = !1;
                    }
                    return e1 && e1.terminate(), URL.revokeObjectURL(o), t1;
                }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                    var t1 = document.createElement("canvas");
                    t1.width = t1.height = 1;
                    var e1 = t1.getContext("2d");
                    if (!e1) return !1;
                    var i = e1.getImageData(0, 0, 1, 1);
                    return i && i.width === t1.width;
                }() ? (void 0 === o[e1 = t1 && t1.failIfMajorPerformanceCaveat] && (o[e1] = function(t1) {
                    var e1, o = function(t1) {
                        var e1 = document.createElement("canvas"), o = Object.create(i.webGLContextAttributes);
                        return o.failIfMajorPerformanceCaveat = t1, e1.getContext("webgl", o) || e1.getContext("experimental-webgl", o);
                    }(t1);
                    if (!o) return !1;
                    try {
                        e1 = o.createShader(o.VERTEX_SHADER);
                    } catch (t1) {
                        return !1;
                    }
                    return !(!e1 || o.isContextLost()) && (o.shaderSource(e1, "void main() {}"), o.compileShader(e1), !0 === o.getShaderParameter(e1, o.COMPILE_STATUS));
                }(e1)), o[e1] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            }(t1);
        }
        var o = {};
        function a(t1, e1) {
            if (Array.isArray(t1)) {
                if (!Array.isArray(e1) || t1.length !== e1.length) return !1;
                for(let i = 0; i < t1.length; i++)if (!a(t1[i], e1[i])) return !1;
                return !0;
            }
            if ("object" == typeof t1 && null !== t1 && null !== e1) {
                if ("object" != typeof e1) return !1;
                if (Object.keys(t1).length !== Object.keys(e1).length) return !1;
                for(const i in t1)if (!a(t1[i], e1[i])) return !1;
                return !0;
            }
            return t1 === e1;
        }
        i.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        class r {
            static testProp(t1) {
                if (!r.docStyle) return t1[0];
                for(let e1 = 0; e1 < t1.length; e1++)if (t1[e1] in r.docStyle) return t1[e1];
                return t1[0];
            }
            static create(t1, e1, i) {
                const o = window.document.createElement(t1);
                return void 0 !== e1 && (o.className = e1), i && i.appendChild(o), o;
            }
            static createNS(t1, e1) {
                return window.document.createElementNS(t1, e1);
            }
            static disableDrag() {
                r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
            }
            static enableDrag() {
                r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
            }
            static setTransform(t1, e1) {
                t1.style[r.transformProp] = e1;
            }
            static addEventListener(t1, e1, i, o = {}) {
                t1.addEventListener(e1, i, "passive" in o ? o : o.capture);
            }
            static removeEventListener(t1, e1, i, o = {}) {
                t1.removeEventListener(e1, i, "passive" in o ? o : o.capture);
            }
            static suppressClickInternal(t1) {
                t1.preventDefault(), t1.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, !0);
            }
            static suppressClick() {
                window.addEventListener("click", r.suppressClickInternal, !0), window.setTimeout(()=>{
                    window.removeEventListener("click", r.suppressClickInternal, !0);
                }, 0);
            }
            static mousePos(e1, i) {
                const o = e1.getBoundingClientRect();
                return new t1.pointGeometry(i.clientX - o.left - e1.clientLeft, i.clientY - o.top - e1.clientTop);
            }
            static touchPos(e1, i) {
                const o = e1.getBoundingClientRect(), a = [];
                for(let r = 0; r < i.length; r++)a.push(new t1.pointGeometry(i[r].clientX - o.left - e1.clientLeft, i[r].clientY - o.top - e1.clientTop));
                return a;
            }
            static mouseButton(t1) {
                return t1.button;
            }
            static remove(t1) {
                t1.parentNode && t1.parentNode.removeChild(t1);
            }
        }
        r.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, r.selectProp = r.testProp([
            "userSelect",
            "MozUserSelect",
            "WebkitUserSelect",
            "msUserSelect"
        ]), r.transformProp = r.testProp([
            "transform",
            "WebkitTransform"
        ]);
        class s {
            constructor(t1){
                this._transformRequestFn = t1;
            }
            transformRequest(t1, e1) {
                return this._transformRequestFn && this._transformRequestFn(t1, e1) || {
                    url: t1
                };
            }
            normalizeSpriteURL(t1, e1, i) {
                const o = function(t1) {
                    const e1 = t1.match(n);
                    if (!e1) throw new Error(`Unable to parse URL "${t1}"`);
                    return {
                        protocol: e1[1],
                        authority: e1[2],
                        path: e1[3] || "/",
                        params: e1[4] ? e1[4].split("&") : []
                    };
                }(t1);
                return o.path += `${e1}${i}`, function(t1) {
                    const e1 = t1.params.length ? `?${t1.params.join("&")}` : "";
                    return `${t1.protocol}://${t1.authority}${t1.path}${e1}`;
                }(o);
            }
            setTransformRequest(t1) {
                this._transformRequestFn = t1;
            }
        }
        const n = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        class l {
            constructor(t1, e1, i, o){
                this.context = t1, this.format = i, this.texture = t1.gl.createTexture(), this.update(e1, o);
            }
            update(e1, i, o) {
                const { width: a, height: r } = e1, s = !(this.size && this.size[0] === a && this.size[1] === r || o), { context: n } = this, { gl: l } = n;
                if (this.useMipmap = Boolean(i && i.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), n.pixelStoreUnpackFlipY.set(!1), n.pixelStoreUnpack.set(1), n.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!i || !1 !== i.premultiply)), s) this.size = [
                    a,
                    r
                ], e1 instanceof HTMLImageElement || e1 instanceof HTMLCanvasElement || e1 instanceof HTMLVideoElement || e1 instanceof ImageData || t1.isImageBitmap(e1) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, e1) : l.texImage2D(l.TEXTURE_2D, 0, this.format, a, r, 0, this.format, l.UNSIGNED_BYTE, e1.data);
                else {
                    const { x: i, y: s } = o || {
                        x: 0,
                        y: 0
                    };
                    e1 instanceof HTMLImageElement || e1 instanceof HTMLCanvasElement || e1 instanceof HTMLVideoElement || e1 instanceof ImageData || t1.isImageBitmap(e1) ? l.texSubImage2D(l.TEXTURE_2D, 0, i, s, l.RGBA, l.UNSIGNED_BYTE, e1) : l.texSubImage2D(l.TEXTURE_2D, 0, i, s, a, r, l.RGBA, l.UNSIGNED_BYTE, e1.data);
                }
                this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D);
            }
            bind(t1, e1, i) {
                const { context: o } = this, { gl: a } = o;
                a.bindTexture(a.TEXTURE_2D, this.texture), i !== a.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i = a.LINEAR), t1 !== this.filter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, t1), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, i || t1), this.filter = t1), e1 !== this.wrap && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, e1), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, e1), this.wrap = e1);
            }
            isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        function c(t1) {
            const { userImage: e1 } = t1;
            return !!(e1 && e1.render && e1.render()) && (t1.data.replace(new Uint8Array(e1.data.buffer)), !0);
        }
        class h extends t1.Evented {
            constructor(){
                super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t1.RGBAImage({
                    width: 1,
                    height: 1
                }), this.dirty = !0;
            }
            isLoaded() {
                return this.loaded;
            }
            setLoaded(t1) {
                if (this.loaded !== t1 && (this.loaded = t1, t1)) {
                    for (const { ids: t1, callback: e1 } of this.requestors)this._notify(t1, e1);
                    this.requestors = [];
                }
            }
            getImage(t1) {
                return this.images[t1];
            }
            addImage(t1, e1) {
                if (this.images[t1]) throw new Error(`Image id ${t1} already exist, use updateImage instead`);
                this._validate(t1, e1) && (this.images[t1] = e1);
            }
            _validate(e1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t1.ErrorEvent(new Error(`Image "${e1}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t1.ErrorEvent(new Error(`Image "${e1}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new t1.ErrorEvent(new Error(`Image "${e1}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(t1, e1) {
                if (!t1) return !0;
                let i = 0;
                for (const o of t1){
                    if (o[0] < i || o[1] < o[0] || e1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(t1, e1) {
                return !(t1 && (4 !== t1.length || t1[0] < 0 || e1.data.width < t1[0] || t1[1] < 0 || e1.data.height < t1[1] || t1[2] < 0 || e1.data.width < t1[2] || t1[3] < 0 || e1.data.height < t1[3] || t1[2] < t1[0] || t1[3] < t1[1]));
            }
            updateImage(t1, e1) {
                const i = this.images[t1];
                if (i.data.width !== e1.data.width || i.data.height !== e1.data.height) throw new Error(`size mismatch between old image (${i.data.width}x${i.data.height}) and new image (${e1.data.width}x${e1.data.height}).`);
                e1.version = i.version + 1, this.images[t1] = e1, this.updatedImages[t1] = !0;
            }
            removeImage(t1) {
                const e1 = this.images[t1];
                delete this.images[t1], delete this.patterns[t1], e1.userImage && e1.userImage.onRemove && e1.userImage.onRemove();
            }
            listImages() {
                return Object.keys(this.images);
            }
            getImages(t1, e1) {
                let i = !0;
                if (!this.isLoaded()) for (const e1 of t1)this.images[e1] || (i = !1);
                this.isLoaded() || i ? this._notify(t1, e1) : this.requestors.push({
                    ids: t1,
                    callback: e1
                });
            }
            _notify(e1, i) {
                const o = {};
                for (const i of e1){
                    this.images[i] || this.fire(new t1.Event("styleimagemissing", {
                        id: i
                    }));
                    const e1 = this.images[i];
                    e1 ? o[i] = {
                        data: e1.data.clone(),
                        pixelRatio: e1.pixelRatio,
                        sdf: e1.sdf,
                        version: e1.version,
                        stretchX: e1.stretchX,
                        stretchY: e1.stretchY,
                        content: e1.content,
                        hasRenderCallback: Boolean(e1.userImage && e1.userImage.render)
                    } : t1.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                i(null, o);
            }
            getPixelSize() {
                const { width: t1, height: e1 } = this.atlasImage;
                return {
                    width: t1,
                    height: e1
                };
            }
            getPattern(e1) {
                const i = this.patterns[e1], o = this.getImage(e1);
                if (!o) return null;
                if (i && i.position.version === o.version) return i.position;
                if (i) i.position.version = o.version;
                else {
                    const i = {
                        w: o.data.width + 2,
                        h: o.data.height + 2,
                        x: 0,
                        y: 0
                    }, a = new t1.ImagePosition(i, o);
                    this.patterns[e1] = {
                        bin: i,
                        position: a
                    };
                }
                return this._updatePatternAtlas(), this.patterns[e1].position;
            }
            bind(t1) {
                const e1 = t1.gl;
                this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new l(t1, this.atlasImage, e1.RGBA), this.atlasTexture.bind(e1.LINEAR, e1.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
                const e1 = [];
                for(const t1 in this.patterns)e1.push(this.patterns[t1].bin);
                const { w: i, h: o } = t1.potpack(e1), a = this.atlasImage;
                a.resize({
                    width: i || 1,
                    height: o || 1
                });
                for(const e1 in this.patterns){
                    const { bin: i } = this.patterns[e1], o = i.x + 1, r = i.y + 1, s = this.images[e1].data, n = s.width, l = s.height;
                    t1.RGBAImage.copy(s, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: r
                    }, {
                        width: n,
                        height: l
                    }), t1.RGBAImage.copy(s, a, {
                        x: 0,
                        y: l - 1
                    }, {
                        x: o,
                        y: r - 1
                    }, {
                        width: n,
                        height: 1
                    }), t1.RGBAImage.copy(s, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: r + l
                    }, {
                        width: n,
                        height: 1
                    }), t1.RGBAImage.copy(s, a, {
                        x: n - 1,
                        y: 0
                    }, {
                        x: o - 1,
                        y: r
                    }, {
                        width: 1,
                        height: l
                    }), t1.RGBAImage.copy(s, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + n,
                        y: r
                    }, {
                        width: 1,
                        height: l
                    });
                }
                this.dirty = !0;
            }
            beginFrame() {
                this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e1) {
                for (const i of e1){
                    if (this.callbackDispatchedThisFrame[i]) continue;
                    this.callbackDispatchedThisFrame[i] = !0;
                    const e1 = this.images[i];
                    e1 || t1.warnOnce(`Image with ID: "${i}" was not found`), c(e1) && this.updateImage(i, e1);
                }
            }
        }
        const u = 1e20;
        function d(t1, e1, i, o, a, r, s, n, l) {
            for(let c = e1; c < e1 + o; c++)m(t1, i * r + c, r, a, s, n, l);
            for(let c = i; c < i + a; c++)m(t1, c * r + e1, 1, o, s, n, l);
        }
        function m(t1, e1, i, o, a, r, s) {
            r[0] = 0, s[0] = -u, s[1] = u, a[0] = t1[e1];
            for(let n = 1, l = 0, c = 0; n < o; n++){
                a[n] = t1[e1 + n * i];
                const o = n * n;
                do {
                    const t1 = r[l];
                    c = (a[n] - a[t1] + o - t1 * t1) / (n - t1) / 2;
                }while (c <= s[l] && --l > -1);
                l++, r[l] = n, s[l] = c, s[l + 1] = u;
            }
            for(let n = 0, l = 0; n < o; n++){
                for(; s[l + 1] < n;)l++;
                const o = r[l], c = n - o;
                t1[e1 + n * i] = a[o] + c * c;
            }
        }
        class _ {
            constructor(t1, e1){
                this.requestManager = t1, this.localIdeographFontFamily = e1, this.entries = {};
            }
            setURL(t1) {
                this.url = t1;
            }
            getGlyphs(e1, i) {
                const o = [];
                for(const t1 in e1)for (const i of e1[t1])o.push({
                    stack: t1,
                    id: i
                });
                t1.asyncAll(o, ({ stack: t1, id: e1 }, i)=>{
                    let o = this.entries[t1];
                    o || (o = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {}
                    });
                    let a = o.glyphs[e1];
                    if (void 0 !== a) return void i(null, {
                        stack: t1,
                        id: e1,
                        glyph: a
                    });
                    if (a = this._tinySDF(o, t1, e1), a) return o.glyphs[e1] = a, void i(null, {
                        stack: t1,
                        id: e1,
                        glyph: a
                    });
                    const r = Math.floor(e1 / 256);
                    if (256 * r > 65535) return void i(new Error("glyphs > 65535 not supported"));
                    if (o.ranges[r]) return void i(null, {
                        stack: t1,
                        id: e1,
                        glyph: a
                    });
                    let s = o.requests[r];
                    s || (s = o.requests[r] = [], _.loadGlyphRange(t1, r, this.url, this.requestManager, (t1, e1)=>{
                        if (e1) {
                            for(const t1 in e1)this._doesCharSupportLocalGlyph(+t1) || (o.glyphs[+t1] = e1[+t1]);
                            o.ranges[r] = !0;
                        }
                        for (const i of s)i(t1, e1);
                        delete o.requests[r];
                    })), s.push((o, a)=>{
                        o ? i(o) : a && i(null, {
                            stack: t1,
                            id: e1,
                            glyph: a[e1] || null
                        });
                    });
                }, (t1, e1)=>{
                    if (t1) i(t1);
                    else if (e1) {
                        const t1 = {};
                        for (const { stack: i, id: o, glyph: a } of e1)(t1[i] || (t1[i] = {}))[o] = a && {
                            id: a.id,
                            bitmap: a.bitmap.clone(),
                            metrics: a.metrics
                        };
                        i(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(e1) {
                return !!this.localIdeographFontFamily && (t1.unicodeBlockLookup["CJK Unified Ideographs"](e1) || t1.unicodeBlockLookup["Hangul Syllables"](e1) || t1.unicodeBlockLookup.Hiragana(e1) || t1.unicodeBlockLookup.Katakana(e1));
            }
            _tinySDF(e1, i, o) {
                const a = this.localIdeographFontFamily;
                if (!a) return;
                if (!this._doesCharSupportLocalGlyph(o)) return;
                let r = e1.tinySDF;
                if (!r) {
                    let t1 = "400";
                    /bold/i.test(i) ? t1 = "900" : /medium/i.test(i) ? t1 = "500" : /light/i.test(i) && (t1 = "200"), r = e1.tinySDF = new _.TinySDF({
                        fontSize: 24,
                        buffer: 3,
                        radius: 8,
                        cutoff: .25,
                        fontFamily: a,
                        fontWeight: t1
                    });
                }
                const s = r.draw(String.fromCharCode(o));
                return {
                    id: o,
                    bitmap: new t1.AlphaImage({
                        width: s.width || 30,
                        height: s.height || 30
                    }, s.data),
                    metrics: {
                        width: s.glyphWidth || 24,
                        height: s.glyphHeight || 24,
                        left: s.glyphLeft || 0,
                        top: s.glyphTop - 27 || -8,
                        advance: s.glyphAdvance || 24
                    }
                };
            }
        }
        _.loadGlyphRange = function(e1, i, o, a, r) {
            const s = 256 * i, n = s + 255, l = a.transformRequest(o.replace("{fontstack}", e1).replace("{range}", `${s}-${n}`), t1.ResourceType.Glyphs);
            t1.getArrayBuffer(l, (e1, i)=>{
                if (e1) r(e1);
                else if (i) {
                    const e1 = {};
                    for (const o of t1.parseGlyphPbf(i))e1[o.id] = o;
                    r(null, e1);
                }
            });
        }, _.TinySDF = class {
            constructor({ fontSize: t1 = 24, buffer: e1 = 3, radius: i = 8, cutoff: o = .25, fontFamily: a = "sans-serif", fontWeight: r = "normal", fontStyle: s = "normal" } = {}){
                this.buffer = e1, this.cutoff = o, this.radius = i;
                const n = this.size = t1 + 4 * e1, l = this._createCanvas(n), c = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                c.font = `${s} ${r} ${t1}px ${a}`, c.textBaseline = "alphabetic", c.textAlign = "left", c.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Uint16Array(n);
            }
            _createCanvas(t1) {
                const e1 = document.createElement("canvas");
                return e1.width = e1.height = t1, e1;
            }
            draw(t1) {
                const { width: e1, actualBoundingBoxAscent: i, actualBoundingBoxDescent: o, actualBoundingBoxLeft: a, actualBoundingBoxRight: r } = this.ctx.measureText(t1), s = Math.ceil(i), n = Math.min(this.size - this.buffer, Math.ceil(r - a)), l = Math.min(this.size - this.buffer, s + Math.ceil(o)), c = n + 2 * this.buffer, h = l + 2 * this.buffer, m = Math.max(c * h, 0), _ = new Uint8ClampedArray(m), p = {
                    data: _,
                    width: c,
                    height: h,
                    glyphWidth: n,
                    glyphHeight: l,
                    glyphTop: s,
                    glyphLeft: 0,
                    glyphAdvance: e1
                };
                if (0 === n || 0 === l) return p;
                const { ctx: f, buffer: g, gridInner: x, gridOuter: v } = this;
                f.clearRect(g, g, n, l), f.fillText(t1, g, g + s);
                const y = f.getImageData(g, g, n, l);
                v.fill(u, 0, m), x.fill(0, 0, m);
                for(let t1 = 0; t1 < l; t1++)for(let e1 = 0; e1 < n; e1++){
                    const i = y.data[4 * (t1 * n + e1) + 3] / 255;
                    if (0 === i) continue;
                    const o = (t1 + g) * c + e1 + g;
                    if (1 === i) v[o] = 0, x[o] = u;
                    else {
                        const t1 = .5 - i;
                        v[o] = t1 > 0 ? t1 * t1 : 0, x[o] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                d(v, 0, 0, c, h, c, this.f, this.v, this.z), d(x, g, g, n, l, c, this.f, this.v, this.z);
                for(let t1 = 0; t1 < m; t1++){
                    const e1 = Math.sqrt(v[t1]) - Math.sqrt(x[t1]);
                    _[t1] = Math.round(255 - 255 * (e1 / this.radius + this.cutoff));
                }
                return p;
            }
        };
        const p = new t1.Properties({
            anchor: new t1.DataConstantProperty(t1.spec.light.anchor),
            position: new class {
                constructor(){
                    this.specification = t1.spec.light.position;
                }
                possiblyEvaluate(e1, i) {
                    return t1.sphericalToCartesian(e1.expression.evaluate(i));
                }
                interpolate(e1, i, o) {
                    return {
                        x: t1.number(e1.x, i.x, o),
                        y: t1.number(e1.y, i.y, o),
                        z: t1.number(e1.z, i.z, o)
                    };
                }
            },
            color: new t1.DataConstantProperty(t1.spec.light.color),
            intensity: new t1.DataConstantProperty(t1.spec.light.intensity)
        }), f = "-transition";
        class g extends t1.Evented {
            constructor(e1){
                super(), this._transitionable = new t1.Transitionable(p), this.setLight(e1), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(e1, i = {}) {
                if (!this._validate(t1.validateLight, e1, i)) for(const t1 in e1){
                    const i = e1[t1];
                    t1.endsWith(f) ? this._transitionable.setTransition(t1.slice(0, -f.length), i) : this._transitionable.setValue(t1, i);
                }
            }
            updateTransitions(t1) {
                this._transitioning = this._transitionable.transitioned(t1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(t1) {
                this.properties = this._transitioning.possiblyEvaluate(t1);
            }
            _validate(e1, i, o) {
                return (!o || !1 !== o.validate) && t1.emitValidationErrors(this, e1.call(t1.validateStyle, t1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: t1.spec
                })));
            }
        }
        class x {
            constructor(t1, e1){
                this.width = t1, this.height = e1, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(t1, e1) {
                const i = t1.join(",") + String(e1);
                return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t1, e1)), this.dashEntry[i];
            }
            getDashRanges(t1, e1, i) {
                const o = [];
                let a = t1.length % 2 == 1 ? -t1[t1.length - 1] * i : 0, r = t1[0] * i, s = !0;
                o.push({
                    left: a,
                    right: r,
                    isDash: s,
                    zeroLength: 0 === t1[0]
                });
                let n = t1[0];
                for(let e1 = 1; e1 < t1.length; e1++){
                    s = !s;
                    const l = t1[e1];
                    a = n * i, n += l, r = n * i, o.push({
                        left: a,
                        right: r,
                        isDash: s,
                        zeroLength: 0 === l
                    });
                }
                return o;
            }
            addRoundDash(t1, e1, i) {
                const o = e1 / 2;
                for(let e1 = -i; e1 <= i; e1++){
                    const a = this.width * (this.nextRow + i + e1);
                    let r = 0, s = t1[r];
                    for(let n = 0; n < this.width; n++){
                        n / s.right > 1 && (s = t1[++r]);
                        const l = Math.abs(n - s.left), c = Math.abs(n - s.right), h = Math.min(l, c);
                        let u;
                        const d = e1 / i * (o + 1);
                        if (s.isDash) {
                            const t1 = o - Math.abs(d);
                            u = Math.sqrt(h * h + t1 * t1);
                        } else u = o - Math.sqrt(h * h + d * d);
                        this.data[a + n] = Math.max(0, Math.min(255, u + 128));
                    }
                }
            }
            addRegularDash(t1) {
                for(let e1 = t1.length - 1; e1 >= 0; --e1){
                    const i = t1[e1], o = t1[e1 + 1];
                    i.zeroLength ? t1.splice(e1, 1) : o && o.isDash === i.isDash && (o.left = i.left, t1.splice(e1, 1));
                }
                const e1 = t1[0], i = t1[t1.length - 1];
                e1.isDash === i.isDash && (e1.left = i.left - this.width, i.right = e1.right + this.width);
                const o = this.width * this.nextRow;
                let a = 0, r = t1[a];
                for(let e1 = 0; e1 < this.width; e1++){
                    e1 / r.right > 1 && (r = t1[++a]);
                    const i = Math.abs(e1 - r.left), s = Math.abs(e1 - r.right), n = Math.min(i, s);
                    this.data[o + e1] = Math.max(0, Math.min(255, (r.isDash ? n : -n) + 128));
                }
            }
            addDash(e1, i) {
                const o = i ? 7 : 0, a = 2 * o + 1;
                if (this.nextRow + a > this.height) return t1.warnOnce("LineAtlas out of space"), null;
                let r = 0;
                for(let t1 = 0; t1 < e1.length; t1++)r += e1[t1];
                if (0 !== r) {
                    const t1 = this.width / r, a = this.getDashRanges(e1, this.width, t1);
                    i ? this.addRoundDash(a, t1, o) : this.addRegularDash(a);
                }
                const s = {
                    y: (this.nextRow + o + .5) / this.height,
                    height: 2 * o / this.height,
                    width: r
                };
                return this.nextRow += a, this.dirty = !0, s;
            }
            bind(t1) {
                const e1 = t1.gl;
                this.texture ? (e1.bindTexture(e1.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e1.texSubImage2D(e1.TEXTURE_2D, 0, 0, 0, this.width, this.height, e1.ALPHA, e1.UNSIGNED_BYTE, this.data))) : (this.texture = e1.createTexture(), e1.bindTexture(e1.TEXTURE_2D, this.texture), e1.texParameteri(e1.TEXTURE_2D, e1.TEXTURE_WRAP_S, e1.REPEAT), e1.texParameteri(e1.TEXTURE_2D, e1.TEXTURE_WRAP_T, e1.REPEAT), e1.texParameteri(e1.TEXTURE_2D, e1.TEXTURE_MIN_FILTER, e1.LINEAR), e1.texParameteri(e1.TEXTURE_2D, e1.TEXTURE_MAG_FILTER, e1.LINEAR), e1.texImage2D(e1.TEXTURE_2D, 0, e1.ALPHA, this.width, this.height, 0, e1.ALPHA, e1.UNSIGNED_BYTE, this.data));
            }
        }
        class v {
            constructor(e1, i){
                this.workerPool = e1, this.actors = [], this.currentActor = 0, this.id = t1.uniqueId();
                const o = this.workerPool.acquire(this.id);
                for(let t1 = 0; t1 < o.length; t1++){
                    const e1 = new v.Actor(o[t1], i, this.id);
                    e1.name = `Worker ${t1}`, this.actors.push(e1);
                }
                if (!this.actors.length) throw new Error("No actors found");
            }
            broadcast(e1, i, o) {
                t1.asyncAll(this.actors, (t1, o)=>{
                    t1.send(e1, i, o);
                }, o = o || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((t1)=>{
                    t1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        function y(e1, i, o) {
            const a = function(i, a) {
                if (i) return o(i);
                if (a) {
                    const i = t1.pick(t1.extend(a, e1), [
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "bounds",
                        "scheme",
                        "tileSize",
                        "encoding"
                    ]);
                    a.vector_layers && (i.vectorLayers = a.vector_layers, i.vectorLayerIds = i.vectorLayers.map((t1)=>t1.id)), o(null, i);
                }
            };
            return e1.url ? t1.getJSON(i.transformRequest(e1.url, t1.ResourceType.Source), a) : t1.exported.frame(()=>a(null, e1));
        }
        v.Actor = t1.Actor;
        class b {
            constructor(e1, i, o){
                this.bounds = t1.LngLatBounds.convert(this.validateBounds(e1)), this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(t1) {
                return Array.isArray(t1) && 4 === t1.length ? [
                    Math.max(-180, t1[0]),
                    Math.max(-90, t1[1]),
                    Math.min(180, t1[2]),
                    Math.min(90, t1[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            contains(e1) {
                const i = Math.pow(2, e1.z), o = Math.floor(t1.mercatorXfromLng(this.bounds.getWest()) * i), a = Math.floor(t1.mercatorYfromLat(this.bounds.getNorth()) * i), r = Math.ceil(t1.mercatorXfromLng(this.bounds.getEast()) * i), s = Math.ceil(t1.mercatorYfromLat(this.bounds.getSouth()) * i);
                return e1.x >= o && e1.x < r && e1.y >= a && e1.y < s;
            }
        }
        class w extends t1.Evented {
            constructor(e1, i, o, a){
                if (super(), this.id = e1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t1.extend(this, t1.pick(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = t1.extend({
                    type: "vector"
                }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(a);
            }
            load() {
                this._loaded = !1, this.fire(new t1.Event("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = y(this._options, this.map._requestManager, (e1, i)=>{
                    this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e1 ? this.fire(new t1.ErrorEvent(e1)) : i && (t1.extend(this, i), i.bounds && (this.tileBounds = new b(i.bounds, this.minzoom, this.maxzoom)), this.fire(new t1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new t1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    })));
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(t1) {
                return !this.tileBounds || this.tileBounds.contains(t1.canonical);
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            setSourceProperty(t1) {
                this._tileJSONRequest && this._tileJSONRequest.cancel(), t1(), this.load();
            }
            setTiles(t1) {
                return this.setSourceProperty(()=>{
                    this._options.tiles = t1;
                }), this;
            }
            setUrl(t1) {
                return this.setSourceProperty(()=>{
                    this.url = t1, this._options.url = t1;
                }), this;
            }
            onRemove() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
                return t1.extend({}, this._options);
            }
            loadTile(e1, i) {
                const o = e1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a = {
                    request: this.map._requestManager.transformRequest(o, t1.ResourceType.Tile),
                    uid: e1.uid,
                    tileID: e1.tileID,
                    zoom: e1.tileID.overscaledZ,
                    tileSize: this.tileSize * e1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    pixelRatio: this.map.getPixelRatio(),
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId
                };
                function r(o, a) {
                    return delete e1.request, e1.aborted ? i(null) : o && 404 !== o.status ? i(o) : (a && a.resourceTiming && (e1.resourceTiming = a.resourceTiming), this.map._refreshExpiredTiles && a && e1.setExpiryData(a), e1.loadVectorData(a, this.map.painter), t1.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (e1.reloadCallback && (this.loadTile(e1, e1.reloadCallback), e1.reloadCallback = null)));
                }
                a.request.collectResourceTiming = this._collectResourceTiming, e1.actor && "expired" !== e1.state ? "loading" === e1.state ? e1.reloadCallback = i : e1.request = e1.actor.send("reloadTile", a, r.bind(this)) : (e1.actor = this.dispatcher.getActor(), e1.request = e1.actor.send("loadTile", a, r.bind(this)));
            }
            abortTile(t1) {
                t1.request && (t1.request.cancel(), delete t1.request), t1.actor && t1.actor.send("abortTile", {
                    uid: t1.uid,
                    type: this.type,
                    source: this.id
                }, void 0);
            }
            unloadTile(t1) {
                t1.unloadVectorData(), t1.actor && t1.actor.send("removeTile", {
                    uid: t1.uid,
                    type: this.type,
                    source: this.id
                }, void 0);
            }
            hasTransition() {
                return !1;
            }
        }
        class T extends t1.Evented {
            constructor(e1, i, o, a){
                super(), this.id = e1, this.dispatcher = o, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t1.extend({
                    type: "raster"
                }, i), t1.extend(this, t1.pick(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load() {
                this._loaded = !1, this.fire(new t1.Event("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = y(this._options, this.map._requestManager, (e1, i)=>{
                    this._tileJSONRequest = null, this._loaded = !0, e1 ? this.fire(new t1.ErrorEvent(e1)) : i && (t1.extend(this, i), i.bounds && (this.tileBounds = new b(i.bounds, this.minzoom, this.maxzoom)), this.fire(new t1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new t1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    })));
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            onRemove() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
                return t1.extend({}, this._options);
            }
            hasTile(t1) {
                return !this.tileBounds || this.tileBounds.contains(t1.canonical);
            }
            loadTile(e1, i) {
                const o = e1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                e1.request = t1.getImage(this.map._requestManager.transformRequest(o, t1.ResourceType.Tile), (o, a, r)=>{
                    if (delete e1.request, e1.aborted) e1.state = "unloaded", i(null);
                    else if (o) e1.state = "errored", i(o);
                    else if (a) {
                        this.map._refreshExpiredTiles && e1.setExpiryData(r);
                        const o = this.map.painter.context, s = o.gl;
                        e1.texture = this.map.painter.getTileTexture(a.width), e1.texture ? e1.texture.update(a, {
                            useMipmap: !0
                        }) : (e1.texture = new l(o, a, s.RGBA, {
                            useMipmap: !0
                        }), e1.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), o.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, o.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o.extTextureFilterAnisotropicMax)), e1.state = "loaded", t1.cacheEntryPossiblyAdded(this.dispatcher), i(null);
                    }
                });
            }
            abortTile(t1, e1) {
                t1.request && (t1.request.cancel(), delete t1.request), e1();
            }
            unloadTile(t1, e1) {
                t1.texture && this.map.painter.saveTileTexture(t1.texture), e1();
            }
            hasTransition() {
                return !1;
            }
        }
        let E;
        class I extends T {
            constructor(e1, i, o, a){
                super(e1, i, o, a), this.type = "raster-dem", this.maxzoom = 22, this._options = t1.extend({
                    type: "raster-dem"
                }, i), this.encoding = i.encoding || "mapbox";
            }
            serialize() {
                return {
                    type: "raster-dem",
                    url: this.url,
                    tileSize: this.tileSize,
                    tiles: this.tiles,
                    bounds: this.bounds,
                    encoding: this.encoding
                };
            }
            loadTile(e1, i) {
                const o = e1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                function a(t1, o) {
                    t1 && (e1.state = "errored", i(t1)), o && (e1.dem = o, e1.needsHillshadePrepare = !0, e1.needsTerrainPrepare = !0, e1.state = "loaded", i(null));
                }
                e1.request = t1.getImage(this.map._requestManager.transformRequest(o, t1.ResourceType.Tile), (function(o, r) {
                    if (delete e1.request, e1.aborted) e1.state = "unloaded", i(null);
                    else if (o) e1.state = "errored", i(o);
                    else if (r) {
                        this.map._refreshExpiredTiles && e1.setExpiryData(r), delete r.cacheControl, delete r.expires;
                        const i = t1.isImageBitmap(r) && (null == E && (E = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), E) ? r : t1.exported.getImageData(r, 1), o = {
                            uid: e1.uid,
                            coord: e1.tileID,
                            source: this.id,
                            rawImageData: i,
                            encoding: this.encoding
                        };
                        e1.actor && "expired" !== e1.state || (e1.actor = this.dispatcher.getActor(), e1.actor.send("loadDEMTile", o, a.bind(this)));
                    }
                }).bind(this)), e1.neighboringTiles = this._getNeighboringTiles(e1.tileID);
            }
            _getNeighboringTiles(e1) {
                const i = e1.canonical, o = Math.pow(2, i.z), a = (i.x - 1 + o) % o, r = 0 === i.x ? e1.wrap - 1 : e1.wrap, s = (i.x + 1 + o) % o, n = i.x + 1 === o ? e1.wrap + 1 : e1.wrap, l = {};
                return l[new t1.OverscaledTileID(e1.overscaledZ, r, i.z, a, i.y).key] = {
                    backfilled: !1
                }, l[new t1.OverscaledTileID(e1.overscaledZ, n, i.z, s, i.y).key] = {
                    backfilled: !1
                }, i.y > 0 && (l[new t1.OverscaledTileID(e1.overscaledZ, r, i.z, a, i.y - 1).key] = {
                    backfilled: !1
                }, l[new t1.OverscaledTileID(e1.overscaledZ, e1.wrap, i.z, i.x, i.y - 1).key] = {
                    backfilled: !1
                }, l[new t1.OverscaledTileID(e1.overscaledZ, n, i.z, s, i.y - 1).key] = {
                    backfilled: !1
                }), i.y + 1 < o && (l[new t1.OverscaledTileID(e1.overscaledZ, r, i.z, a, i.y + 1).key] = {
                    backfilled: !1
                }, l[new t1.OverscaledTileID(e1.overscaledZ, e1.wrap, i.z, i.x, i.y + 1).key] = {
                    backfilled: !1
                }, l[new t1.OverscaledTileID(e1.overscaledZ, n, i.z, s, i.y + 1).key] = {
                    backfilled: !1
                }), l;
            }
            unloadTile(t1) {
                t1.demTexture && this.map.painter.saveTileTexture(t1.demTexture), t1.fbo && (t1.fbo.destroy(), delete t1.fbo), t1.dem && delete t1.dem, delete t1.neighboringTiles, t1.state = "unloaded", t1.actor && t1.actor.send("removeDEMTile", {
                    uid: t1.uid,
                    source: this.id
                });
            }
        }
        class C extends t1.Evented {
            constructor(e1, i, o, a){
                super(), this.id = e1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = o.getActor(), this.setEventedParent(a), this._data = i.data, this._options = t1.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                const r = t1.EXTENT / this.tileSize;
                this.workerOptions = t1.extend({
                    source: this.id,
                    cluster: i.cluster || !1,
                    geojsonVtOptions: {
                        buffer: (void 0 !== i.buffer ? i.buffer : 128) * r,
                        tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * r,
                        extent: t1.EXTENT,
                        maxZoom: this.maxzoom,
                        lineMetrics: i.lineMetrics || !1,
                        generateId: i.generateId || !1
                    },
                    superclusterOptions: {
                        maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                        minPoints: Math.max(2, i.clusterMinPoints || 2),
                        extent: t1.EXTENT,
                        radius: (i.clusterRadius || 50) * r,
                        log: !1,
                        generateId: i.generateId || !1
                    },
                    clusterProperties: i.clusterProperties,
                    filter: i.filter
                }, i.workerOptions);
            }
            load() {
                this._updateWorkerData("metadata");
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            setData(t1) {
                return this._data = t1, this._updateWorkerData("content"), this;
            }
            getClusterExpansionZoom(t1, e1) {
                return this.actor.send("geojson.getClusterExpansionZoom", {
                    clusterId: t1,
                    source: this.id
                }, e1), this;
            }
            getClusterChildren(t1, e1) {
                return this.actor.send("geojson.getClusterChildren", {
                    clusterId: t1,
                    source: this.id
                }, e1), this;
            }
            getClusterLeaves(t1, e1, i, o) {
                return this.actor.send("geojson.getClusterLeaves", {
                    source: this.id,
                    clusterId: t1,
                    limit: e1,
                    offset: i
                }, o), this;
            }
            _updateWorkerData(e1) {
                const i = t1.extend({}, this.workerOptions), o = this._data;
                "string" == typeof o ? (i.request = this.map._requestManager.transformRequest(t1.exported.resolveURL(o), t1.ResourceType.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoads++, this.fire(new t1.Event("dataloading", {
                    dataType: "source"
                })), this.actor.send(`${this.type}.loadData`, i, (i, o)=>{
                    if (this._pendingLoads--, this._removed || o && o.abandoned) return void this.fire(new t1.Event("dataabort", {
                        dataType: "source",
                        sourceDataType: e1
                    }));
                    let a = null;
                    if (o && o.resourceTiming && o.resourceTiming[this.id] && (a = o.resourceTiming[this.id].slice(0)), i) return void this.fire(new t1.ErrorEvent(i));
                    const r = {
                        dataType: "source",
                        sourceDataType: e1
                    };
                    this._collectResourceTiming && a && a.length > 0 && t1.extend(r, {
                        resourceTiming: a
                    }), this.fire(new t1.Event("data", r));
                });
            }
            loaded() {
                return 0 === this._pendingLoads;
            }
            loadTile(t1, e1) {
                const i = t1.actor ? "reloadTile" : "loadTile";
                t1.actor = this.actor;
                const o = {
                    type: this.type,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    zoom: t1.tileID.overscaledZ,
                    maxZoom: this.maxzoom,
                    tileSize: this.tileSize,
                    source: this.id,
                    pixelRatio: this.map.getPixelRatio(),
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId
                };
                t1.request = this.actor.send(i, o, (o, a)=>(delete t1.request, t1.unloadVectorData(), t1.aborted ? e1(null) : o ? e1(o) : (t1.loadVectorData(a, this.map.painter, "reloadTile" === i), e1(null))));
            }
            abortTile(t1) {
                t1.request && (t1.request.cancel(), delete t1.request), t1.aborted = !0;
            }
            unloadTile(t1) {
                t1.unloadVectorData(), this.actor.send("removeTile", {
                    uid: t1.uid,
                    type: this.type,
                    source: this.id
                });
            }
            onRemove() {
                this._removed = !0, this.actor.send("removeSource", {
                    type: this.type,
                    source: this.id
                });
            }
            serialize() {
                return t1.extend({}, this._options, {
                    type: this.type,
                    data: this._data
                });
            }
            hasTransition() {
                return !1;
            }
        }
        var S = t1.createLayout([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        class D extends t1.Evented {
            constructor(t1, e1, i, o){
                super(), this.id = t1, this.dispatcher = i, this.coordinates = e1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = e1;
            }
            load(e1, i) {
                this._loaded = !1, this.fire(new t1.Event("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, t1.getImage(this.map._requestManager.transformRequest(this.url, t1.ResourceType.Image), (o, a)=>{
                    this._loaded = !0, o ? this.fire(new t1.ErrorEvent(o)) : a && (this.image = a, e1 && (this.coordinates = e1), i && i(), this._finishLoading());
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(t1) {
                return this.image && t1.url ? (this.options.url = t1.url, this.load(t1.coordinates, ()=>{
                    this.texture = null;
                }), this) : this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new t1.Event("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            setCoordinates(e1) {
                this.coordinates = e1;
                const i = e1.map(t1.MercatorCoordinate.fromLngLat);
                this.tileID = function(e1) {
                    let i = 1 / 0, o = 1 / 0, a = -1 / 0, r = -1 / 0;
                    for (const t1 of e1)i = Math.min(i, t1.x), o = Math.min(o, t1.y), a = Math.max(a, t1.x), r = Math.max(r, t1.y);
                    const s = Math.max(a - i, r - o), n = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)), l = Math.pow(2, n);
                    return new t1.CanonicalTileID(n, Math.floor((i + a) / 2 * l), Math.floor((o + r) / 2 * l));
                }(i), this.minzoom = this.maxzoom = this.tileID.z;
                const o = i.map((t1)=>this.tileID.getTilePoint(t1)._round());
                return this._boundsArray = new t1.RasterBoundsArray, this._boundsArray.emplaceBack(o[0].x, o[0].y, 0, 0), this._boundsArray.emplaceBack(o[1].x, o[1].y, t1.EXTENT, 0), this._boundsArray.emplaceBack(o[3].x, o[3].y, 0, t1.EXTENT), this._boundsArray.emplaceBack(o[2].x, o[2].y, t1.EXTENT, t1.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t1.Event("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const e1 = this.map.painter.context, i = e1.gl;
                this.boundsBuffer || (this.boundsBuffer = e1.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new l(e1, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                for(const t1 in this.tiles){
                    const e1 = this.tiles[t1];
                    "loaded" !== e1.state && (e1.state = "loaded", e1.texture = this.texture);
                }
            }
            loadTile(t1, e1) {
                this.tileID && this.tileID.equals(t1.tileID.canonical) ? (this.tiles[String(t1.tileID.wrap)] = t1, t1.buckets = {}, e1(null)) : (t1.state = "errored", e1(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
        }
        class z extends D {
            constructor(t1, e1, i, o){
                super(t1, e1, i, o), this.roundZoom = !0, this.type = "video", this.options = e1;
            }
            load() {
                this._loaded = !1;
                const e1 = this.options;
                this.urls = [];
                for (const i of e1.urls)this.urls.push(this.map._requestManager.transformRequest(i, t1.ResourceType.Source).url);
                t1.getVideo(this.urls, (e1, i)=>{
                    this._loaded = !0, e1 ? this.fire(new t1.ErrorEvent(e1)) : i && (this.video = i, this.video.loop = !0, this.video.addEventListener("playing", ()=>{
                        this.map.triggerRepaint();
                    }), this.map && this.video.play(), this._finishLoading());
                });
            }
            pause() {
                this.video && this.video.pause();
            }
            play() {
                this.video && this.video.play();
            }
            seek(e1) {
                if (this.video) {
                    const i = this.video.seekable;
                    e1 < i.start(0) || e1 > i.end(0) ? this.fire(new t1.ErrorEvent(new t1.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e1;
                }
            }
            getVideo() {
                return this.video;
            }
            onAdd(t1) {
                this.map || (this.map = t1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                const e1 = this.map.painter.context, i = e1.gl;
                this.boundsBuffer || (this.boundsBuffer = e1.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new l(e1, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                for(const t1 in this.tiles){
                    const e1 = this.tiles[t1];
                    "loaded" !== e1.state && (e1.state = "loaded", e1.texture = this.texture);
                }
            }
            serialize() {
                return {
                    type: "video",
                    urls: this.urls,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return this.video && !this.video.paused;
            }
        }
        class P extends D {
            constructor(e1, i, o, a){
                super(e1, i, o, a), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((t1)=>!Array.isArray(t1) || 2 !== t1.length || t1.some((t1)=>"number" != typeof t1)) || this.fire(new t1.ErrorEvent(new t1.ValidationError(`sources.${e1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t1.ErrorEvent(new t1.ValidationError(`sources.${e1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new t1.ErrorEvent(new t1.ValidationError(`sources.${e1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new t1.ErrorEvent(new t1.ValidationError(`sources.${e1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t1.ErrorEvent(new t1.ValidationError(`sources.${e1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
            }
            load() {
                this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t1.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                    this._playing = !0, this.map.triggerRepaint();
                }, this.pause = function() {
                    this._playing && (this.prepare(), this._playing = !1);
                }, this._finishLoading());
            }
            getCanvas() {
                return this.canvas;
            }
            onAdd(t1) {
                this.map = t1, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
                this.pause();
            }
            prepare() {
                let e1 = !1;
                if (this.canvas.width !== this.width && (this.width = this.canvas.width, e1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e1 = !0), this._hasInvalidDimensions()) return;
                if (0 === Object.keys(this.tiles).length) return;
                const i = this.map.painter.context, o = i.gl;
                this.boundsBuffer || (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e1 || this._playing) && this.texture.update(this.canvas, {
                    premultiply: !0
                }) : this.texture = new l(i, this.canvas, o.RGBA, {
                    premultiply: !0
                });
                for(const t1 in this.tiles){
                    const e1 = this.tiles[t1];
                    "loaded" !== e1.state && (e1.state = "loaded", e1.texture = this.texture);
                }
            }
            serialize() {
                return {
                    type: "canvas",
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return this._playing;
            }
            _hasInvalidDimensions() {
                for (const t1 of [
                    this.canvas.width,
                    this.canvas.height
                ])if (isNaN(t1) || t1 <= 0) return !0;
                return !1;
            }
        }
        const M = {
            vector: w,
            raster: T,
            "raster-dem": I,
            geojson: C,
            video: z,
            image: D,
            canvas: P
        };
        function A(e1, i) {
            const o = t1.create();
            return t1.translate(o, o, [
                1,
                1,
                0
            ]), t1.scale(o, o, [
                .5 * e1.width,
                .5 * e1.height,
                1
            ]), t1.multiply(o, o, e1.calculatePosMatrix(i.toUnwrapped()));
        }
        function L(t1, e1, i, o, a, r) {
            const s = function(t1, e1, i) {
                if (t1) for (const o of t1){
                    const t1 = e1[o];
                    if (t1 && t1.source === i && "fill-extrusion" === t1.type) return !0;
                }
                else for(const t1 in e1){
                    const o = e1[t1];
                    if (o.source === i && "fill-extrusion" === o.type) return !0;
                }
                return !1;
            }(a && a.layers, e1, t1.id), n = r.maxPitchScaleFactor(), l = t1.tilesIn(o, n, s);
            l.sort(R);
            const c = [];
            for (const o of l)c.push({
                wrappedTileID: o.tileID.wrapped().key,
                queryResults: o.tile.queryRenderedFeatures(e1, i, t1._state, o.queryGeometry, o.cameraQueryGeometry, o.scale, a, r, n, A(t1.transform, o.tileID))
            });
            const h = function(t1) {
                const e1 = {}, i = {};
                for (const o of t1){
                    const t1 = o.queryResults, a = o.wrappedTileID, r = i[a] = i[a] || {};
                    for(const i in t1){
                        const o = t1[i], a = r[i] = r[i] || {}, s = e1[i] = e1[i] || [];
                        for (const t1 of o)a[t1.featureIndex] || (a[t1.featureIndex] = !0, s.push(t1));
                    }
                }
                return e1;
            }(c);
            for(const e1 in h)h[e1].forEach((e1)=>{
                const i = e1.feature, o = t1.getFeatureState(i.layer["source-layer"], i.id);
                i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = o;
            });
            return h;
        }
        function R(t1, e1) {
            const i = t1.tileID, o = e1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        class k {
            constructor(e1, i){
                this.tileID = e1, this.uid = t1.uniqueId(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.textures = [], this.textureCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(e1) {
                const i = e1 + this.timeAdded;
                i < t1.exported.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            clearTextures(t1) {
                this.demTexture && t1.saveTileTexture(this.demTexture), this.textures.forEach((e1)=>t1.saveTileTexture(e1)), this.demTexture = null, this.textures = [], this.textureCoords = {};
            }
            loadVectorData(e1, i, o) {
                if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e1) {
                    e1.featureIndex && (this.latestFeatureIndex = e1.featureIndex, e1.rawTileData ? (this.latestRawTileData = e1.rawTileData, this.latestFeatureIndex.rawTileData = e1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e1.collisionBoxArray, this.buckets = function(t1, e1) {
                        const i = {};
                        if (!e1) return i;
                        for (const o of t1){
                            const t1 = o.layerIds.map((t1)=>e1.getLayer(t1)).filter(Boolean);
                            if (0 !== t1.length) {
                                o.layers = t1, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map((e1)=>t1.filter((t1)=>t1.id === e1)[0]));
                                for (const e1 of t1)i[e1.id] = o;
                            }
                        }
                        return i;
                    }(e1.buckets, i.style), this.hasSymbolBuckets = !1;
                    for(const e1 in this.buckets){
                        const i = this.buckets[e1];
                        if (i instanceof t1.SymbolBucket) {
                            if (this.hasSymbolBuckets = !0, !o) break;
                            i.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const e1 in this.buckets){
                        const i = this.buckets[e1];
                        if (i instanceof t1.SymbolBucket && i.hasRTLText) {
                            this.hasRTLText = !0, t1.lazyLoadRTLTextPlugin();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const t1 in this.buckets){
                        const e1 = this.buckets[t1];
                        this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(t1).queryRadius(e1));
                    }
                    e1.imageAtlas && (this.imageAtlas = e1.imageAtlas), e1.glyphAtlasImage && (this.glyphAtlasImage = e1.glyphAtlasImage);
                } else this.collisionBoxArray = new t1.CollisionBoxArray;
            }
            unloadVectorData() {
                for(const t1 in this.buckets)this.buckets[t1].destroy();
                this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(t1) {
                return this.buckets[t1.id];
            }
            upload(t1) {
                for(const e1 in this.buckets){
                    const i = this.buckets[e1];
                    i.uploadPending() && i.upload(t1);
                }
                const e1 = t1.gl;
                this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new l(t1, this.imageAtlas.image, e1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new l(t1, this.glyphAtlasImage, e1.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(t1) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t1, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t1, e1, i, o, a, r, s, n, l, c) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                    queryGeometry: o,
                    cameraQueryGeometry: a,
                    scale: r,
                    tileSize: this.tileSize,
                    pixelPosMatrix: c,
                    transform: n,
                    params: s,
                    queryPadding: this.queryPadding * l
                }, t1, e1, i) : {};
            }
            querySourceFeatures(e1, i) {
                const o = this.latestFeatureIndex;
                if (!o || !o.rawTileData) return;
                const a = o.loadVTLayers(), r = i ? i.sourceLayer : "", s = a._geojsonTileLayer || a[r];
                if (!s) return;
                const n = t1.createFilter(i && i.filter), { z: l, x: c, y: h } = this.tileID.canonical, u = {
                    z: l,
                    x: c,
                    y: h
                };
                for(let i = 0; i < s.length; i++){
                    const a = s.feature(i);
                    if (n.needGeometry) {
                        const e1 = t1.toEvaluationFeature(a, !0);
                        if (!n.filter(new t1.EvaluationParameters(this.tileID.overscaledZ), e1, this.tileID.canonical)) continue;
                    } else if (!n.filter(new t1.EvaluationParameters(this.tileID.overscaledZ), a)) continue;
                    const d = o.getId(a, r), m = new t1.GeoJSONFeature(a, l, c, h, d);
                    m.tile = u, e1.push(m);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e1) {
                const i = this.expirationTime;
                if (e1.cacheControl) {
                    const i = t1.parseCacheControl(e1.cacheControl);
                    i["max-age"] && (this.expirationTime = Date.now() + 1e3 * i["max-age"]);
                } else e1.expires && (this.expirationTime = new Date(e1.expires).getTime());
                if (this.expirationTime) {
                    const t1 = Date.now();
                    let e1 = !1;
                    if (this.expirationTime > t1) e1 = !1;
                    else if (i) {
                        if (this.expirationTime < i) e1 = !0;
                        else {
                            const o = this.expirationTime - i;
                            o ? this.expirationTime = t1 + Math.max(o, 3e4) : e1 = !0;
                        }
                    } else e1 = !0;
                    e1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t1, e1) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t1).length) return;
                const i = this.latestFeatureIndex.loadVTLayers();
                for(const o in this.buckets){
                    if (!e1.style.hasLayer(o)) continue;
                    const a = this.buckets[o], r = a.layers[0].sourceLayer || "_geojsonTileLayer", s = i[r], n = t1[r];
                    if (!s || !n || 0 === Object.keys(n).length) continue;
                    a.update(n, s, this.imageAtlas && this.imageAtlas.patternPositions || {});
                    const l = e1 && e1.style && e1.style.getLayer(o);
                    l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(a)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t1.exported.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e1) {
                this.symbolFadeHoldUntil = t1.exported.now() + e1;
            }
            setDependencies(t1, e1) {
                const i = {};
                for (const t1 of e1)i[t1] = !0;
                this.dependencies[t1] = i;
            }
            hasDependency(t1, e1) {
                for (const i of t1){
                    const t1 = this.dependencies[i];
                    if (t1) {
                        for (const i of e1)if (t1[i]) return !0;
                    }
                }
                return !1;
            }
        }
        class B {
            constructor(t1, e1){
                this.max = t1, this.onRemove = e1, this.reset();
            }
            reset() {
                for(const t1 in this.data)for (const e1 of this.data[t1])e1.timeout && clearTimeout(e1.timeout), this.onRemove(e1.value);
                return this.data = {}, this.order = [], this;
            }
            add(t1, e1, i) {
                const o = t1.wrapped().key;
                void 0 === this.data[o] && (this.data[o] = []);
                const a = {
                    value: e1,
                    timeout: void 0
                };
                if (void 0 !== i && (a.timeout = setTimeout(()=>{
                    this.remove(t1, a);
                }, i)), this.data[o].push(a), this.order.push(o), this.order.length > this.max) {
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            has(t1) {
                return t1.wrapped().key in this.data;
            }
            getAndRemove(t1) {
                return this.has(t1) ? this._getAndRemoveByKey(t1.wrapped().key) : null;
            }
            _getAndRemoveByKey(t1) {
                const e1 = this.data[t1].shift();
                return e1.timeout && clearTimeout(e1.timeout), 0 === this.data[t1].length && delete this.data[t1], this.order.splice(this.order.indexOf(t1), 1), e1.value;
            }
            getByKey(t1) {
                const e1 = this.data[t1];
                return e1 ? e1[0].value : null;
            }
            get(t1) {
                return this.has(t1) ? this.data[t1.wrapped().key][0].value : null;
            }
            remove(t1, e1) {
                if (!this.has(t1)) return this;
                const i = t1.wrapped().key, o = void 0 === e1 ? 0 : this.data[i].indexOf(e1), a = this.data[i][o];
                return this.data[i].splice(o, 1), a.timeout && clearTimeout(a.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(a.value), this.order.splice(this.order.indexOf(i), 1), this;
            }
            setMaxSize(t1) {
                for(this.max = t1; this.order.length > this.max;){
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            filter(t1) {
                const e1 = [];
                for(const i in this.data)for (const o of this.data[i])t1(o.value) || e1.push(o);
                for (const t1 of e1)this.remove(t1.value.tileID, t1);
            }
        }
        class F {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e1, i, o) {
                const a = String(i);
                if (this.stateChanges[e1] = this.stateChanges[e1] || {}, this.stateChanges[e1][a] = this.stateChanges[e1][a] || {}, t1.extend(this.stateChanges[e1][a], o), null === this.deletedStates[e1]) {
                    this.deletedStates[e1] = {};
                    for(const t1 in this.state[e1])t1 !== a && (this.deletedStates[e1][t1] = null);
                } else if (this.deletedStates[e1] && null === this.deletedStates[e1][a]) {
                    this.deletedStates[e1][a] = {};
                    for(const t1 in this.state[e1][a])o[t1] || (this.deletedStates[e1][a][t1] = null);
                } else for(const t1 in o)this.deletedStates[e1] && this.deletedStates[e1][a] && null === this.deletedStates[e1][a][t1] && delete this.deletedStates[e1][a][t1];
            }
            removeFeatureState(t1, e1, i) {
                if (null === this.deletedStates[t1]) return;
                const o = String(e1);
                if (this.deletedStates[t1] = this.deletedStates[t1] || {}, i && void 0 !== e1) null !== this.deletedStates[t1][o] && (this.deletedStates[t1][o] = this.deletedStates[t1][o] || {}, this.deletedStates[t1][o][i] = null);
                else if (void 0 !== e1) {
                    if (this.stateChanges[t1] && this.stateChanges[t1][o]) for(i in this.deletedStates[t1][o] = {}, this.stateChanges[t1][o])this.deletedStates[t1][o][i] = null;
                    else this.deletedStates[t1][o] = null;
                } else this.deletedStates[t1] = null;
            }
            getState(e1, i) {
                const o = String(i), a = t1.extend({}, (this.state[e1] || {})[o], (this.stateChanges[e1] || {})[o]);
                if (null === this.deletedStates[e1]) return {};
                if (this.deletedStates[e1]) {
                    const t1 = this.deletedStates[e1][i];
                    if (null === t1) return {};
                    for(const e1 in t1)delete a[e1];
                }
                return a;
            }
            initializeTileState(t1, e1) {
                t1.setFeatureState(this.state, e1);
            }
            coalesceChanges(e1, i) {
                const o = {};
                for(const e1 in this.stateChanges){
                    this.state[e1] = this.state[e1] || {};
                    const i = {};
                    for(const o in this.stateChanges[e1])this.state[e1][o] || (this.state[e1][o] = {}), t1.extend(this.state[e1][o], this.stateChanges[e1][o]), i[o] = this.state[e1][o];
                    o[e1] = i;
                }
                for(const e1 in this.deletedStates){
                    this.state[e1] = this.state[e1] || {};
                    const i = {};
                    if (null === this.deletedStates[e1]) for(const t1 in this.state[e1])i[t1] = {}, this.state[e1][t1] = {};
                    else for(const t1 in this.deletedStates[e1]){
                        if (null === this.deletedStates[e1][t1]) this.state[e1][t1] = {};
                        else for (const i of Object.keys(this.deletedStates[e1][t1]))delete this.state[e1][t1][i];
                        i[t1] = this.state[e1][t1];
                    }
                    o[e1] = o[e1] || {}, t1.extend(o[e1], i);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o).length) for(const t1 in e1)e1[t1].setFeatureState(o, i);
            }
        }
        class O extends t1.Evented {
            constructor(e1, i, o){
                super(), this.id = e1, this.dispatcher = o, this.on("data", (t1)=>{
                    "source" === t1.dataType && "metadata" === t1.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t1.dataType && "content" === t1.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain));
                }), this.on("dataloading", ()=>{
                    this._sourceErrored = !1;
                }), this.on("error", ()=>{
                    this._sourceErrored = this._source.loaded();
                }), this._source = function(e1, i, o, a) {
                    const r = new M[i.type](e1, i, o, a);
                    if (r.id !== e1) throw new Error(`Expected Source id to be ${e1} instead of ${r.id}`);
                    return t1.bindAll([
                        "load",
                        "abort",
                        "unload",
                        "serialize",
                        "prepare"
                    ], r), r;
                }(e1, i, o, this), this._tiles = {}, this._cache = new B(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new F;
            }
            onAdd(t1) {
                this.map = t1, this._maxTileCacheSize = t1 ? t1._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t1);
            }
            onRemove(t1) {
                this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t1);
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const t1 in this._tiles){
                    const e1 = this._tiles[t1];
                    if ("loaded" !== e1.state && "errored" !== e1.state) return !1;
                }
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const t1 = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, t1 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(t1, e1) {
                return this._source.loadTile(t1, e1);
            }
            _unloadTile(t1) {
                if (this._source.unloadTile) return this._source.unloadTile(t1, ()=>{});
            }
            _abortTile(e1) {
                this._source.abortTile && this._source.abortTile(e1, ()=>{}), this._source.fire(new t1.Event("dataabort", {
                    tile: e1,
                    coord: e1.tileID,
                    dataType: "source"
                }));
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(t1) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const e1 in this._tiles){
                    const i = this._tiles[e1];
                    i.upload(t1), i.prepare(this.map.style.imageManager);
                }
            }
            getIds() {
                return Object.values(this._tiles).map((t1)=>t1.tileID).sort(U).map((t1)=>t1.key);
            }
            getRenderableIds(e1) {
                const i = [];
                for(const t1 in this._tiles)this._isIdRenderable(t1, e1) && i.push(this._tiles[t1]);
                return e1 ? i.sort((e1, i)=>{
                    const o = e1.tileID, a = i.tileID, r = new t1.pointGeometry(o.canonical.x, o.canonical.y)._rotate(this.transform.angle), s = new t1.pointGeometry(a.canonical.x, a.canonical.y)._rotate(this.transform.angle);
                    return o.overscaledZ - a.overscaledZ || s.y - r.y || s.x - r.x;
                }).map((t1)=>t1.tileID.key) : i.map((t1)=>t1.tileID).sort(U).map((t1)=>t1.key);
            }
            hasRenderableParent(t1) {
                const e1 = this.findLoadedParent(t1, 0);
                return !!e1 && this._isIdRenderable(e1.tileID.key);
            }
            _isIdRenderable(t1, e1) {
                return this._tiles[t1] && this._tiles[t1].hasData() && !this._coveredTiles[t1] && (e1 || !this._tiles[t1].holdingForFade());
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const t1 in this._tiles)"errored" !== this._tiles[t1].state && this._reloadTile(t1, "reloading");
                }
            }
            _reloadTile(t1, e1) {
                const i = this._tiles[t1];
                i && ("loading" !== i.state && (i.state = e1), this._loadTile(i, this._tileLoaded.bind(this, i, t1, e1)));
            }
            _tileLoaded(e1, i, o, a) {
                if (a) return e1.state = "errored", void (404 !== a.status ? this._source.fire(new t1.ErrorEvent(a, {
                    tile: e1
                })) : this.update(this.transform, this.terrain));
                e1.timeAdded = t1.exported.now(), "expired" === o && (e1.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e1), "raster-dem" === this.getSource().type && e1.dem && this._backfillDEM(e1), this._state.initializeTileState(e1, this.map ? this.map.painter : null), e1.aborted || this._source.fire(new t1.Event("data", {
                    dataType: "source",
                    tile: e1,
                    coord: e1.tileID
                }));
            }
            _backfillDEM(t1) {
                const e1 = this.getRenderableIds();
                for(let o = 0; o < e1.length; o++){
                    const a = e1[o];
                    if (t1.neighboringTiles && t1.neighboringTiles[a]) {
                        const e1 = this.getTileByID(a);
                        i(t1, e1), i(e1, t1);
                    }
                }
                function i(t1, e1) {
                    t1.needsHillshadePrepare = !0, t1.needsTerrainPrepare = !0;
                    let i = e1.tileID.canonical.x - t1.tileID.canonical.x;
                    const o = e1.tileID.canonical.y - t1.tileID.canonical.y, a = Math.pow(2, t1.tileID.canonical.z), r = e1.tileID.key;
                    0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + a) ? i += a : 1 === Math.abs(i - a) && (i -= a)), e1.dem && t1.dem && (t1.dem.backfillBorder(e1.dem, i, o), t1.neighboringTiles && t1.neighboringTiles[r] && (t1.neighboringTiles[r].backfilled = !0)));
                }
            }
            getTile(t1) {
                return this.getTileByID(t1.key);
            }
            getTileByID(t1) {
                return this._tiles[t1];
            }
            _retainLoadedChildren(t1, e1, i, o) {
                for(const a in this._tiles){
                    let r = this._tiles[a];
                    if (o[a] || !r.hasData() || r.tileID.overscaledZ <= e1 || r.tileID.overscaledZ > i) continue;
                    let s = r.tileID;
                    for(; r && r.tileID.overscaledZ > e1 + 1;){
                        const t1 = r.tileID.scaledTo(r.tileID.overscaledZ - 1);
                        r = this._tiles[t1.key], r && r.hasData() && (s = t1);
                    }
                    let n = s;
                    for(; n.overscaledZ > e1;)if (n = n.scaledTo(n.overscaledZ - 1), t1[n.key]) {
                        o[s.key] = s;
                        break;
                    }
                }
            }
            findLoadedParent(t1, e1) {
                if (t1.key in this._loadedParentTiles) {
                    const i = this._loadedParentTiles[t1.key];
                    return i && i.tileID.overscaledZ >= e1 ? i : null;
                }
                for(let i = t1.overscaledZ - 1; i >= e1; i--){
                    const e1 = t1.scaledTo(i), o = this._getLoadedTile(e1);
                    if (o) return o;
                }
            }
            _getLoadedTile(t1) {
                const e1 = this._tiles[t1.key];
                return e1 && e1.hasData() ? e1 : this._cache.getByKey(t1.wrapped().key);
            }
            updateCacheSize(t1) {
                const e1 = Math.ceil(t1.width / this._source.tileSize) + 1, i = Math.ceil(t1.height / this._source.tileSize) + 1, o = Math.floor(e1 * i * 5), a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;
                this._cache.setMaxSize(a);
            }
            handleWrapJump(t1) {
                const e1 = Math.round((t1 - (void 0 === this._prevLng ? t1 : this._prevLng)) / 360);
                if (this._prevLng = t1, e1) {
                    const t1 = {};
                    for(const i in this._tiles){
                        const o = this._tiles[i];
                        o.tileID = o.tileID.unwrapTo(o.tileID.wrap + e1), t1[o.tileID.key] = o;
                    }
                    this._tiles = t1;
                    for(const t1 in this._timers)clearTimeout(this._timers[t1]), delete this._timers[t1];
                    for(const t1 in this._tiles)this._setTileReloadTimer(t1, this._tiles[t1]);
                }
            }
            update(e1, i) {
                if (this.transform = e1, this.terrain = i, !this._sourceLoaded || this._paused) return;
                let o;
                this.updateCacheSize(e1), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o = e1.getVisibleUnwrappedCoordinates(this._source.tileID).map((e1)=>new t1.OverscaledTileID(e1.canonical.z, e1.wrap, e1.canonical.z, e1.canonical.x, e1.canonical.y)) : (o = e1.coveringTiles({
                    tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: !this.usedForTerrain && this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                    terrain: i
                }), this._source.hasTile && (o = o.filter((t1)=>this._source.hasTile(t1)))) : o = [];
                const a = e1.coveringZoomLevel(this._source), r = Math.max(a - O.maxOverzooming, this._source.minzoom), s = Math.max(a + O.maxUnderzooming, this._source.minzoom);
                if (this.usedForTerrain) {
                    const t1 = {};
                    for (const e1 of o)if (e1.canonical.z > this._source.minzoom) {
                        const i = e1.scaledTo(e1.canonical.z - 1);
                        t1[i.key] = i;
                        const o = e1.scaledTo(Math.max(this._source.minzoom, Math.min(e1.canonical.z, 5)));
                        t1[o.key] = o;
                    }
                    o = o.concat(Object.values(t1));
                }
                const n = this._updateRetainedTiles(o, a);
                if (N(this._source.type)) {
                    const e1 = {}, l = {}, c = Object.keys(n);
                    for (const i of c){
                        const o = n[i], a = this._tiles[i];
                        if (!a || a.fadeEndTime && a.fadeEndTime <= t1.exported.now()) continue;
                        const s = this.findLoadedParent(o, r);
                        s && (this._addTile(s.tileID), e1[s.tileID.key] = s.tileID), l[i] = o;
                    }
                    this._retainLoadedChildren(l, a, s, n);
                    for(const t1 in e1)n[t1] || (this._coveredTiles[t1] = !0, n[t1] = e1[t1]);
                    if (i) {
                        const t1 = {}, e1 = {};
                        for (const i of o)this._tiles[i.key].hasData() ? t1[i.key] = i : e1[i.key] = i;
                        for(const i in e1){
                            const o = e1[i].children(this._source.maxzoom);
                            this._tiles[o[0].key] && this._tiles[o[1].key] && this._tiles[o[2].key] && this._tiles[o[3].key] && (t1[o[0].key] = n[o[0].key] = o[0], t1[o[1].key] = n[o[1].key] = o[1], t1[o[2].key] = n[o[2].key] = o[2], t1[o[3].key] = n[o[3].key] = o[3], delete e1[i]);
                        }
                        for(const i in e1){
                            const o = this.findLoadedParent(e1[i], this._source.minzoom);
                            if (o) {
                                t1[o.tileID.key] = n[o.tileID.key] = o.tileID;
                                for(const e1 in t1)t1[e1].isChildOf(o.tileID) && delete t1[e1];
                            }
                        }
                        for(const e1 in this._tiles)t1[e1] || (this._coveredTiles[e1] = !0);
                    }
                }
                for(const t1 in n)this._tiles[t1].clearFadeHold();
                const l = t1.keysDifference(this._tiles, n);
                for (const t1 of l){
                    const e1 = this._tiles[t1];
                    e1.hasSymbolBuckets && !e1.holdingForFade() ? e1.setHoldDuration(this.map._fadeDuration) : e1.hasSymbolBuckets && !e1.symbolFadeFinished() || this._removeTile(t1);
                }
                this._updateLoadedParentTileCache();
            }
            releaseSymbolFadeTiles() {
                for(const t1 in this._tiles)this._tiles[t1].holdingForFade() && this._removeTile(t1);
            }
            _updateRetainedTiles(t1, e1) {
                const i = {}, o = {}, a = Math.max(e1 - O.maxOverzooming, this._source.minzoom), r = Math.max(e1 + O.maxUnderzooming, this._source.minzoom), s = {};
                for (const o of t1){
                    const t1 = this._addTile(o);
                    i[o.key] = o, t1.hasData() || e1 < this._source.maxzoom && (s[o.key] = o);
                }
                this._retainLoadedChildren(s, e1, r, i);
                for (const r of t1){
                    let t1 = this._tiles[r.key];
                    if (t1.hasData()) continue;
                    if (e1 + 1 > this._source.maxzoom) {
                        const t1 = r.children(this._source.maxzoom)[0], e1 = this.getTile(t1);
                        if (e1 && e1.hasData()) {
                            i[t1.key] = t1;
                            continue;
                        }
                    } else {
                        const t1 = r.children(this._source.maxzoom);
                        if (i[t1[0].key] && i[t1[1].key] && i[t1[2].key] && i[t1[3].key]) continue;
                    }
                    let s = t1.wasRequested();
                    for(let e1 = r.overscaledZ - 1; e1 >= a; --e1){
                        const a = r.scaledTo(e1);
                        if (o[a.key]) break;
                        if (o[a.key] = !0, t1 = this.getTile(a), !t1 && s && (t1 = this._addTile(a)), t1 && (i[a.key] = a, s = t1.wasRequested(), t1.hasData())) break;
                    }
                }
                return i;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const t1 in this._tiles){
                    const e1 = [];
                    let i, o = this._tiles[t1].tileID;
                    for(; o.overscaledZ > 0;){
                        if (o.key in this._loadedParentTiles) {
                            i = this._loadedParentTiles[o.key];
                            break;
                        }
                        e1.push(o.key);
                        const t1 = o.scaledTo(o.overscaledZ - 1);
                        if (i = this._getLoadedTile(t1), i) break;
                        o = t1;
                    }
                    for (const t1 of e1)this._loadedParentTiles[t1] = i;
                }
            }
            _addTile(e1) {
                let i = this._tiles[e1.key];
                if (i) return i;
                i = this._cache.getAndRemove(e1), i && (this._setTileReloadTimer(e1.key, i), i.tileID = e1, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e1.key] && (clearTimeout(this._cacheTimers[e1.key]), delete this._cacheTimers[e1.key], this._setTileReloadTimer(e1.key, i)));
                const o = i;
                return i || (i = new k(e1, this._source.tileSize * e1.overscaleFactor()), this._loadTile(i, this._tileLoaded.bind(this, i, e1.key, i.state))), i.uses++, this._tiles[e1.key] = i, o || this._source.fire(new t1.Event("dataloading", {
                    tile: i,
                    coord: i.tileID,
                    dataType: "source"
                })), i;
            }
            _setTileReloadTimer(t1, e1) {
                t1 in this._timers && (clearTimeout(this._timers[t1]), delete this._timers[t1]);
                const i = e1.getExpiryTimeout();
                i && (this._timers[t1] = setTimeout(()=>{
                    this._reloadTile(t1, "expired"), delete this._timers[t1];
                }, i));
            }
            _removeTile(t1) {
                const e1 = this._tiles[t1];
                e1 && (e1.uses--, delete this._tiles[t1], this._timers[t1] && (clearTimeout(this._timers[t1]), delete this._timers[t1]), e1.uses > 0 || (e1.hasData() && "reloading" !== e1.state ? this._cache.add(e1.tileID, e1, e1.getExpiryTimeout()) : (e1.aborted = !0, this._abortTile(e1), this._unloadTile(e1))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const t1 in this._tiles)this._removeTile(t1);
                this._cache.reset();
            }
            tilesIn(e1, i, o) {
                const a = [], r = this.transform;
                if (!r) return a;
                const s = o ? r.getCameraQueryGeometry(e1) : e1, n = e1.map((t1)=>r.pointCoordinate(t1, this.terrain)), l = s.map((t1)=>r.pointCoordinate(t1, this.terrain)), c = this.getIds();
                let h = 1 / 0, u = 1 / 0, d = -1 / 0, m = -1 / 0;
                for (const t1 of l)h = Math.min(h, t1.x), u = Math.min(u, t1.y), d = Math.max(d, t1.x), m = Math.max(m, t1.y);
                for(let e1 = 0; e1 < c.length; e1++){
                    const o = this._tiles[c[e1]];
                    if (o.holdingForFade()) continue;
                    const s = o.tileID, _ = Math.pow(2, r.zoom - o.tileID.overscaledZ), p = i * o.queryPadding * t1.EXTENT / o.tileSize / _, f = [
                        s.getTilePoint(new t1.MercatorCoordinate(h, u)),
                        s.getTilePoint(new t1.MercatorCoordinate(d, m))
                    ];
                    if (f[0].x - p < t1.EXTENT && f[0].y - p < t1.EXTENT && f[1].x + p >= 0 && f[1].y + p >= 0) {
                        const t1 = n.map((t1)=>s.getTilePoint(t1)), e1 = l.map((t1)=>s.getTilePoint(t1));
                        a.push({
                            tile: o,
                            tileID: s,
                            queryGeometry: t1,
                            cameraQueryGeometry: e1,
                            scale: _
                        });
                    }
                }
                return a;
            }
            getVisibleCoordinates(t1) {
                const e1 = this.getRenderableIds(t1).map((t1)=>this._tiles[t1].tileID);
                for (const t1 of e1)t1.posMatrix = this.transform.calculatePosMatrix(t1.toUnwrapped());
                return e1;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (N(this._source.type)) for(const e1 in this._tiles){
                    const i = this._tiles[e1];
                    if (void 0 !== i.fadeEndTime && i.fadeEndTime >= t1.exported.now()) return !0;
                }
                return !1;
            }
            setFeatureState(t1, e1, i) {
                this._state.updateState(t1 = t1 || "_geojsonTileLayer", e1, i);
            }
            removeFeatureState(t1, e1, i) {
                this._state.removeFeatureState(t1 = t1 || "_geojsonTileLayer", e1, i);
            }
            getFeatureState(t1, e1) {
                return this._state.getState(t1 = t1 || "_geojsonTileLayer", e1);
            }
            setDependencies(t1, e1, i) {
                const o = this._tiles[t1];
                o && o.setDependencies(e1, i);
            }
            reloadTilesForDependencies(t1, e1) {
                for(const i in this._tiles)this._tiles[i].hasDependency(t1, e1) && this._reloadTile(i, "reloading");
                this._cache.filter((i)=>!i.hasDependency(t1, e1));
            }
        }
        function U(t1, e1) {
            const i = Math.abs(2 * t1.wrap) - +(t1.wrap < 0), o = Math.abs(2 * e1.wrap) - +(e1.wrap < 0);
            return t1.overscaledZ - e1.overscaledZ || o - i || e1.canonical.y - t1.canonical.y || e1.canonical.x - t1.canonical.x;
        }
        function N(t1) {
            return "raster" === t1 || "image" === t1 || "video" === t1;
        }
        O.maxOverzooming = 10, O.maxUnderzooming = 3;
        const G = "mapboxgl_preloaded_worker_pool";
        class Z {
            constructor(){
                this.active = {};
            }
            acquire(t1) {
                if (!this.workers) for(this.workers = []; this.workers.length < Z.workerCount;)this.workers.push(new Worker(ba.workerUrl));
                return this.active[t1] = !0, this.workers.slice();
            }
            release(t1) {
                delete this.active[t1], 0 === this.numActive() && (this.workers.forEach((t1)=>{
                    t1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[G];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        const V = Math.floor(t1.exported.hardwareConcurrency / 2);
        let q;
        function j() {
            return q || (q = new Z), q;
        }
        function $(e1, i) {
            const o = {};
            for(const t1 in e1)"ref" !== t1 && (o[t1] = e1[t1]);
            return t1.refProperties.forEach((t1)=>{
                t1 in i && (o[t1] = i[t1]);
            }), o;
        }
        function X(t1) {
            t1 = t1.slice();
            const e1 = Object.create(null);
            for(let i = 0; i < t1.length; i++)e1[t1[i].id] = t1[i];
            for(let i = 0; i < t1.length; i++)"ref" in t1[i] && (t1[i] = $(t1[i], e1[t1[i].ref]));
            return t1;
        }
        Z.workerCount = Math.max(Math.min(V, 6), 1);
        const W = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight"
        };
        function H(t1, e1, i) {
            i.push({
                command: W.addSource,
                args: [
                    t1,
                    e1[t1]
                ]
            });
        }
        function K(t1, e1, i) {
            e1.push({
                command: W.removeSource,
                args: [
                    t1
                ]
            }), i[t1] = !0;
        }
        function Y(t1, e1, i, o) {
            K(t1, i, o), H(t1, e1, i);
        }
        function J(t1, e1, i) {
            let o;
            for(o in t1[i])if (Object.prototype.hasOwnProperty.call(t1[i], o) && "data" !== o && !a(t1[i][o], e1[i][o])) return !1;
            for(o in e1[i])if (Object.prototype.hasOwnProperty.call(e1[i], o) && "data" !== o && !a(t1[i][o], e1[i][o])) return !1;
            return !0;
        }
        function Q(t1, e1, i, o, r, s) {
            let n;
            for(n in e1 = e1 || {}, t1 = t1 || {})Object.prototype.hasOwnProperty.call(t1, n) && (a(t1[n], e1[n]) || i.push({
                command: s,
                args: [
                    o,
                    n,
                    e1[n],
                    r
                ]
            }));
            for(n in e1)Object.prototype.hasOwnProperty.call(e1, n) && !Object.prototype.hasOwnProperty.call(t1, n) && (a(t1[n], e1[n]) || i.push({
                command: s,
                args: [
                    o,
                    n,
                    e1[n],
                    r
                ]
            }));
        }
        function tt(t1) {
            return t1.id;
        }
        function et(t1, e1) {
            return t1[e1.id] = e1, t1;
        }
        class it {
            constructor(t1, e1){
                this.reset(t1, e1);
            }
            reset(t1, e1) {
                this.points = t1 || [], this._distances = [
                    0
                ];
                for(let t1 = 1; t1 < this.points.length; t1++)this._distances[t1] = this._distances[t1 - 1] + this.points[t1].dist(this.points[t1 - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e1) {
                if (1 === this.points.length) return this.points[0];
                e1 = t1.clamp(e1, 0, 1);
                let i = 1, o = this._distances[i];
                const a = e1 * this.paddedLength + this.padding;
                for(; o < a && i < this._distances.length;)o = this._distances[++i];
                const r = i - 1, s = this._distances[r], n = o - s, l = n > 0 ? (a - s) / n : 0;
                return this.points[r].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        function ot(t1, e1) {
            let i = !0;
            return "always" === t1 || "never" !== t1 && "never" !== e1 || (i = !1), i;
        }
        class at {
            constructor(t1, e1, i){
                const o = this.boxCells = [], a = this.circleCells = [];
                this.xCellCount = Math.ceil(t1 / i), this.yCellCount = Math.ceil(e1 / i);
                for(let t1 = 0; t1 < this.xCellCount * this.yCellCount; t1++)o.push([]), a.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t1, this.height = e1, this.xScale = this.xCellCount / t1, this.yScale = this.yCellCount / e1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(t1, e1, i, o, a) {
                this._forEachCell(e1, i, o, a, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t1), this.bboxes.push(e1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(a);
            }
            insertCircle(t1, e1, i, o) {
                this._forEachCell(e1 - o, i - o, e1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t1), this.circles.push(e1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(t1, e1, i, o, a, r) {
                this.boxCells[a].push(r);
            }
            _insertCircleCell(t1, e1, i, o, a, r) {
                this.circleCells[a].push(r);
            }
            _query(t1, e1, i, o, a, r, s) {
                if (i < 0 || t1 > this.width || o < 0 || e1 > this.height) return [];
                const n = [];
                if (t1 <= 0 && e1 <= 0 && this.width <= i && this.height <= o) {
                    if (a) return [
                        {
                            key: null,
                            x1: t1,
                            y1: e1,
                            x2: i,
                            y2: o
                        }
                    ];
                    for(let t1 = 0; t1 < this.boxKeys.length; t1++)n.push({
                        key: this.boxKeys[t1],
                        x1: this.bboxes[4 * t1],
                        y1: this.bboxes[4 * t1 + 1],
                        x2: this.bboxes[4 * t1 + 2],
                        y2: this.bboxes[4 * t1 + 3]
                    });
                    for(let t1 = 0; t1 < this.circleKeys.length; t1++){
                        const e1 = this.circles[3 * t1], i = this.circles[3 * t1 + 1], o = this.circles[3 * t1 + 2];
                        n.push({
                            key: this.circleKeys[t1],
                            x1: e1 - o,
                            y1: i - o,
                            x2: e1 + o,
                            y2: i + o
                        });
                    }
                } else this._forEachCell(t1, e1, i, o, this._queryCell, n, {
                    hitTest: a,
                    overlapMode: r,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, s);
                return n;
            }
            query(t1, e1, i, o) {
                return this._query(t1, e1, i, o, !1, null);
            }
            hitTest(t1, e1, i, o, a, r) {
                return this._query(t1, e1, i, o, !0, a, r).length > 0;
            }
            hitTestCircle(t1, e1, i, o, a) {
                const r = t1 - i, s = t1 + i, n = e1 - i, l = e1 + i;
                if (s < 0 || r > this.width || l < 0 || n > this.height) return !1;
                const c = [];
                return this._forEachCell(r, n, s, l, this._queryCellCircle, c, {
                    hitTest: !0,
                    overlapMode: o,
                    circle: {
                        x: t1,
                        y: e1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, a), c.length > 0;
            }
            _queryCell(t1, e1, i, o, a, r, s, n) {
                const { seenUids: l, hitTest: c, overlapMode: h } = s, u = this.boxCells[a];
                if (null !== u) {
                    const a = this.bboxes;
                    for (const s of u)if (!l.box[s]) {
                        l.box[s] = !0;
                        const u = 4 * s, d = this.boxKeys[s];
                        if (t1 <= a[u + 2] && e1 <= a[u + 3] && i >= a[u + 0] && o >= a[u + 1] && (!n || n(d)) && (!c || !ot(h, d.overlapMode)) && (r.push({
                            key: d,
                            x1: a[u],
                            y1: a[u + 1],
                            x2: a[u + 2],
                            y2: a[u + 3]
                        }), c)) return !0;
                    }
                }
                const d = this.circleCells[a];
                if (null !== d) {
                    const a = this.circles;
                    for (const s of d)if (!l.circle[s]) {
                        l.circle[s] = !0;
                        const u = 3 * s, d = this.circleKeys[s];
                        if (this._circleAndRectCollide(a[u], a[u + 1], a[u + 2], t1, e1, i, o) && (!n || n(d)) && (!c || !ot(h, d.overlapMode))) {
                            const t1 = a[u], e1 = a[u + 1], i = a[u + 2];
                            if (r.push({
                                key: d,
                                x1: t1 - i,
                                y1: e1 - i,
                                x2: t1 + i,
                                y2: e1 + i
                            }), c) return !0;
                        }
                    }
                }
                return !1;
            }
            _queryCellCircle(t1, e1, i, o, a, r, s, n) {
                const { circle: l, seenUids: c, overlapMode: h } = s, u = this.boxCells[a];
                if (null !== u) {
                    const t1 = this.bboxes;
                    for (const e1 of u)if (!c.box[e1]) {
                        c.box[e1] = !0;
                        const i = 4 * e1, o = this.boxKeys[e1];
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, t1[i + 0], t1[i + 1], t1[i + 2], t1[i + 3]) && (!n || n(o)) && !ot(h, o.overlapMode)) return r.push(!0), !0;
                    }
                }
                const d = this.circleCells[a];
                if (null !== d) {
                    const t1 = this.circles;
                    for (const e1 of d)if (!c.circle[e1]) {
                        c.circle[e1] = !0;
                        const i = 3 * e1, o = this.circleKeys[e1];
                        if (this._circlesCollide(t1[i], t1[i + 1], t1[i + 2], l.x, l.y, l.radius) && (!n || n(o)) && !ot(h, o.overlapMode)) return r.push(!0), !0;
                    }
                }
            }
            _forEachCell(t1, e1, i, o, a, r, s, n) {
                const l = this._convertToXCellCoord(t1), c = this._convertToYCellCoord(e1), h = this._convertToXCellCoord(i), u = this._convertToYCellCoord(o);
                for(let d = l; d <= h; d++)for(let l = c; l <= u; l++)if (a.call(this, t1, e1, i, o, this.xCellCount * l + d, r, s, n)) return;
            }
            _convertToXCellCoord(t1) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t1 * this.xScale)));
            }
            _convertToYCellCoord(t1) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t1 * this.yScale)));
            }
            _circlesCollide(t1, e1, i, o, a, r) {
                const s = o - t1, n = a - e1, l = i + r;
                return l * l > s * s + n * n;
            }
            _circleAndRectCollide(t1, e1, i, o, a, r, s) {
                const n = (r - o) / 2, l = Math.abs(t1 - (o + n));
                if (l > n + i) return !1;
                const c = (s - a) / 2, h = Math.abs(e1 - (a + c));
                if (h > c + i) return !1;
                if (l <= n || h <= c) return !0;
                const u = l - n, d = h - c;
                return u * u + d * d <= i * i;
            }
        }
        function rt(e1, i, o, a, r) {
            const s = t1.create();
            return i ? (t1.scale(s, s, [
                1 / r,
                1 / r,
                1
            ]), o || t1.rotateZ(s, s, a.angle)) : t1.multiply(s, a.labelPlaneMatrix, e1), s;
        }
        function st(e1, i, o, a, r) {
            if (i) {
                const i = t1.clone(e1);
                return t1.scale(i, i, [
                    r,
                    r,
                    1
                ]), o || t1.rotateZ(i, i, -a.angle), i;
            }
            return a.glCoordMatrix;
        }
        function nt(e1, i, o) {
            let a;
            o ? (a = [
                e1.x,
                e1.y,
                o(e1.x, e1.y),
                1
            ], t1.transformMat4(a, a, i)) : (a = [
                e1.x,
                e1.y,
                0,
                1
            ], xt(a, a, i));
            const r = a[3];
            return {
                point: new t1.pointGeometry(a[0] / r, a[1] / r),
                signedDistanceFromCamera: r
            };
        }
        function lt(t1, e1) {
            return .5 + t1 / e1 * .5;
        }
        function ct(t1, e1) {
            const i = t1[0] / t1[3], o = t1[1] / t1[3];
            return i >= -e1[0] && i <= e1[0] && o >= -e1[1] && o <= e1[1];
        }
        function ht(e1, i, o, a, r, s, n, l, c, h) {
            const u = a ? e1.textSizeData : e1.iconSizeData, d = t1.evaluateSizeForZoom(u, o.transform.zoom), m = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], _ = a ? e1.text.dynamicLayoutVertexArray : e1.icon.dynamicLayoutVertexArray;
            _.clear();
            const p = e1.lineVertexArray, f = a ? e1.text.placedSymbolArray : e1.icon.placedSymbolArray, g = o.transform.width / o.transform.height;
            let x = !1;
            for(let a = 0; a < f.length; a++){
                const v = f.get(a);
                if (v.hidden || v.writingMode === t1.WritingMode.vertical && !x) {
                    gt(v.numGlyphs, _);
                    continue;
                }
                let y;
                if (x = !1, h ? (y = [
                    v.anchorX,
                    v.anchorY,
                    h(v.anchorX, v.anchorY),
                    1
                ], t1.transformMat4(y, y, i)) : (y = [
                    v.anchorX,
                    v.anchorY,
                    0,
                    1
                ], xt(y, y, i)), !ct(y, m)) {
                    gt(v.numGlyphs, _);
                    continue;
                }
                const b = lt(o.transform.cameraToCenterDistance, y[3]), w = t1.evaluateSizeForFeature(u, d, v), T = n ? w / b : w * b, E = new t1.pointGeometry(v.anchorX, v.anchorY), I = nt(E, r, h).point, C = {}, S = mt(v, T, !1, l, i, r, s, e1.glyphOffsetArray, p, _, I, E, C, g, c, h);
                x = S.useVertical, (S.notEnoughRoom || x || S.needsFlipping && mt(v, T, !0, l, i, r, s, e1.glyphOffsetArray, p, _, I, E, C, g, c, h).notEnoughRoom) && gt(v.numGlyphs, _);
            }
            a ? e1.text.dynamicLayoutVertexBuffer.updateData(_) : e1.icon.dynamicLayoutVertexBuffer.updateData(_);
        }
        function ut(t1, e1, i, o, a, r, s, n, l, c, h, u, d) {
            const m = n.glyphStartIndex + n.numGlyphs, _ = n.lineStartIndex, p = n.lineStartIndex + n.lineLength, f = e1.getoffsetX(n.glyphStartIndex), g = e1.getoffsetX(m - 1), x = pt(t1 * f, i, o, a, r, s, n.segment, _, p, l, c, h, u, d);
            if (!x) return null;
            const v = pt(t1 * g, i, o, a, r, s, n.segment, _, p, l, c, h, u, d);
            return v ? {
                first: x,
                last: v
            } : null;
        }
        function dt(e1, i, o, a) {
            return e1 === t1.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * a ? {
                useVertical: !0
            } : (e1 === t1.WritingMode.vertical ? i.y < o.y : i.x > o.x) ? {
                needsFlipping: !0
            } : null;
        }
        function mt(e1, i, o, a, r, s, n, l, c, h, u, d, m, _, p, f) {
            const g = i / 24, x = e1.lineOffsetX * g, v = e1.lineOffsetY * g;
            let y;
            if (e1.numGlyphs > 1) {
                const t1 = e1.glyphStartIndex + e1.numGlyphs, i = e1.lineStartIndex, r = e1.lineStartIndex + e1.lineLength, h = ut(g, l, x, v, o, u, d, e1, c, s, m, p, f);
                if (!h) return {
                    notEnoughRoom: !0
                };
                const b = nt(h.first.point, n, f).point, w = nt(h.last.point, n, f).point;
                if (a && !o) {
                    const t1 = dt(e1.writingMode, b, w, _);
                    if (t1) return t1;
                }
                y = [
                    h.first
                ];
                for(let a = e1.glyphStartIndex + 1; a < t1 - 1; a++)y.push(pt(g * l.getoffsetX(a), x, v, o, u, d, e1.segment, i, r, c, s, m, p, f));
                y.push(h.last);
            } else {
                if (a && !o) {
                    const i = nt(d, r, f).point, o = e1.lineStartIndex + e1.segment + 1, a = new t1.pointGeometry(c.getx(o), c.gety(o)), s = nt(a, r, f), n = s.signedDistanceFromCamera > 0 ? s.point : _t(d, a, i, 1, r, f), l = dt(e1.writingMode, i, n, _);
                    if (l) return l;
                }
                const i = pt(g * l.getoffsetX(e1.glyphStartIndex), x, v, o, u, d, e1.segment, e1.lineStartIndex, e1.lineStartIndex + e1.lineLength, c, s, m, p, f);
                if (!i) return {
                    notEnoughRoom: !0
                };
                y = [
                    i
                ];
            }
            for (const e1 of y)t1.addDynamicAttributes(h, e1.point, e1.angle);
            return {};
        }
        function _t(t1, e1, i, o, a, r) {
            const s = nt(t1.add(t1.sub(e1)._unit()), a, r).point, n = i.sub(s);
            return i.add(n._mult(o / n.mag()));
        }
        function pt(e1, i, o, a, r, s, n, l, c, h, u, d, m, _) {
            const p = a ? e1 - i : e1 + i;
            let f = p > 0 ? 1 : -1, g = 0;
            a && (f *= -1, g = Math.PI), f < 0 && (g += Math.PI);
            let x = f > 0 ? l + n : l + n + 1, v = r, y = r, b = 0, w = 0;
            const T = Math.abs(p), E = [];
            for(; b + w <= T;){
                if (x += f, x < l || x >= c) return null;
                if (y = v, E.push(v), v = d[x], void 0 === v) {
                    const e1 = new t1.pointGeometry(h.getx(x), h.gety(x)), i = nt(e1, u, _);
                    if (i.signedDistanceFromCamera > 0) v = d[x] = i.point;
                    else {
                        const i = x - f;
                        v = _t(0 === b ? s : new t1.pointGeometry(h.getx(i), h.gety(i)), e1, y, T - b + 1, u, _);
                    }
                }
                b += w, w = y.dist(v);
            }
            const I = (T - b) / w, C = v.sub(y), S = C.mult(I)._add(y);
            S._add(C._unit()._perp()._mult(o * f));
            const D = g + Math.atan2(v.y - y.y, v.x - y.x);
            return E.push(S), {
                point: S,
                angle: m ? D : 0,
                path: E
            };
        }
        const ft = new Float32Array([
            -1 / 0,
            -1 / 0,
            0,
            -1 / 0,
            -1 / 0,
            0,
            -1 / 0,
            -1 / 0,
            0,
            -1 / 0,
            -1 / 0,
            0
        ]);
        function gt(t1, e1) {
            for(let i = 0; i < t1; i++){
                const t1 = e1.length;
                e1.resize(t1 + 4), e1.float32.set(ft, 3 * t1);
            }
        }
        function xt(t1, e1, i) {
            const o = e1[0], a = e1[1];
            return t1[0] = i[0] * o + i[4] * a + i[12], t1[1] = i[1] * o + i[5] * a + i[13], t1[3] = i[3] * o + i[7] * a + i[15], t1;
        }
        const vt = 100;
        class yt {
            constructor(t1, e1 = new at(t1.width + 200, t1.height + 200, 25), i = new at(t1.width + 200, t1.height + 200, 25)){
                this.transform = t1, this.grid = e1, this.ignoredGrid = i, this.pitchfactor = Math.cos(t1._pitch) * t1.cameraToCenterDistance, this.screenRightBoundary = t1.width + vt, this.screenBottomBoundary = t1.height + vt, this.gridRightBoundary = t1.width + 200, this.gridBottomBoundary = t1.height + 200, this.perspectiveRatioCutoff = .6;
            }
            placeCollisionBox(t1, e1, i, o, a, r) {
                const s = this.projectAndGetPerspectiveRatio(o, t1.anchorPointX, t1.anchorPointY, r), n = i * s.perspectiveRatio, l = t1.x1 * n + s.point.x, c = t1.y1 * n + s.point.y, h = t1.x2 * n + s.point.x, u = t1.y2 * n + s.point.y;
                return !this.isInsideGrid(l, c, h, u) || "always" !== e1 && this.grid.hitTest(l, c, h, u, e1, a) || s.perspectiveRatio < this.perspectiveRatioCutoff ? {
                    box: [],
                    offscreen: !1
                } : {
                    box: [
                        l,
                        c,
                        h,
                        u
                    ],
                    offscreen: this.isOffscreen(l, c, h, u)
                };
            }
            placeCollisionCircles(e1, i, o, a, r, s, n, l, c, h, u, d, m, _) {
                const p = [], f = new t1.pointGeometry(i.anchorX, i.anchorY), g = nt(f, s, _), x = lt(this.transform.cameraToCenterDistance, g.signedDistanceFromCamera), v = (h ? r / x : r * x) / t1.ONE_EM, y = nt(f, n, _).point, b = ut(v, a, i.lineOffsetX * v, i.lineOffsetY * v, !1, y, f, i, o, n, {}, !1, _);
                let w = !1, T = !1, E = !0;
                if (b) {
                    const i = .5 * d * x + m, o = new t1.pointGeometry(-100, -100), a = new t1.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), r = new it, s = b.first, n = b.last;
                    let h = [];
                    for(let t1 = s.path.length - 1; t1 >= 1; t1--)h.push(s.path[t1]);
                    for(let t1 = 1; t1 < n.path.length; t1++)h.push(n.path[t1]);
                    const f = 2.5 * i;
                    if (l) {
                        const t1 = h.map((t1)=>nt(t1, l, _));
                        h = t1.some((t1)=>t1.signedDistanceFromCamera <= 0) ? [] : t1.map((t1)=>t1.point);
                    }
                    let g = [];
                    if (h.length > 0) {
                        const e1 = h[0].clone(), i = h[0].clone();
                        for(let t1 = 1; t1 < h.length; t1++)e1.x = Math.min(e1.x, h[t1].x), e1.y = Math.min(e1.y, h[t1].y), i.x = Math.max(i.x, h[t1].x), i.y = Math.max(i.y, h[t1].y);
                        g = e1.x >= o.x && i.x <= a.x && e1.y >= o.y && i.y <= a.y ? [
                            h
                        ] : i.x < o.x || e1.x > a.x || i.y < o.y || e1.y > a.y ? [] : t1.clipLine([
                            h
                        ], o.x, o.y, a.x, a.y);
                    }
                    for (const t1 of g){
                        r.reset(t1, .25 * i);
                        let o = 0;
                        o = r.length <= .5 * i ? 1 : Math.ceil(r.paddedLength / f) + 1;
                        for(let t1 = 0; t1 < o; t1++){
                            const a = t1 / Math.max(o - 1, 1), s = r.lerp(a), n = s.x + vt, l = s.y + vt;
                            p.push(n, l, i, 0);
                            const h = n - i, d = l - i, m = n + i, _ = l + i;
                            if (E = E && this.isOffscreen(h, d, m, _), T = T || this.isInsideGrid(h, d, m, _), "always" !== e1 && this.grid.hitTestCircle(n, l, i, e1, u) && (w = !0, !c)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: w
                            };
                        }
                    }
                }
                return {
                    circles: !c && w || !T || x < this.perspectiveRatioCutoff ? [] : p,
                    offscreen: E,
                    collisionDetected: w
                };
            }
            queryRenderedSymbols(e1) {
                if (0 === e1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, a = 1 / 0, r = -1 / 0, s = -1 / 0;
                for (const n of e1){
                    const e1 = new t1.pointGeometry(n.x + vt, n.y + vt);
                    o = Math.min(o, e1.x), a = Math.min(a, e1.y), r = Math.max(r, e1.x), s = Math.max(s, e1.y), i.push(e1);
                }
                const n = this.grid.query(o, a, r, s).concat(this.ignoredGrid.query(o, a, r, s)), l = {}, c = {};
                for (const e1 of n){
                    const o = e1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const a = [
                        new t1.pointGeometry(e1.x1, e1.y1),
                        new t1.pointGeometry(e1.x2, e1.y1),
                        new t1.pointGeometry(e1.x2, e1.y2),
                        new t1.pointGeometry(e1.x1, e1.y2)
                    ];
                    t1.polygonIntersectsPolygon(i, a) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(t1, e1, i, o, a, r) {
                (i ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: o,
                    featureIndex: a,
                    collisionGroupID: r,
                    overlapMode: e1
                }, t1[0], t1[1], t1[2], t1[3]);
            }
            insertCollisionCircles(t1, e1, i, o, a, r) {
                const s = i ? this.ignoredGrid : this.grid, n = {
                    bucketInstanceId: o,
                    featureIndex: a,
                    collisionGroupID: r,
                    overlapMode: e1
                };
                for(let e1 = 0; e1 < t1.length; e1 += 4)s.insertCircle(n, t1[e1], t1[e1 + 1], t1[e1 + 2]);
            }
            projectAndGetPerspectiveRatio(e1, i, o, a) {
                let r;
                return a ? (r = [
                    i,
                    o,
                    a(i, o),
                    1
                ], t1.transformMat4(r, r, e1)) : (r = [
                    i,
                    o,
                    0,
                    1
                ], xt(r, r, e1)), {
                    point: new t1.pointGeometry((r[0] / r[3] + 1) / 2 * this.transform.width + vt, (-r[1] / r[3] + 1) / 2 * this.transform.height + vt),
                    perspectiveRatio: .5 + this.transform.cameraToCenterDistance / r[3] * .5
                };
            }
            isOffscreen(t1, e1, i, o) {
                return i < vt || t1 >= this.screenRightBoundary || o < vt || e1 > this.screenBottomBoundary;
            }
            isInsideGrid(t1, e1, i, o) {
                return i >= 0 && t1 < this.gridRightBoundary && o >= 0 && e1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const e1 = t1.identity([]);
                return t1.translate(e1, e1, [
                    -100,
                    -100,
                    0
                ]), e1;
            }
        }
        function bt(e1, i, o) {
            return i * (t1.EXTENT / (e1.tileSize * Math.pow(2, o - e1.tileID.overscaledZ)));
        }
        class wt {
            constructor(t1, e1, i, o){
                this.opacity = t1 ? Math.max(0, Math.min(1, t1.opacity + (t1.placed ? e1 : -e1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class Tt {
            constructor(t1, e1, i, o, a){
                this.text = new wt(t1 ? t1.text : null, e1, i, a), this.icon = new wt(t1 ? t1.icon : null, e1, o, a);
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class Et {
            constructor(t1, e1, i){
                this.text = t1, this.icon = e1, this.skipFade = i;
            }
        }
        class It {
            constructor(){
                this.invProjMatrix = t1.create(), this.viewportMatrix = t1.create(), this.circles = [];
            }
        }
        class Ct {
            constructor(t1, e1, i, o, a){
                this.bucketInstanceId = t1, this.featureIndex = e1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = a;
            }
        }
        class St {
            constructor(t1){
                this.crossSourceCollisions = t1, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(t1) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[t1]) {
                    const e1 = ++this.maxGroupID;
                    this.collisionGroups[t1] = {
                        ID: e1,
                        predicate: (t1)=>t1.collisionGroupID === e1
                    };
                }
                return this.collisionGroups[t1];
            }
        }
        function Dt(e1, i, o, a, r) {
            const { horizontalAlign: s, verticalAlign: n } = t1.getAnchorAlignment(e1), l = -(s - .5) * i, c = -(n - .5) * o, h = t1.evaluateVariableOffset(e1, a);
            return new t1.pointGeometry(l + h[0] * r, c + h[1] * r);
        }
        function zt(e1, i, o, a, r, s) {
            const { x1: n, x2: l, y1: c, y2: h, anchorPointX: u, anchorPointY: d } = e1, m = new t1.pointGeometry(i, o);
            return a && m._rotate(r ? s : -s), {
                x1: n + m.x,
                y1: c + m.y,
                x2: l + m.x,
                y2: h + m.y,
                anchorPointX: u,
                anchorPointY: d
            };
        }
        class Pt {
            constructor(t1, e1, i, o, a){
                this.transform = t1.clone(), this.terrain = e1, this.collisionIndex = new yt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i, this.retainedQueryData = {}, this.collisionGroups = new St(o), this.collisionCircleArrays = {}, this.prevPlacement = a, a && (a.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(e1, i, o, a) {
                const r = o.getBucket(i), s = o.latestFeatureIndex;
                if (!r || !s || i.id !== r.layerIds[0]) return;
                const n = o.collisionBoxArray, l = r.layers[0].layout, c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), h = o.tileSize / t1.EXTENT, u = this.transform.calculatePosMatrix(o.tileID.toUnwrapped()), d = "map" === l.get("text-pitch-alignment"), m = "map" === l.get("text-rotation-alignment"), _ = bt(o, 1, this.transform.zoom), p = rt(u, d, m, this.transform, _);
                let f = null;
                if (d) {
                    const e1 = st(u, d, m, this.transform, _);
                    f = t1.multiply([], this.transform.labelPlaneMatrix, e1);
                }
                this.retainedQueryData[r.bucketInstanceId] = new Ct(r.bucketInstanceId, s, r.sourceLayerIndex, r.index, o.tileID);
                const g = {
                    bucket: r,
                    layout: l,
                    posMatrix: u,
                    textLabelPlaneMatrix: p,
                    labelToScreenMatrix: f,
                    scale: c,
                    textPixelRatio: h,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: n,
                    partiallyEvaluatedTextSize: t1.evaluateSizeForZoom(r.textSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(r.sourceID)
                };
                if (a) for (const t1 of r.sortKeyRanges){
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: a } = t1;
                    e1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: a,
                        parameters: g
                    });
                }
                else e1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: r.symbolInstances.length,
                    parameters: g
                });
            }
            attemptAnchorPlacement(t1, e1, i, o, a, r, s, n, l, c, h, u, d, m, _, p) {
                const f = [
                    u.textOffset0,
                    u.textOffset1
                ], g = Dt(t1, i, o, f, a), x = this.collisionIndex.placeCollisionBox(zt(e1, g.x, g.y, r, s, this.transform.angle), h, n, l, c.predicate, p);
                if ((!_ || 0 !== this.collisionIndex.placeCollisionBox(zt(_, g.x, g.y, r, s, this.transform.angle), h, n, l, c.predicate, p).box.length) && x.box.length > 0) {
                    let e1;
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[u.crossTileID] && this.prevPlacement.placements[u.crossTileID] && this.prevPlacement.placements[u.crossTileID].text && (e1 = this.prevPlacement.variableOffsets[u.crossTileID].anchor), 0 === u.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                    return this.variableOffsets[u.crossTileID] = {
                        textOffset: f,
                        width: i,
                        height: o,
                        anchor: t1,
                        textBoxScale: a,
                        prevAnchor: e1
                    }, this.markUsedJustification(d, t1, u, m), d.allowVerticalPlacement && (this.markUsedOrientation(d, m, u), this.placedOrientations[u.crossTileID] = m), {
                        shift: g,
                        placedGlyphBoxes: x
                    };
                }
            }
            placeLayerBucketPart(e1, i, o) {
                const { bucket: a, layout: r, posMatrix: s, textLabelPlaneMatrix: n, labelToScreenMatrix: l, textPixelRatio: c, holdingForFade: h, collisionBoxArray: u, partiallyEvaluatedTextSize: d, collisionGroup: m } = e1.parameters, _ = r.get("text-optional"), p = r.get("icon-optional"), f = t1.getOverlapMode(r, "text-overlap", "text-allow-overlap"), g = "always" === f, x = t1.getOverlapMode(r, "icon-overlap", "icon-allow-overlap"), v = "always" === x, y = "map" === r.get("text-rotation-alignment"), b = "map" === r.get("text-pitch-alignment"), w = "none" !== r.get("icon-text-fit"), T = "viewport-y" === r.get("symbol-z-order"), E = g && (v || !a.hasIconData() || p), I = v && (g || !a.hasTextData() || _);
                !a.collisionArrays && u && a.deserializeCollisionBoxes(u);
                const C = (e1, u)=>{
                    if (i[e1.crossTileID]) return;
                    if (h) return void (this.placements[e1.crossTileID] = new Et(!1, !1, !1));
                    let v = !1, T = !1, C = !0, S = null, D = {
                        box: null,
                        offscreen: null
                    }, z = {
                        box: null,
                        offscreen: null
                    }, P = null, M = null, A = null, L = 0, R = 0, k = 0;
                    u.textFeatureIndex ? L = u.textFeatureIndex : e1.useRuntimeCollisionCircles && (L = e1.featureIndex), u.verticalTextFeatureIndex && (R = u.verticalTextFeatureIndex);
                    const B = this.retainedQueryData[a.bucketInstanceId].tileID, F = this.terrain ? (t1, e1)=>this.terrain.getElevation(B, t1, e1) : null;
                    for (const t1 of [
                        "textBox",
                        "verticalTextBox",
                        "iconBox",
                        "verticalIconBox"
                    ]){
                        const e1 = u[t1];
                        e1 && (e1.elevation = F ? F(e1.anchorPointX, e1.anchorPointY) : 0);
                    }
                    const O = u.textBox;
                    if (O) {
                        const i = (i)=>{
                            let o = t1.WritingMode.horizontal;
                            if (a.allowVerticalPlacement && !i && this.prevPlacement) {
                                const t1 = this.prevPlacement.placedOrientations[e1.crossTileID];
                                t1 && (this.placedOrientations[e1.crossTileID] = t1, o = t1, this.markUsedOrientation(a, o, e1));
                            }
                            return o;
                        }, o = (i, o)=>{
                            if (a.allowVerticalPlacement && e1.numVerticalGlyphVertices > 0 && u.verticalTextBox) {
                                for (const e1 of a.writingModes)if (e1 === t1.WritingMode.vertical ? (D = o(), z = D) : D = i(), D && D.box && D.box.length) break;
                            } else D = i();
                        };
                        if (r.get("text-variable-anchor")) {
                            let n = r.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[e1.crossTileID]) {
                                const t1 = this.prevPlacement.variableOffsets[e1.crossTileID];
                                n.indexOf(t1.anchor) > 0 && (n = n.filter((e1)=>e1 !== t1.anchor), n.unshift(t1.anchor));
                            }
                            const l = (t1, i, o)=>{
                                const r = t1.x2 - t1.x1, l = t1.y2 - t1.y1, h = e1.textBoxScale, u = w && "never" === x ? i : null;
                                let d = {
                                    box: [],
                                    offscreen: !1
                                };
                                const _ = "never" !== f ? 2 * n.length : n.length;
                                for(let i = 0; i < _; ++i){
                                    const _ = this.attemptAnchorPlacement(n[i % n.length], t1, r, l, h, y, b, c, s, m, i >= n.length ? f : "never", e1, a, o, u, F);
                                    if (_ && (d = _.placedGlyphBoxes, d && d.box && d.box.length)) {
                                        v = !0, S = _.shift;
                                        break;
                                    }
                                }
                                return d;
                            };
                            o(()=>l(O, u.iconBox, t1.WritingMode.horizontal), ()=>{
                                const i = u.verticalTextBox;
                                return a.allowVerticalPlacement && !(D && D.box && D.box.length) && e1.numVerticalGlyphVertices > 0 && i ? l(i, u.verticalIconBox, t1.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null
                                };
                            }), D && (v = D.box, C = D.offscreen);
                            const h = i(D && D.box);
                            if (!v && this.prevPlacement) {
                                const t1 = this.prevPlacement.variableOffsets[e1.crossTileID];
                                t1 && (this.variableOffsets[e1.crossTileID] = t1, this.markUsedJustification(a, t1.anchor, e1, h));
                            }
                        } else {
                            const r = (t1, i)=>{
                                const o = this.collisionIndex.placeCollisionBox(t1, f, c, s, m.predicate, F);
                                return o && o.box && o.box.length && (this.markUsedOrientation(a, i, e1), this.placedOrientations[e1.crossTileID] = i), o;
                            };
                            o(()=>r(O, t1.WritingMode.horizontal), ()=>{
                                const i = u.verticalTextBox;
                                return a.allowVerticalPlacement && e1.numVerticalGlyphVertices > 0 && i ? r(i, t1.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null
                                };
                            }), i(D && D.box && D.box.length);
                        }
                    }
                    if (P = D, v = P && P.box && P.box.length > 0, C = P && P.offscreen, e1.useRuntimeCollisionCircles) {
                        const i = a.text.placedSymbolArray.get(e1.centerJustifiedTextSymbolIndex), c = t1.evaluateSizeForFeature(a.textSizeData, d, i), h = r.get("text-padding");
                        M = this.collisionIndex.placeCollisionCircles(f, i, a.lineVertexArray, a.glyphOffsetArray, c, s, n, l, o, b, m.predicate, e1.collisionCircleDiameter, h, F), M.circles.length && M.collisionDetected && !o && t1.warnOnce("Collisions detected, but collision boxes are not shown"), v = g || M.circles.length > 0 && !M.collisionDetected, C = C && M.offscreen;
                    }
                    if (u.iconFeatureIndex && (k = u.iconFeatureIndex), u.iconBox) {
                        const t1 = (t1)=>{
                            const e1 = w && S ? zt(t1, S.x, S.y, y, b, this.transform.angle) : t1;
                            return this.collisionIndex.placeCollisionBox(e1, x, c, s, m.predicate, F);
                        };
                        z && z.box && z.box.length && u.verticalIconBox ? (A = t1(u.verticalIconBox), T = A.box.length > 0) : (A = t1(u.iconBox), T = A.box.length > 0), C = C && A.offscreen;
                    }
                    const U = _ || 0 === e1.numHorizontalGlyphVertices && 0 === e1.numVerticalGlyphVertices, N = p || 0 === e1.numIconVertices;
                    if (U || N ? N ? U || (T = T && v) : v = T && v : T = v = T && v, v && P && P.box && this.collisionIndex.insertCollisionBox(P.box, f, r.get("text-ignore-placement"), a.bucketInstanceId, z && z.box && R ? R : L, m.ID), T && A && this.collisionIndex.insertCollisionBox(A.box, x, r.get("icon-ignore-placement"), a.bucketInstanceId, k, m.ID), M && (v && this.collisionIndex.insertCollisionCircles(M.circles, f, r.get("text-ignore-placement"), a.bucketInstanceId, L, m.ID), o)) {
                        const t1 = a.bucketInstanceId;
                        let e1 = this.collisionCircleArrays[t1];
                        void 0 === e1 && (e1 = this.collisionCircleArrays[t1] = new It);
                        for(let t1 = 0; t1 < M.circles.length; t1 += 4)e1.circles.push(M.circles[t1 + 0]), e1.circles.push(M.circles[t1 + 1]), e1.circles.push(M.circles[t1 + 2]), e1.circles.push(M.collisionDetected ? 1 : 0);
                    }
                    if (0 === e1.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                    if (0 === a.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
                    this.placements[e1.crossTileID] = new Et(v || E, T || I, C || a.justReloaded), i[e1.crossTileID] = !0;
                };
                if (T) {
                    if (0 !== e1.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
                    const t1 = a.getSortedSymbolIndexes(this.transform.angle);
                    for(let e1 = t1.length - 1; e1 >= 0; --e1){
                        const i = t1[e1];
                        C(a.symbolInstances.get(i), a.collisionArrays[i]);
                    }
                } else for(let t1 = e1.symbolInstanceStart; t1 < e1.symbolInstanceEnd; t1++)C(a.symbolInstances.get(t1), a.collisionArrays[t1]);
                if (o && a.bucketInstanceId in this.collisionCircleArrays) {
                    const e1 = this.collisionCircleArrays[a.bucketInstanceId];
                    t1.invert(e1.invProjMatrix, s), e1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                a.justReloaded = !1;
            }
            markUsedJustification(e1, i, o, a) {
                let r;
                r = a === t1.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : ({
                    left: o.leftJustifiedTextSymbolIndex,
                    center: o.centerJustifiedTextSymbolIndex,
                    right: o.rightJustifiedTextSymbolIndex
                })[t1.getAnchorJustification(i)];
                const s = [
                    o.leftJustifiedTextSymbolIndex,
                    o.centerJustifiedTextSymbolIndex,
                    o.rightJustifiedTextSymbolIndex,
                    o.verticalPlacedTextSymbolIndex
                ];
                for (const t1 of s)t1 >= 0 && (e1.text.placedSymbolArray.get(t1).crossTileID = r >= 0 && t1 !== r ? 0 : o.crossTileID);
            }
            markUsedOrientation(e1, i, o) {
                const a = i === t1.WritingMode.horizontal || i === t1.WritingMode.horizontalOnly ? i : 0, r = i === t1.WritingMode.vertical ? i : 0, s = [
                    o.leftJustifiedTextSymbolIndex,
                    o.centerJustifiedTextSymbolIndex,
                    o.rightJustifiedTextSymbolIndex
                ];
                for (const t1 of s)e1.text.placedSymbolArray.get(t1).placedOrientation = a;
                o.verticalPlacedTextSymbolIndex && (e1.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = r);
            }
            commit(t1) {
                this.commitTime = t1, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const e1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = e1 ? e1.zoomAdjustment(this.transform.zoom) : 0;
                const o = e1 ? e1.symbolFadeChange(t1) : 1, a = e1 ? e1.opacities : {}, r = e1 ? e1.variableOffsets : {}, s = e1 ? e1.placedOrientations : {};
                for(const t1 in this.placements){
                    const e1 = this.placements[t1], r = a[t1];
                    r ? (this.opacities[t1] = new Tt(r, o, e1.text, e1.icon), i = i || e1.text !== r.text.placed || e1.icon !== r.icon.placed) : (this.opacities[t1] = new Tt(null, o, e1.text, e1.icon, e1.skipFade), i = i || e1.text || e1.icon);
                }
                for(const t1 in a){
                    const e1 = a[t1];
                    if (!this.opacities[t1]) {
                        const a = new Tt(e1, o, !1, !1);
                        a.isHidden() || (this.opacities[t1] = a, i = i || e1.text.placed || e1.icon.placed);
                    }
                }
                for(const t1 in r)this.variableOffsets[t1] || !this.opacities[t1] || this.opacities[t1].isHidden() || (this.variableOffsets[t1] = r[t1]);
                for(const t1 in s)this.placedOrientations[t1] || !this.opacities[t1] || this.opacities[t1].isHidden() || (this.placedOrientations[t1] = s[t1]);
                if (e1 && void 0 === e1.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
                i ? this.lastPlacementChangeTime = t1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e1 ? e1.lastPlacementChangeTime : t1);
            }
            updateLayerOpacities(t1, e1) {
                const i = {};
                for (const o of e1){
                    const e1 = o.getBucket(t1);
                    e1 && o.latestFeatureIndex && t1.id === e1.layerIds[0] && this.updateBucketOpacities(e1, i, o.collisionBoxArray);
                }
            }
            updateBucketOpacities(e1, i, o) {
                e1.hasTextData() && e1.text.opacityVertexArray.clear(), e1.hasIconData() && e1.icon.opacityVertexArray.clear(), e1.hasIconCollisionBoxData() && e1.iconCollisionBox.collisionVertexArray.clear(), e1.hasTextCollisionBoxData() && e1.textCollisionBox.collisionVertexArray.clear();
                const a = e1.layers[0].layout, r = new Tt(null, 0, !1, !1, !0), s = a.get("text-allow-overlap"), n = a.get("icon-allow-overlap"), l = a.get("text-variable-anchor"), c = "map" === a.get("text-rotation-alignment"), h = "map" === a.get("text-pitch-alignment"), u = "none" !== a.get("icon-text-fit"), d = new Tt(null, 0, s && (n || !e1.hasIconData() || a.get("icon-optional")), n && (s || !e1.hasTextData() || a.get("text-optional")), !0);
                !e1.collisionArrays && o && (e1.hasIconCollisionBoxData() || e1.hasTextCollisionBoxData()) && e1.deserializeCollisionBoxes(o);
                const m = (t1, e1, i)=>{
                    for(let o = 0; o < e1 / 4; o++)t1.opacityVertexArray.emplaceBack(i);
                };
                for(let o = 0; o < e1.symbolInstances.length; o++){
                    const a = e1.symbolInstances.get(o), { numHorizontalGlyphVertices: s, numVerticalGlyphVertices: n, crossTileID: _ } = a;
                    let p = this.opacities[_];
                    i[_] ? p = r : p || (p = d, this.opacities[_] = p), i[_] = !0;
                    const f = a.numIconVertices > 0, g = this.placedOrientations[a.crossTileID], x = g === t1.WritingMode.vertical, v = g === t1.WritingMode.horizontal || g === t1.WritingMode.horizontalOnly;
                    if (s > 0 || n > 0) {
                        const t1 = Ut(p.text);
                        m(e1.text, s, x ? Nt : t1), m(e1.text, n, v ? Nt : t1);
                        const i = p.text.isHidden();
                        [
                            a.rightJustifiedTextSymbolIndex,
                            a.centerJustifiedTextSymbolIndex,
                            a.leftJustifiedTextSymbolIndex
                        ].forEach((t1)=>{
                            t1 >= 0 && (e1.text.placedSymbolArray.get(t1).hidden = i || x ? 1 : 0);
                        }), a.verticalPlacedTextSymbolIndex >= 0 && (e1.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = i || v ? 1 : 0);
                        const o = this.variableOffsets[a.crossTileID];
                        o && this.markUsedJustification(e1, o.anchor, a, g);
                        const r = this.placedOrientations[a.crossTileID];
                        r && (this.markUsedJustification(e1, "left", a, r), this.markUsedOrientation(e1, r, a));
                    }
                    if (f) {
                        const t1 = Ut(p.icon), i = !(u && a.verticalPlacedIconSymbolIndex && x);
                        a.placedIconSymbolIndex >= 0 && (m(e1.icon, a.numIconVertices, i ? t1 : Nt), e1.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = p.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (m(e1.icon, a.numVerticalIconVertices, i ? Nt : t1), e1.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = p.icon.isHidden());
                    }
                    if (e1.hasIconCollisionBoxData() || e1.hasTextCollisionBoxData()) {
                        const i = e1.collisionArrays[o];
                        if (i) {
                            let o = new t1.pointGeometry(0, 0);
                            if (i.textBox || i.verticalTextBox) {
                                let t1 = !0;
                                if (l) {
                                    const e1 = this.variableOffsets[_];
                                    e1 ? (o = Dt(e1.anchor, e1.width, e1.height, e1.textOffset, e1.textBoxScale), c && o._rotate(h ? this.transform.angle : -this.transform.angle)) : t1 = !1;
                                }
                                i.textBox && Mt(e1.textCollisionBox.collisionVertexArray, p.text.placed, !t1 || x, o.x, o.y), i.verticalTextBox && Mt(e1.textCollisionBox.collisionVertexArray, p.text.placed, !t1 || v, o.x, o.y);
                            }
                            const a = Boolean(!v && i.verticalIconBox);
                            i.iconBox && Mt(e1.iconCollisionBox.collisionVertexArray, p.icon.placed, a, u ? o.x : 0, u ? o.y : 0), i.verticalIconBox && Mt(e1.iconCollisionBox.collisionVertexArray, p.icon.placed, !a, u ? o.x : 0, u ? o.y : 0);
                        }
                    }
                }
                if (e1.sortFeatures(this.transform.angle), this.retainedQueryData[e1.bucketInstanceId] && (this.retainedQueryData[e1.bucketInstanceId].featureSortOrder = e1.featureSortOrder), e1.hasTextData() && e1.text.opacityVertexBuffer && e1.text.opacityVertexBuffer.updateData(e1.text.opacityVertexArray), e1.hasIconData() && e1.icon.opacityVertexBuffer && e1.icon.opacityVertexBuffer.updateData(e1.icon.opacityVertexArray), e1.hasIconCollisionBoxData() && e1.iconCollisionBox.collisionVertexBuffer && e1.iconCollisionBox.collisionVertexBuffer.updateData(e1.iconCollisionBox.collisionVertexArray), e1.hasTextCollisionBoxData() && e1.textCollisionBox.collisionVertexBuffer && e1.textCollisionBox.collisionVertexBuffer.updateData(e1.textCollisionBox.collisionVertexArray), e1.text.opacityVertexArray.length !== e1.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e1.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e1.text.layoutVertexArray.length}) / 4`);
                if (e1.icon.opacityVertexArray.length !== e1.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e1.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e1.icon.layoutVertexArray.length}) / 4`);
                if (e1.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[e1.bucketInstanceId];
                    e1.placementInvProjMatrix = t1.invProjMatrix, e1.placementViewportMatrix = t1.viewportMatrix, e1.collisionCircleArray = t1.circles, delete this.collisionCircleArrays[e1.bucketInstanceId];
                }
            }
            symbolFadeChange(t1) {
                return 0 === this.fadeDuration ? 1 : (t1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(t1) {
                return Math.max(0, (this.transform.zoom - t1) / 1.5);
            }
            hasTransitions(t1) {
                return this.stale || t1 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(t1, e1) {
                const i = this.zoomAtLastRecencyCheck === e1 ? 1 - this.zoomAdjustment(e1) : 1;
                return this.zoomAtLastRecencyCheck = e1, this.commitTime + this.fadeDuration * i > t1;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function Mt(t1, e1, i, o, a) {
            t1.emplaceBack(e1 ? 1 : 0, i ? 1 : 0, o || 0, a || 0), t1.emplaceBack(e1 ? 1 : 0, i ? 1 : 0, o || 0, a || 0), t1.emplaceBack(e1 ? 1 : 0, i ? 1 : 0, o || 0, a || 0), t1.emplaceBack(e1 ? 1 : 0, i ? 1 : 0, o || 0, a || 0);
        }
        const At = Math.pow(2, 25), Lt = Math.pow(2, 24), Rt = Math.pow(2, 17), kt = Math.pow(2, 16), Bt = Math.pow(2, 9), Ft = Math.pow(2, 8), Ot = Math.pow(2, 1);
        function Ut(t1) {
            if (0 === t1.opacity && !t1.placed) return 0;
            if (1 === t1.opacity && t1.placed) return 4294967295;
            const e1 = t1.placed ? 1 : 0, i = Math.floor(127 * t1.opacity);
            return i * At + e1 * Lt + i * Rt + e1 * kt + i * Bt + e1 * Ft + i * Ot + e1;
        }
        const Nt = 0;
        class Gt {
            constructor(t1){
                this._sortAcrossTiles = "viewport-y" !== t1.layout.get("symbol-z-order") && !t1.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(t1, e1, i, o, a) {
                const r = this._bucketParts;
                for(; this._currentTileIndex < t1.length;)if (e1.getBucketParts(r, o, t1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, r.sort((t1, e1)=>t1.sortKey - e1.sortKey)); this._currentPartIndex < r.length;)if (e1.placeLayerBucketPart(r[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, a()) return !0;
                return !1;
            }
        }
        class Zt {
            constructor(t1, e1, i, o, a, r, s, n){
                this.placement = new Pt(t1, e1, r, s, n), this._currentPlacementIndex = i.length - 1, this._forceFullPlacement = o, this._showCollisionBoxes = a, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(e1, i, o) {
                const a = t1.exported.now(), r = ()=>{
                    const e1 = t1.exported.now() - a;
                    return !this._forceFullPlacement && e1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const t1 = i[e1[this._currentPlacementIndex]], a = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === t1.type && (!t1.minzoom || t1.minzoom <= a) && (!t1.maxzoom || t1.maxzoom > a)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new Gt(t1)), this._inProgressLayer.continuePlacement(o[t1.source], this.placement, this._showCollisionBoxes, t1, r)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(t1) {
                return this.placement.commit(t1), this.placement;
            }
        }
        const Vt = 512 / t1.EXTENT / 2;
        class qt {
            constructor(t1, e1, i){
                this.tileID = t1, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;
                for(let i = 0; i < e1.length; i++){
                    const o = e1.get(i), a = o.key;
                    this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({
                        crossTileID: o.crossTileID,
                        coord: this.getScaledCoordinates(o, t1)
                    });
                }
            }
            getScaledCoordinates(e1, i) {
                const o = Vt / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
                return {
                    x: Math.floor((i.canonical.x * t1.EXTENT + e1.anchorX) * o),
                    y: Math.floor((i.canonical.y * t1.EXTENT + e1.anchorY) * o)
                };
            }
            findMatches(t1, e1, i) {
                const o = this.tileID.canonical.z < e1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e1.canonical.z);
                for(let a = 0; a < t1.length; a++){
                    const r = t1.get(a);
                    if (r.crossTileID) continue;
                    const s = this.indexedSymbolInstances[r.key];
                    if (!s) continue;
                    const n = this.getScaledCoordinates(r, e1);
                    for (const t1 of s)if (Math.abs(t1.coord.x - n.x) <= o && Math.abs(t1.coord.y - n.y) <= o && !i[t1.crossTileID]) {
                        i[t1.crossTileID] = !0, r.crossTileID = t1.crossTileID;
                        break;
                    }
                }
            }
        }
        class jt {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class $t {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(t1) {
                const e1 = Math.round((t1 - this.lng) / 360);
                if (0 !== e1) for(const t1 in this.indexes){
                    const i = this.indexes[t1], o = {};
                    for(const t1 in i){
                        const a = i[t1];
                        a.tileID = a.tileID.unwrapTo(a.tileID.wrap + e1), o[a.tileID.key] = a;
                    }
                    this.indexes[t1] = o;
                }
                this.lng = t1;
            }
            addBucket(t1, e1, i) {
                if (this.indexes[t1.overscaledZ] && this.indexes[t1.overscaledZ][t1.key]) {
                    if (this.indexes[t1.overscaledZ][t1.key].bucketInstanceId === e1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(t1.overscaledZ, this.indexes[t1.overscaledZ][t1.key]);
                }
                for(let t1 = 0; t1 < e1.symbolInstances.length; t1++)e1.symbolInstances.get(t1).crossTileID = 0;
                this.usedCrossTileIDs[t1.overscaledZ] || (this.usedCrossTileIDs[t1.overscaledZ] = {});
                const o = this.usedCrossTileIDs[t1.overscaledZ];
                for(const i in this.indexes){
                    const a = this.indexes[i];
                    if (Number(i) > t1.overscaledZ) for(const i in a){
                        const r = a[i];
                        r.tileID.isChildOf(t1) && r.findMatches(e1.symbolInstances, t1, o);
                    }
                    else {
                        const r = a[t1.scaledTo(Number(i)).key];
                        r && r.findMatches(e1.symbolInstances, t1, o);
                    }
                }
                for(let t1 = 0; t1 < e1.symbolInstances.length; t1++){
                    const a = e1.symbolInstances.get(t1);
                    a.crossTileID || (a.crossTileID = i.generate(), o[a.crossTileID] = !0);
                }
                return void 0 === this.indexes[t1.overscaledZ] && (this.indexes[t1.overscaledZ] = {}), this.indexes[t1.overscaledZ][t1.key] = new qt(t1, e1.symbolInstances, e1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(t1, e1) {
                for(const i in e1.indexedSymbolInstances)for (const o of e1.indexedSymbolInstances[i])delete this.usedCrossTileIDs[t1][o.crossTileID];
            }
            removeStaleBuckets(t1) {
                let e1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const a in o)t1[o[a].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[a]), delete o[a], e1 = !0);
                }
                return e1;
            }
        }
        class Xt {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new jt, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(t1, e1, i) {
                let o = this.layerIndexes[t1.id];
                void 0 === o && (o = this.layerIndexes[t1.id] = new $t);
                let a = !1;
                const r = {};
                o.handleWrapJump(i);
                for (const i of e1){
                    const e1 = i.getBucket(t1);
                    e1 && t1.id === e1.layerIds[0] && (e1.bucketInstanceId || (e1.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(i.tileID, e1, this.crossTileIDs) && (a = !0), r[e1.bucketInstanceId] = !0);
                }
                return o.removeStaleBuckets(r) && (a = !0), a;
            }
            pruneUnusedLayers(t1) {
                const e1 = {};
                t1.forEach((t1)=>{
                    e1[t1] = !0;
                });
                for(const t1 in this.layerIndexes)e1[t1] || delete this.layerIndexes[t1];
            }
        }
        var Wt = t1.createLayout([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        class Ht extends t1.Evented {
            constructor(t1){
                super(), this.sourceCache = t1, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.renderHistory = [], this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, this.renderHistorySize = t1._cache.max, t1.usedForTerrain = !0, t1.tileSize = this.tileSize * 2 ** this.deltaZoom;
            }
            destruct() {
                this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
                for(const t1 in this._tiles){
                    const e1 = this._tiles[t1];
                    e1.textures.forEach((t1)=>t1.destroy()), e1.textures = [];
                }
            }
            update(e1, i) {
                this.sourceCache.update(e1, i), this._renderableTilesKeys = [];
                for (const o of e1.coveringTiles({
                    tileSize: this.tileSize,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    reparseOverscaled: !1,
                    terrain: i
                }))this._renderableTilesKeys.push(o.key), this._tiles[o.key] || (o.posMatrix = new Float64Array(16), t1.ortho(o.posMatrix, 0, t1.EXTENT, 0, t1.EXTENT, 0, 1), this._tiles[o.key] = new k(o, this.tileSize));
            }
            removeOutdated(t1) {
                const e1 = {};
                this.renderHistory = this.renderHistory.filter((t1, e1)=>this.renderHistory.indexOf(t1) === e1).slice(0, this.renderHistorySize);
                for (const t1 of this._renderableTilesKeys)e1[t1] = !0;
                for (const t1 of this.renderHistory)e1[t1] = !0;
                for(const i in this._tiles)e1[i] || (this._tiles[i].clearTextures(t1), delete this._tiles[i]);
            }
            getRenderableTiles() {
                return this._renderableTilesKeys.map((t1)=>this.getTileByID(t1));
            }
            getTileByID(t1) {
                return this._tiles[t1];
            }
            getTerrainCoords(e1) {
                const i = {};
                for (const o of this._renderableTilesKeys){
                    const a = this._tiles[o].tileID;
                    if (a.canonical.equals(e1.canonical)) {
                        const a = e1.clone();
                        a.posMatrix = new Float64Array(16), t1.ortho(a.posMatrix, 0, t1.EXTENT, 0, t1.EXTENT, 0, 1), i[o] = a;
                    } else if (a.canonical.isChildOf(e1.canonical)) {
                        const r = e1.clone();
                        r.posMatrix = new Float64Array(16);
                        const s = a.canonical.z - e1.canonical.z, n = a.canonical.x - (a.canonical.x >> s << s), l = a.canonical.y - (a.canonical.y >> s << s), c = t1.EXTENT >> s;
                        t1.ortho(r.posMatrix, 0, c, 0, c, 0, 1), t1.translate(r.posMatrix, r.posMatrix, [
                            -n * c,
                            -l * c,
                            0
                        ]), i[o] = r;
                    } else if (e1.canonical.isChildOf(a.canonical)) {
                        const r = e1.clone();
                        r.posMatrix = new Float64Array(16);
                        const s = e1.canonical.z - a.canonical.z, n = e1.canonical.x - (e1.canonical.x >> s << s), l = e1.canonical.y - (e1.canonical.y >> s << s), c = t1.EXTENT >> s;
                        t1.ortho(r.posMatrix, 0, t1.EXTENT, 0, t1.EXTENT, 0, 1), t1.translate(r.posMatrix, r.posMatrix, [
                            n * c,
                            l * c,
                            0
                        ]), t1.scale(r.posMatrix, r.posMatrix, [
                            1 / 2 ** s,
                            1 / 2 ** s,
                            0
                        ]), i[o] = r;
                    }
                }
                return i;
            }
            getSourceTile(t1, e1) {
                const i = this.sourceCache._source;
                let o = t1.overscaledZ - this.deltaZoom;
                if (o > i.maxzoom && (o = i.maxzoom), o < i.minzoom) return null;
                this._sourceTileCache[t1.key] || (this._sourceTileCache[t1.key] = t1.scaledTo(o).key);
                let a = this.sourceCache.getTileByID(this._sourceTileCache[t1.key]);
                if ((!a || !a.dem) && e1) for(; o >= i.minzoom && (!a || !a.dem);)a = this.sourceCache.getTileByID(t1.scaledTo(o--).key);
                return a;
            }
            tilesAfterTime(t1 = Date.now()) {
                return Object.values(this._tiles).filter((e1)=>e1.timeLoaded >= t1);
            }
        }
        class Kt {
            constructor(t1, e1, i){
                this.style = t1, this.sourceCache = new Ht(e1), this.options = i, this.exaggeration = "number" == typeof i.exaggeration ? i.exaggeration : 1, this.elevationOffset = "number" == typeof i.elevationOffset ? i.elevationOffset : 450, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024, this.clearRerenderCache();
            }
            getDEMElevation(e1, i, o, a = t1.EXTENT) {
                if (!(i >= 0 && i < a && o >= 0 && o < a)) return this.elevationOffset;
                let r = 0;
                const s = this.getTerrainData(e1);
                if (s.tile && s.tile.dem) {
                    const e1 = t1.transformMat4$1([], [
                        i / a * t1.EXTENT,
                        o / a * t1.EXTENT
                    ], s.u_terrain_matrix), n = [
                        e1[0] * s.tile.dem.dim,
                        e1[1] * s.tile.dem.dim
                    ], l = [
                        Math.floor(n[0]),
                        Math.floor(n[1])
                    ], c = s.tile.dem.get(l[0], l[1]), h = s.tile.dem.get(l[0], l[1] + 1), u = s.tile.dem.get(l[0] + 1, l[1]), d = s.tile.dem.get(l[0] + 1, l[1] + 1);
                    r = t1.number(t1.number(c, h, n[0] - l[0]), t1.number(u, d, n[0] - l[0]), n[1] - l[1]);
                }
                return r;
            }
            rememberForRerender(t1, e1) {
                for(const i in this.sourceCache._tiles){
                    const o = this.sourceCache._tiles[i];
                    (o.tileID.equals(e1) || o.tileID.isChildOf(e1)) && (t1 === this.sourceCache.sourceCache.id && (o.timeLoaded = Date.now()), this._rerender[t1] = this._rerender[t1] || {}, this._rerender[t1][o.tileID.key] = !0);
                }
            }
            needsRerender(t1, e1) {
                return this._rerender[t1] && this._rerender[t1][e1.key];
            }
            clearRerenderCache() {
                this._rerender = {};
            }
            getElevation(e1, i, o, a = t1.EXTENT) {
                return (this.getDEMElevation(e1, i, o, a) + this.elevationOffset) * this.exaggeration;
            }
            getTerrainData(e1) {
                if (!this._emptyDemTexture) {
                    const e1 = this.style.map.painter.context, i = new t1.RGBAImage({
                        width: 1,
                        height: 1
                    }, new Uint8Array(4));
                    this._emptyDepthTexture = new l(e1, i, e1.gl.RGBA, {
                        premultiply: !1
                    }), this._emptyDemUnpack = [
                        0,
                        0,
                        0,
                        0
                    ], this._emptyDemTexture = new l(e1, new t1.RGBAImage({
                        width: 1,
                        height: 1
                    }), e1.gl.RGBA, {
                        premultiply: !1
                    }), this._emptyDemTexture.bind(e1.gl.NEAREST, e1.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t1.identity([]);
                }
                const i = this.sourceCache.getSourceTile(e1, !0);
                if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
                    const t1 = this.style.map.painter.context;
                    i.demTexture = this.style.map.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), {
                        premultiply: !1
                    }) : i.demTexture = new l(t1, i.dem.getPixels(), t1.gl.RGBA, {
                        premultiply: !1
                    }), i.demTexture.bind(t1.gl.NEAREST, t1.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1;
                }
                const o = i && i + i.tileID.key + e1.key;
                if (o && !this._demMatrixCache[o]) {
                    const o = this.sourceCache.sourceCache._source.maxzoom;
                    let a = e1.canonical.z - i.tileID.canonical.z;
                    e1.overscaledZ > e1.canonical.z && (e1.canonical.z >= o ? a = e1.canonical.z - o : t1.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                    const r = e1.canonical.x - (e1.canonical.x >> a << a), s = e1.canonical.y - (e1.canonical.y >> a << a), n = t1.fromScaling(new Float64Array(16), [
                        1 / (t1.EXTENT << a),
                        1 / (t1.EXTENT << a),
                        0
                    ]);
                    t1.translate(n, n, [
                        r * t1.EXTENT,
                        s * t1.EXTENT,
                        0
                    ]), this._demMatrixCache[e1.key] = {
                        matrix: n,
                        coord: e1
                    };
                }
                return {
                    u_depth: 2,
                    u_terrain: 3,
                    u_terrain_dim: i && i.dem && i.dem.dim || 1,
                    u_terrain_matrix: o ? this._demMatrixCache[e1.key].matrix : this._emptyDemMatrix,
                    u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack,
                    u_terrain_offset: this.elevationOffset,
                    u_terrain_exaggeration: this.exaggeration,
                    texture: (i && i.demTexture || this._emptyDemTexture).texture,
                    depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
                    tile: i
                };
            }
            getRTTFramebuffer() {
                const t1 = this.style.map.painter;
                if (!this._rttFramebuffer) {
                    const e1 = this.sourceCache.tileSize * this.qualityFactor;
                    this._rttFramebuffer = t1.context.createFramebuffer(e1, e1, !0), this._rttFramebuffer.depthAttachment.set(t1.context.createRenderbuffer(t1.context.gl.DEPTH_COMPONENT16, e1, e1));
                }
                return this._rttFramebuffer;
            }
            getFramebuffer(t1) {
                const e1 = this.style.map.painter, i = e1.width / devicePixelRatio, o = e1.height / devicePixelRatio;
                return !this._fbo || this._fbo.width === i && this._fbo.height === o || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new l(e1.context, {
                    width: i,
                    height: o,
                    data: null
                }, e1.context.gl.RGBA, {
                    premultiply: !1
                }), this._fboCoordsTexture.bind(e1.context.gl.NEAREST, e1.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new l(e1.context, {
                    width: i,
                    height: o,
                    data: null
                }, e1.context.gl.RGBA, {
                    premultiply: !1
                }), this._fboDepthTexture.bind(e1.context.gl.NEAREST, e1.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e1.context.createFramebuffer(i, o, !0), this._fbo.depthAttachment.set(e1.context.createRenderbuffer(e1.context.gl.DEPTH_COMPONENT16, i, o))), this._fbo.colorAttachment.set("coords" === t1 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
                const e1 = this.style.map.painter.context;
                if (this._coordsTexture) return this._coordsTexture;
                const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                for(let t1 = 0, e1 = 0; t1 < this._coordsTextureSize; t1++)for(let o = 0; o < this._coordsTextureSize; o++, e1 += 4)i[e1 + 0] = 255 & o, i[e1 + 1] = 255 & t1, i[e1 + 2] = o >> 8 << 4 | t1 >> 8, i[e1 + 3] = 0;
                const o = new t1.RGBAImage({
                    width: this._coordsTextureSize,
                    height: this._coordsTextureSize
                }, new Uint8Array(i.buffer)), a = new l(e1, o, e1.gl.RGBA, {
                    premultiply: !1
                });
                return a.bind(e1.gl.NEAREST, e1.gl.CLAMP_TO_EDGE), this._coordsTexture = a, a;
            }
            pointCoordinate(e1) {
                const i = new Uint8Array(4), o = this.style.map.painter, a = o.context, r = a.gl;
                a.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r.readPixels(e1.x, o.height / devicePixelRatio - e1.y - 1, 1, 1, r.RGBA, r.UNSIGNED_BYTE, i), a.bindFramebuffer.set(null);
                const s = i[0] + (i[2] >> 4 << 8), n = i[1] + ((15 & i[2]) << 8), l = this.coordsIndex[255 - i[3]], c = l && this.sourceCache.getTileByID(l);
                if (!c) return null;
                const h = this._coordsTextureSize, u = (1 << c.tileID.canonical.z) * h;
                return new t1.MercatorCoordinate((c.tileID.canonical.x * h + s) / u, (c.tileID.canonical.y * h + n) / u, this.getElevation(c.tileID, s, n, h));
            }
            getTerrainMesh() {
                if (this._mesh) return this._mesh;
                const e1 = this.style.map.painter.context, i = new t1.PosArray, o = new t1.TriangleIndexArray, a = this.meshSize, r = t1.EXTENT / a, s = a * a;
                for(let t1 = 0; t1 <= a; t1++)for(let e1 = 0; e1 <= a; e1++)i.emplaceBack(e1 * r, t1 * r);
                for(let t1 = 0; t1 < s; t1 += a + 1)for(let e1 = 0; e1 < a; e1++)o.emplaceBack(e1 + t1, a + e1 + t1 + 1, a + e1 + t1 + 2), o.emplaceBack(e1 + t1, a + e1 + t1 + 2, e1 + t1 + 1);
                return this._mesh = {
                    indexBuffer: e1.createIndexBuffer(o),
                    vertexBuffer: e1.createVertexBuffer(i, Wt.members),
                    segments: t1.SegmentVector.simpleSegment(0, 0, i.length, o.length)
                }, this._mesh;
            }
            getMinMaxElevation(t1) {
                const e1 = this.getTerrainData(t1).tile, i = {
                    minElevation: null,
                    maxElevation: null
                };
                return e1 && e1.dem && (i.minElevation = (e1.dem.min + this.elevationOffset) * this.exaggeration, i.maxElevation = (e1.dem.max + this.elevationOffset) * this.exaggeration), i;
            }
        }
        const Yt = (e1, i)=>t1.emitValidationErrors(e1, i && i.filter((t1)=>"source.canvas" !== t1.identifier)), Jt = t1.pick(W, [
            "addLayer",
            "removeLayer",
            "setPaintProperty",
            "setLayoutProperty",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData"
        ]), Qt = t1.pick(W, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), te = function() {
            const e1 = {}, i = t1.spec.$version;
            for(const o in t1.spec.$root){
                const a = t1.spec.$root[o];
                if (a.required) {
                    let t1 = null;
                    t1 = "version" === o ? i : "array" === a.type ? [] : {}, null != t1 && (e1[o] = t1);
                }
            }
            return e1;
        }();
        class ee extends t1.Evented {
            constructor(e1, i = {}){
                super(), this.map = e1, this.dispatcher = new v(j(), this), this.imageManager = new h, this.imageManager.setEventedParent(this), this.glyphManager = new _(e1._requestManager, i.localIdeographFontFamily), this.lineAtlas = new x(256, 512), this.crossTileSymbolIndex = new Xt, this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t1.ZoomHistory, this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t1.getReferrer());
                const o = this;
                this._rtlTextPluginCallback = ee.registerForPluginStateChange((e1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: e1.pluginStatus,
                        pluginURL: e1.pluginURL
                    }, (e1, i)=>{
                        if (t1.triggerPluginCompletionEvent(e1), i && i.every((t1)=>t1)) for(const t1 in o.sourceCaches)o.sourceCaches[t1].reload();
                    });
                }), this.on("data", (t1)=>{
                    if ("source" !== t1.dataType || "metadata" !== t1.sourceDataType) return;
                    const e1 = this.sourceCaches[t1.sourceId];
                    if (!e1) return;
                    const i = e1.getSource();
                    if (i && i.vectorLayerIds) for(const t1 in this._layers){
                        const e1 = this._layers[t1];
                        e1.source === i.id && this._validateLayer(e1);
                    }
                });
            }
            loadURL(e1, i = {}) {
                this.fire(new t1.Event("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" != typeof i.validate || i.validate, a = this.map._requestManager.transformRequest(e1, t1.ResourceType.Style);
                this._request = t1.getJSON(a, (e1, i)=>{
                    this._request = null, e1 ? this.fire(new t1.ErrorEvent(e1)) : i && this._load(i, o);
                });
            }
            loadJSON(e1, i = {}) {
                this.fire(new t1.Event("dataloading", {
                    dataType: "style"
                })), this._request = t1.exported.frame(()=>{
                    this._request = null, this._load(e1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new t1.Event("dataloading", {
                    dataType: "style"
                })), this._load(te, !1);
            }
            _load(e1, i) {
                if (i && Yt(this, t1.validateStyle(e1))) return;
                this._loaded = !0, this.stylesheet = e1;
                for(const t1 in e1.sources)this.addSource(t1, e1.sources[t1], {
                    validate: !1
                });
                e1.sprite ? this._loadSprite(e1.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e1.glyphs);
                const o = X(this.stylesheet.layers);
                this._order = o.map((t1)=>t1.id), this._layers = {}, this._serializedLayers = {};
                for (let e1 of o)e1 = t1.createStyleLayer(e1), e1.setEventedParent(this, {
                    layer: {
                        id: e1.id
                    }
                }), this._layers[e1.id] = e1, this._serializedLayers[e1.id] = e1.serialize();
                this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new g(this.stylesheet.light), this.setTerrain(this.stylesheet.terrain), this.fire(new t1.Event("data", {
                    dataType: "style"
                })), this.fire(new t1.Event("style.load"));
            }
            _loadSprite(e1) {
                this._spriteRequest = function(e1, i, o, a) {
                    let r, s, n;
                    const l = o > 1 ? "@2x" : "";
                    let c = t1.getJSON(i.transformRequest(i.normalizeSpriteURL(e1, l, ".json"), t1.ResourceType.SpriteJSON), (t1, e1)=>{
                        c = null, n || (n = t1, r = e1, u());
                    }), h = t1.getImage(i.transformRequest(i.normalizeSpriteURL(e1, l, ".png"), t1.ResourceType.SpriteImage), (t1, e1)=>{
                        h = null, n || (n = t1, s = e1, u());
                    });
                    function u() {
                        if (n) a(n);
                        else if (r && s) {
                            const e1 = t1.exported.getImageData(s), i = {};
                            for(const o in r){
                                const { width: a, height: s, x: n, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: d, content: m } = r[o], _ = new t1.RGBAImage({
                                    width: a,
                                    height: s
                                });
                                t1.RGBAImage.copy(e1, _, {
                                    x: n,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: a,
                                    height: s
                                }), i[o] = {
                                    data: _,
                                    pixelRatio: h,
                                    sdf: c,
                                    stretchX: u,
                                    stretchY: d,
                                    content: m
                                };
                            }
                            a(null, i);
                        }
                    }
                    return {
                        cancel () {
                            c && (c.cancel(), c = null), h && (h.cancel(), h = null);
                        }
                    };
                }(e1, this.map._requestManager, this.map.getPixelRatio(), (e1, i)=>{
                    if (this._spriteRequest = null, e1) this.fire(new t1.ErrorEvent(e1));
                    else if (i) for(const t1 in i)this.imageManager.addImage(t1, i[t1]);
                    this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t1.Event("data", {
                        dataType: "style"
                    }));
                });
            }
            _validateLayer(e1) {
                const i = this.sourceCaches[e1.source];
                if (!i) return;
                const o = e1.sourceLayer;
                if (!o) return;
                const a = i.getSource();
                ("geojson" === a.type || a.vectorLayerIds && -1 === a.vectorLayerIds.indexOf(o)) && this.fire(new t1.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${a.id}" as specified by style layer "${e1.id}".`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._updatedSources).length) return !1;
                for(const t1 in this.sourceCaches)if (!this.sourceCaches[t1].loaded()) return !1;
                return !!this.imageManager.isLoaded();
            }
            _serializeLayers(t1) {
                const e1 = [];
                for (const i of t1){
                    const t1 = this._layers[i];
                    "custom" !== t1.type && e1.push(t1.serialize());
                }
                return e1;
            }
            hasTransitions() {
                if (this.light && this.light.hasTransition()) return !0;
                for(const t1 in this.sourceCaches)if (this.sourceCaches[t1].hasTransition()) return !0;
                for(const t1 in this._layers)if (this._layers[t1].hasTransition()) return !0;
                return !1;
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading.");
            }
            update(e1) {
                if (!this._loaded) return;
                const i = this._changed;
                if (this._changed) {
                    const t1 = Object.keys(this._updatedLayers), i = Object.keys(this._removedLayers);
                    (t1.length || i.length) && this._updateWorkerLayers(t1, i);
                    for(const t1 in this._updatedSources){
                        const e1 = this._updatedSources[t1];
                        if ("reload" === e1) this._reloadSource(t1);
                        else {
                            if ("clear" !== e1) throw new Error(`Invalid action ${e1}`);
                            this._clearSource(t1);
                        }
                    }
                    this._updateTilesForChangedImages();
                    for(const t1 in this._updatedPaintProps)this._layers[t1].updateTransitions(e1);
                    this.light.updateTransitions(e1), this._resetUpdates();
                }
                const o = {};
                for(const t1 in this.sourceCaches){
                    const e1 = this.sourceCaches[t1];
                    o[t1] = e1.used, e1.used = !1;
                }
                for (const t1 of this._order){
                    const i = this._layers[t1];
                    i.recalculate(e1, this._availableImages), !i.isHidden(e1.zoom) && i.source && (this.sourceCaches[i.source].used = !0);
                }
                for(const e1 in o){
                    const i = this.sourceCaches[e1];
                    o[e1] !== i.used && i.fire(new t1.Event("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: e1
                    }));
                }
                this.light.recalculate(e1), this.z = e1.zoom, i && this.fire(new t1.Event("data", {
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const t1 = Object.keys(this._changedImages);
                if (t1.length) {
                    for(const e1 in this.sourceCaches)this.sourceCaches[e1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], t1);
                    this._changedImages = {};
                }
            }
            _updateWorkerLayers(t1, e1) {
                this.dispatcher.broadcast("updateLayers", {
                    layers: this._serializeLayers(t1),
                    removedIds: e1
                });
            }
            _resetUpdates() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setTerrain(e1) {
                if (this._checkLoaded(), this._terrainDataCallback && this.off("data", this._terrainDataCallback), this._terrainfreezeElevationCallback && this.map.off("freezeElevation", this._terrainfreezeElevationCallback), e1) {
                    const t1 = this.sourceCaches[e1.source];
                    if (!t1) throw new Error(`cannot load terrain, because there exists no source with ID: ${e1.source}`);
                    this.terrain = new Kt(this, t1, e1), this.map.transform.updateElevation(this.terrain), this._terrainfreezeElevationCallback = (t1)=>{
                        t1.freeze ? this.map.transform.freezeElevation = !0 : (this.map.transform.freezeElevation = !1, this.map.transform.recalculateZoom(this.terrain));
                    }, this._terrainDataCallback = (t1)=>{
                        t1.tile && (t1.sourceId === e1.source ? (this.map.transform.updateElevation(this.terrain), this.terrain.rememberForRerender(t1.sourceId, t1.tile.tileID)) : "geojson" === t1.source.type && this.terrain.rememberForRerender(t1.sourceId, t1.tile.tileID));
                    }, this.on("data", this._terrainDataCallback), this.map.on("freezeElevation", this._terrainfreezeElevationCallback);
                } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.map.transform.updateElevation(this.terrain);
                this.map.fire(new t1.Event("terrain", {
                    terrain: e1
                }));
            }
            setState(e1) {
                if (this._checkLoaded(), Yt(this, t1.validateStyle(e1))) return !1;
                (e1 = t1.clone$1(e1)).layers = X(e1.layers);
                const i = (function(t1, e1) {
                    if (!t1) return [
                        {
                            command: W.setStyle,
                            args: [
                                e1
                            ]
                        }
                    ];
                    let i = [];
                    try {
                        if (!a(t1.version, e1.version)) return [
                            {
                                command: W.setStyle,
                                args: [
                                    e1
                                ]
                            }
                        ];
                        a(t1.center, e1.center) || i.push({
                            command: W.setCenter,
                            args: [
                                e1.center
                            ]
                        }), a(t1.zoom, e1.zoom) || i.push({
                            command: W.setZoom,
                            args: [
                                e1.zoom
                            ]
                        }), a(t1.bearing, e1.bearing) || i.push({
                            command: W.setBearing,
                            args: [
                                e1.bearing
                            ]
                        }), a(t1.pitch, e1.pitch) || i.push({
                            command: W.setPitch,
                            args: [
                                e1.pitch
                            ]
                        }), a(t1.sprite, e1.sprite) || i.push({
                            command: W.setSprite,
                            args: [
                                e1.sprite
                            ]
                        }), a(t1.glyphs, e1.glyphs) || i.push({
                            command: W.setGlyphs,
                            args: [
                                e1.glyphs
                            ]
                        }), a(t1.transition, e1.transition) || i.push({
                            command: W.setTransition,
                            args: [
                                e1.transition
                            ]
                        }), a(t1.light, e1.light) || i.push({
                            command: W.setLight,
                            args: [
                                e1.light
                            ]
                        });
                        const o = {}, r = [];
                        !function(t1, e1, i, o) {
                            let r;
                            for(r in e1 = e1 || {}, t1 = t1 || {})Object.prototype.hasOwnProperty.call(t1, r) && (Object.prototype.hasOwnProperty.call(e1, r) || K(r, i, o));
                            for(r in e1)Object.prototype.hasOwnProperty.call(e1, r) && (Object.prototype.hasOwnProperty.call(t1, r) ? a(t1[r], e1[r]) || ("geojson" === t1[r].type && "geojson" === e1[r].type && J(t1, e1, r) ? i.push({
                                command: W.setGeoJSONSourceData,
                                args: [
                                    r,
                                    e1[r].data
                                ]
                            }) : Y(r, e1, i, o)) : H(r, e1, i));
                        }(t1.sources, e1.sources, r, o);
                        const s = [];
                        t1.layers && t1.layers.forEach((t1)=>{
                            o[t1.source] ? i.push({
                                command: W.removeLayer,
                                args: [
                                    t1.id
                                ]
                            }) : s.push(t1);
                        }), i = i.concat(r), function(t1, e1, i) {
                            e1 = e1 || [];
                            const o = (t1 = t1 || []).map(tt), r = e1.map(tt), s = t1.reduce(et, {}), n = e1.reduce(et, {}), l = o.slice(), c = Object.create(null);
                            let h, u, d, m, _, p, f;
                            for(h = 0, u = 0; h < o.length; h++)d = o[h], Object.prototype.hasOwnProperty.call(n, d) ? u++ : (i.push({
                                command: W.removeLayer,
                                args: [
                                    d
                                ]
                            }), l.splice(l.indexOf(d, u), 1));
                            for(h = 0, u = 0; h < r.length; h++)d = r[r.length - 1 - h], l[l.length - 1 - h] !== d && (Object.prototype.hasOwnProperty.call(s, d) ? (i.push({
                                command: W.removeLayer,
                                args: [
                                    d
                                ]
                            }), l.splice(l.lastIndexOf(d, l.length - u), 1)) : u++, p = l[l.length - h], i.push({
                                command: W.addLayer,
                                args: [
                                    n[d],
                                    p
                                ]
                            }), l.splice(l.length - h, 0, d), c[d] = !0);
                            for(h = 0; h < r.length; h++)if (d = r[h], m = s[d], _ = n[d], !c[d] && !a(m, _)) {
                                if (a(m.source, _.source) && a(m["source-layer"], _["source-layer"]) && a(m.type, _.type)) {
                                    for(f in Q(m.layout, _.layout, i, d, null, W.setLayoutProperty), Q(m.paint, _.paint, i, d, null, W.setPaintProperty), a(m.filter, _.filter) || i.push({
                                        command: W.setFilter,
                                        args: [
                                            d,
                                            _.filter
                                        ]
                                    }), a(m.minzoom, _.minzoom) && a(m.maxzoom, _.maxzoom) || i.push({
                                        command: W.setLayerZoomRange,
                                        args: [
                                            d,
                                            _.minzoom,
                                            _.maxzoom
                                        ]
                                    }), m)Object.prototype.hasOwnProperty.call(m, f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Q(m[f], _[f], i, d, f.slice(6), W.setPaintProperty) : a(m[f], _[f]) || i.push({
                                        command: W.setLayerProperty,
                                        args: [
                                            d,
                                            f,
                                            _[f]
                                        ]
                                    }));
                                    for(f in _)Object.prototype.hasOwnProperty.call(_, f) && !Object.prototype.hasOwnProperty.call(m, f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Q(m[f], _[f], i, d, f.slice(6), W.setPaintProperty) : a(m[f], _[f]) || i.push({
                                        command: W.setLayerProperty,
                                        args: [
                                            d,
                                            f,
                                            _[f]
                                        ]
                                    }));
                                } else i.push({
                                    command: W.removeLayer,
                                    args: [
                                        d
                                    ]
                                }), p = l[l.lastIndexOf(d) + 1], i.push({
                                    command: W.addLayer,
                                    args: [
                                        _,
                                        p
                                    ]
                                });
                            }
                        }(s, e1.layers, i);
                    } catch (t1) {
                        console.warn("Unable to compute style diff:", t1), i = [
                            {
                                command: W.setStyle,
                                args: [
                                    e1
                                ]
                            }
                        ];
                    }
                    return i;
                })(this.serialize(), e1).filter((t1)=>!(t1.command in Qt));
                if (0 === i.length) return !1;
                const o = i.filter((t1)=>!(t1.command in Jt));
                if (o.length > 0) throw new Error(`Unimplemented: ${o.map((t1)=>t1.command).join(", ")}.`);
                return i.forEach((t1)=>{
                    "setTransition" !== t1.command && this[t1.command].apply(this, t1.args);
                }), this.stylesheet = e1, !0;
            }
            addImage(e1, i) {
                if (this.getImage(e1)) return this.fire(new t1.ErrorEvent(new Error(`An image named "${e1}" already exists.`)));
                this.imageManager.addImage(e1, i), this._afterImageUpdated(e1);
            }
            updateImage(t1, e1) {
                this.imageManager.updateImage(t1, e1);
            }
            getImage(t1) {
                return this.imageManager.getImage(t1);
            }
            removeImage(e1) {
                if (!this.getImage(e1)) return this.fire(new t1.ErrorEvent(new Error(`An image named "${e1}" does not exist.`)));
                this.imageManager.removeImage(e1), this._afterImageUpdated(e1);
            }
            _afterImageUpdated(e1) {
                this._availableImages = this.imageManager.listImages(), this._changedImages[e1] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t1.Event("data", {
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.sourceCaches[e1]) throw new Error(`Source "${e1}" already exists.`);
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(t1.validateStyle.source, `sources.${e1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const a = this.sourceCaches[e1] = new O(e1, i, this.dispatcher);
                a.style = this, a.setEventedParent(this, ()=>({
                        isSourceLoaded: this.loaded(),
                        source: a.serialize(),
                        sourceId: e1
                    })), a.onAdd(this.map), this._changed = !0;
            }
            removeSource(e1) {
                if (this._checkLoaded(), void 0 === this.sourceCaches[e1]) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === e1) return this.fire(new t1.ErrorEvent(new Error(`Source "${e1}" cannot be removed while layer "${i}" is using it.`)));
                const i = this.sourceCaches[e1];
                delete this.sourceCaches[e1], delete this._updatedSources[e1], i.fire(new t1.Event("data", {
                    sourceDataType: "metadata",
                    dataType: "source",
                    sourceId: e1
                })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0;
            }
            setGeoJSONSourceData(t1, e1) {
                if (this._checkLoaded(), void 0 === this.sourceCaches[t1]) throw new Error(`There is no source with this ID=${t1}`);
                const i = this.sourceCaches[t1].getSource();
                if ("geojson" !== i.type) throw new Error(`geojsonSource.type is ${i.type}, which is !== 'geojson`);
                i.setData(e1), this._changed = !0;
            }
            getSource(t1) {
                return this.sourceCaches[t1] && this.sourceCaches[t1].getSource();
            }
            addLayer(e1, i, o = {}) {
                this._checkLoaded();
                const a = e1.id;
                if (this.getLayer(a)) return void this.fire(new t1.ErrorEvent(new Error(`Layer "${a}" already exists on this map.`)));
                let r;
                if ("custom" === e1.type) {
                    if (Yt(this, t1.validateCustomStyleLayer(e1))) return;
                    r = t1.createStyleLayer(e1);
                } else {
                    if ("object" == typeof e1.source && (this.addSource(a, e1.source), e1 = t1.clone$1(e1), e1 = t1.extend(e1, {
                        source: a
                    })), this._validate(t1.validateStyle.layer, `layers.${a}`, e1, {
                        arrayIndex: -1
                    }, o)) return;
                    r = t1.createStyleLayer(e1), this._validateLayer(r), r.setEventedParent(this, {
                        layer: {
                            id: a
                        }
                    }), this._serializedLayers[r.id] = r.serialize();
                }
                const s = i ? this._order.indexOf(i) : this._order.length;
                if (i && -1 === s) this.fire(new t1.ErrorEvent(new Error(`Cannot add layer "${a}" before non-existing layer "${i}".`)));
                else {
                    if (this._order.splice(s, 0, a), this._layerOrderChanged = !0, this._layers[a] = r, this._removedLayers[a] && r.source && "custom" !== r.type) {
                        const t1 = this._removedLayers[a];
                        delete this._removedLayers[a], t1.type !== r.type ? this._updatedSources[r.source] = "clear" : (this._updatedSources[r.source] = "reload", this.sourceCaches[r.source].pause());
                    }
                    this._updateLayer(r), r.onAdd && r.onAdd(this.map);
                }
            }
            moveLayer(e1, i) {
                if (this._checkLoaded(), this._changed = !0, !this._layers[e1]) return void this.fire(new t1.ErrorEvent(new Error(`The layer '${e1}' does not exist in the map's style and cannot be moved.`)));
                if (e1 === i) return;
                const o = this._order.indexOf(e1);
                this._order.splice(o, 1);
                const a = i ? this._order.indexOf(i) : this._order.length;
                i && -1 === a ? this.fire(new t1.ErrorEvent(new Error(`Cannot move layer "${e1}" before non-existing layer "${i}".`))) : (this._order.splice(a, 0, e1), this._layerOrderChanged = !0);
            }
            removeLayer(e1) {
                this._checkLoaded();
                const i = this._layers[e1];
                if (!i) return void this.fire(new t1.ErrorEvent(new Error(`Cannot remove non-existing layer "${e1}".`)));
                i.setEventedParent(null);
                const o = this._order.indexOf(e1);
                this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e1] = i, delete this._layers[e1], delete this._serializedLayers[e1], delete this._updatedLayers[e1], delete this._updatedPaintProps[e1], i.onRemove && i.onRemove(this.map);
            }
            getLayer(t1) {
                return this._layers[t1];
            }
            hasLayer(t1) {
                return t1 in this._layers;
            }
            setLayerZoomRange(e1, i, o) {
                this._checkLoaded();
                const a = this.getLayer(e1);
                a ? a.minzoom === i && a.maxzoom === o || (null != i && (a.minzoom = i), null != o && (a.maxzoom = o), this._updateLayer(a)) : this.fire(new t1.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e1}".`)));
            }
            setFilter(e1, i, o = {}) {
                this._checkLoaded();
                const r = this.getLayer(e1);
                if (r) {
                    if (!a(r.filter, i)) return null == i ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(t1.validateStyle.filter, `layers.${r.id}.filter`, i, null, o) || (r.filter = t1.clone$1(i), this._updateLayer(r)));
                } else this.fire(new t1.ErrorEvent(new Error(`Cannot filter non-existing layer "${e1}".`)));
            }
            getFilter(e1) {
                return t1.clone$1(this.getLayer(e1).filter);
            }
            setLayoutProperty(e1, i, o, r = {}) {
                this._checkLoaded();
                const s = this.getLayer(e1);
                s ? a(s.getLayoutProperty(i), o) || (s.setLayoutProperty(i, o, r), this._updateLayer(s)) : this.fire(new t1.ErrorEvent(new Error(`Cannot style non-existing layer "${e1}".`)));
            }
            getLayoutProperty(e1, i) {
                const o = this.getLayer(e1);
                if (o) return o.getLayoutProperty(i);
                this.fire(new t1.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e1}".`)));
            }
            setPaintProperty(e1, i, o, r = {}) {
                this._checkLoaded();
                const s = this.getLayer(e1);
                s ? a(s.getPaintProperty(i), o) || (s.setPaintProperty(i, o, r) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[e1] = !0) : this.fire(new t1.ErrorEvent(new Error(`Cannot style non-existing layer "${e1}".`)));
            }
            getPaintProperty(t1, e1) {
                return this.getLayer(t1).getPaintProperty(e1);
            }
            setFeatureState(e1, i) {
                this._checkLoaded();
                const o = e1.source, a = e1.sourceLayer, r = this.sourceCaches[o];
                if (void 0 === r) return void this.fire(new t1.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
                const s = r.getSource().type;
                "geojson" === s && a ? this.fire(new t1.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s || a ? (void 0 === e1.id && this.fire(new t1.ErrorEvent(new Error("The feature id parameter must be provided."))), r.setFeatureState(a, e1.id, i)) : this.fire(new t1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e1, i) {
                this._checkLoaded();
                const o = e1.source, a = this.sourceCaches[o];
                if (void 0 === a) return void this.fire(new t1.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
                const r = a.getSource().type, s = "vector" === r ? e1.sourceLayer : void 0;
                "vector" !== r || s ? i && "string" != typeof e1.id && "number" != typeof e1.id ? this.fire(new t1.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a.removeFeatureState(s, e1.id, i) : this.fire(new t1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e1) {
                this._checkLoaded();
                const i = e1.source, o = e1.sourceLayer, a = this.sourceCaches[i];
                if (void 0 !== a) return "vector" !== a.getSource().type || o ? (void 0 === e1.id && this.fire(new t1.ErrorEvent(new Error("The feature id parameter must be provided."))), a.getFeatureState(o, e1.id)) : void this.fire(new t1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                this.fire(new t1.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
            }
            getTransition() {
                return t1.extend({
                    duration: 300,
                    delay: 0
                }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
                return t1.filterObject({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    sources: t1.mapObject(this.sourceCaches, (t1)=>t1.serialize()),
                    layers: this._serializeLayers(this._order)
                }, (t1)=>void 0 !== t1);
            }
            _updateLayer(t1) {
                this._updatedLayers[t1.id] = !0, t1.source && !this._updatedSources[t1.source] && "raster" !== this.sourceCaches[t1.source].getSource().type && (this._updatedSources[t1.source] = "reload", this.sourceCaches[t1.source].pause()), this._changed = !0;
            }
            _flattenAndSortRenderedFeatures(t1) {
                const e1 = (t1)=>"fill-extrusion" === this._layers[t1].type, i = {}, o = [];
                for(let a = this._order.length - 1; a >= 0; a--){
                    const r = this._order[a];
                    if (e1(r)) {
                        i[r] = a;
                        for (const e1 of t1){
                            const t1 = e1[r];
                            if (t1) for (const e1 of t1)o.push(e1);
                        }
                    }
                }
                o.sort((t1, e1)=>e1.intersectionZ - t1.intersectionZ);
                const a = [];
                for(let r = this._order.length - 1; r >= 0; r--){
                    const s = this._order[r];
                    if (e1(s)) for(let t1 = o.length - 1; t1 >= 0; t1--){
                        const e1 = o[t1].feature;
                        if (i[e1.layer.id] < r) break;
                        a.push(e1), o.pop();
                    }
                    else for (const e1 of t1){
                        const t1 = e1[s];
                        if (t1) for (const e1 of t1)a.push(e1.feature);
                    }
                }
                return a;
            }
            queryRenderedFeatures(e1, i, o) {
                i && i.filter && this._validate(t1.validateStyle.filter, "queryRenderedFeatures.filter", i.filter, null, i);
                const a = {};
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new t1.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                    for (const e1 of i.layers){
                        const i = this._layers[e1];
                        if (!i) return this.fire(new t1.ErrorEvent(new Error(`The layer '${e1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        a[i.source] = !0;
                    }
                }
                const r = [];
                i.availableImages = this._availableImages;
                for(const t1 in this.sourceCaches)i.layers && !a[t1] || r.push(L(this.sourceCaches[t1], this._layers, this._serializedLayers, e1, i, o));
                return this.placement && r.push(function(t1, e1, i, o, a, r, s) {
                    const n = {}, l = r.queryRenderedSymbols(o), c = [];
                    for (const t1 of Object.keys(l).map(Number))c.push(s[t1]);
                    c.sort(R);
                    for (const i of c){
                        const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e1, i.bucketIndex, i.sourceLayerIndex, a.filter, a.layers, a.availableImages, t1);
                        for(const t1 in o){
                            const e1 = n[t1] = n[t1] || [], a = o[t1];
                            a.sort((t1, e1)=>{
                                const o = i.featureSortOrder;
                                if (o) {
                                    const i = o.indexOf(t1.featureIndex);
                                    return o.indexOf(e1.featureIndex) - i;
                                }
                                return e1.featureIndex - t1.featureIndex;
                            });
                            for (const t1 of a)e1.push(t1);
                        }
                    }
                    for(const e1 in n)n[e1].forEach((o)=>{
                        const a = o.feature, r = i[t1[e1].source].getFeatureState(a.layer["source-layer"], a.id);
                        a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = r;
                    });
                    return n;
                }(this._layers, this._serializedLayers, this.sourceCaches, e1, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(r);
            }
            querySourceFeatures(e1, i) {
                i && i.filter && this._validate(t1.validateStyle.filter, "querySourceFeatures.filter", i.filter, null, i);
                const o = this.sourceCaches[e1];
                return o ? function(t1, e1) {
                    const i = t1.getRenderableIds().map((e1)=>t1.getTileByID(e1)), o = [], a = {};
                    for(let t1 = 0; t1 < i.length; t1++){
                        const r = i[t1], s = r.tileID.canonical.key;
                        a[s] || (a[s] = !0, r.querySourceFeatures(o, e1));
                    }
                    return o;
                }(o, i) : [];
            }
            addSourceType(t1, e1, i) {
                return ee.getSourceType(t1) ? i(new Error(`A source type called "${t1}" already exists.`)) : (ee.setSourceType(t1, e1), e1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: t1,
                    url: e1.workerSourceURL
                }, i) : i(null, null));
            }
            getLight() {
                return this.light.getLight();
            }
            setLight(e1, i = {}) {
                this._checkLoaded();
                const o = this.light.getLight();
                let r = !1;
                for(const t1 in e1)if (!a(e1[t1], o[t1])) {
                    r = !0;
                    break;
                }
                if (!r) return;
                const s = {
                    now: t1.exported.now(),
                    transition: t1.extend({
                        duration: 300,
                        delay: 0
                    }, this.stylesheet.transition)
                };
                this.light.setLight(e1, i), this.light.updateTransitions(s);
            }
            _validate(e1, i, o, a, r = {}) {
                return (!r || !1 !== r.validate) && Yt(this, e1.call(t1.validateStyle, t1.extend({
                    key: i,
                    style: this.serialize(),
                    value: o,
                    styleSpec: t1.spec
                }, a)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t1.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const t1 in this._layers)this._layers[t1].setEventedParent(null);
                for(const t1 in this.sourceCaches){
                    const e1 = this.sourceCaches[t1];
                    e1.setEventedParent(null), e1.onRemove(this.map);
                }
                this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(t1) {
                this.sourceCaches[t1].clearTiles();
            }
            _reloadSource(t1) {
                this.sourceCaches[t1].resume(), this.sourceCaches[t1].reload();
            }
            _updateSources(t1) {
                for(const e1 in this.sourceCaches)this.sourceCaches[e1].update(t1, this.terrain);
            }
            _generateCollisionBoxes() {
                for(const t1 in this.sourceCaches)this._reloadSource(t1);
            }
            _updatePlacement(e1, i, o, a, r = !1) {
                let s = !1, n = !1;
                const l = {};
                for (const t1 of this._order){
                    const i = this._layers[t1];
                    if ("symbol" !== i.type) continue;
                    if (!l[i.source]) {
                        const t1 = this.sourceCaches[i.source];
                        l[i.source] = t1.getRenderableIds(!0).map((e1)=>t1.getTileByID(e1)).sort((t1, e1)=>e1.tileID.overscaledZ - t1.tileID.overscaledZ || (t1.tileID.isLessThan(e1.tileID) ? -1 : 1));
                    }
                    const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], e1.center.lng);
                    s = s || o;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r = r || this._layerOrderChanged || 0 === o) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t1.exported.now(), e1.zoom)) && (this.pauseablePlacement = new Zt(e1, this.terrain, this._order, r, i, o, a, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t1.exported.now()), n = !0), s && this.pauseablePlacement.placement.setStale()), n || s) for (const t1 of this._order){
                    const e1 = this._layers[t1];
                    "symbol" === e1.type && this.placement.updateLayerOpacities(e1, l[e1.source]);
                }
                return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t1.exported.now());
            }
            _releaseSymbolFadeTiles() {
                for(const t1 in this.sourceCaches)this.sourceCaches[t1].releaseSymbolFadeTiles();
            }
            getImages(t1, e1, i) {
                this.imageManager.getImages(e1.icons, i), this._updateTilesForChangedImages();
                const o = this.sourceCaches[e1.source];
                o && o.setDependencies(e1.tileID.key, e1.type, e1.icons);
            }
            getGlyphs(t1, e1, i) {
                this.glyphManager.getGlyphs(e1.stacks, i);
            }
            getResource(e1, i, o) {
                return t1.makeRequest(i, o);
            }
        }
        ee.getSourceType = function(t1) {
            return M[t1];
        }, ee.setSourceType = function(t1, e1) {
            M[t1] = e1;
        }, ee.registerForPluginStateChange = t1.registerForPluginStateChange;
        var ie = "attribute vec2 a_pos;uniform mat4 u_matrix;varying vec2 v_texture_pos;varying float v_depth;void main() {v_texture_pos=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);v_depth=gl_Position.z/gl_Position.w;}";
        const oe = {
            prelude: ae("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_offset;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return (elevation+u_terrain_offset)*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"),
            background: ae("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            backgroundPattern: ae("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
            circle: ae("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
            clippingMask: ae("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: ae("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),
            heatmapTexture: ae("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
            collisionBox: ae("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
            collisionCircle: ae("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: ae("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"),
            fill: ae("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),
            fillOutline: ae("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),
            fillOutlinePattern: ae("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),
            fillPattern: ae("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
            fillExtrusion: ae("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat baseDelta=10.0;float ele=get_elevation(a_centroid);\n#else\nfloat baseDelta=0.0;float ele=0.0;\n#endif\nbase=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
            fillExtrusionPattern: ae("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat baseDelta=10.0;float ele=get_elevation(a_centroid);\n#else\nfloat baseDelta=0.0;float ele=0.0;\n#endif\nbase=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
            hillshadePrepare: ae("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: ae("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),
            line: ae("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
            lineGradient: ae("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
            linePattern: ae("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
            lineSDF: ae("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),
            raster: ae("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
            symbolIcon: ae("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
            symbolSDF: ae("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
            symbolTextAndIcon: ae("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
            terrain: ae("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", ie),
            terrainDepth: ae("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", ie),
            terrainCoords: ae("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", ie)
        };
        function ae(t1, e1) {
            const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = e1.match(/attribute ([\w]+) ([\w]+)/g), a = t1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r = e1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s = r ? r.concat(a) : a, n = {};
            return {
                fragmentSource: t1 = t1.replace(i, (t1, e1, i, o, a)=>(n[a] = !0, "define" === e1 ? `\n#ifndef HAS_UNIFORM_u_${a}\nvarying ${i} ${o} ${a};\n#else\nuniform ${i} ${o} u_${a};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${a}\n    ${i} ${o} ${a} = u_${a};\n#endif\n`)),
                vertexSource: e1 = e1.replace(i, (t1, e1, i, o, a)=>{
                    const r = "float" === o ? "vec2" : "vec4", s = a.match(/color/) ? "color" : r;
                    return n[a] ? "define" === e1 ? `\n#ifndef HAS_UNIFORM_u_${a}\nuniform lowp float u_${a}_t;\nattribute ${i} ${r} a_${a};\nvarying ${i} ${o} ${a};\n#else\nuniform ${i} ${o} u_${a};\n#endif\n` : "vec4" === s ? `\n#ifndef HAS_UNIFORM_u_${a}\n    ${a} = a_${a};\n#else\n    ${i} ${o} ${a} = u_${a};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${a}\n    ${a} = unpack_mix_${s}(a_${a}, u_${a}_t);\n#else\n    ${i} ${o} ${a} = u_${a};\n#endif\n` : "define" === e1 ? `\n#ifndef HAS_UNIFORM_u_${a}\nuniform lowp float u_${a}_t;\nattribute ${i} ${r} a_${a};\n#else\nuniform ${i} ${o} u_${a};\n#endif\n` : "vec4" === s ? `\n#ifndef HAS_UNIFORM_u_${a}\n    ${i} ${o} ${a} = a_${a};\n#else\n    ${i} ${o} ${a} = u_${a};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${a}\n    ${i} ${o} ${a} = unpack_mix_${s}(a_${a}, u_${a}_t);\n#else\n    ${i} ${o} ${a} = u_${a};\n#endif\n`;
                }),
                staticAttributes: o,
                staticUniforms: s
            };
        }
        class re {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(t1, e1, i, o, a, r, s, n, l) {
                this.context = t1;
                let c = this.boundPaintVertexBuffers.length !== o.length;
                for(let t1 = 0; !c && t1 < o.length; t1++)this.boundPaintVertexBuffers[t1] !== o[t1] && (c = !0);
                t1.extVertexArrayObject && this.vao && this.boundProgram === e1 && this.boundLayoutVertexBuffer === i && !c && this.boundIndexBuffer === a && this.boundVertexOffset === r && this.boundDynamicVertexBuffer === s && this.boundDynamicVertexBuffer2 === n && this.boundDynamicVertexBuffer3 === l ? (t1.bindVertexArrayOES.set(this.vao), s && s.bind(), a && a.dynamicDraw && a.bind(), n && n.bind(), l && l.bind()) : this.freshBind(e1, i, o, a, r, s, n, l);
            }
            freshBind(t1, e1, i, o, a, r, s, n) {
                let l;
                const c = t1.numAttributes, h = this.context, u = h.gl;
                if (h.extVertexArrayObject) this.vao && this.destroy(), this.vao = h.extVertexArrayObject.createVertexArrayOES(), h.bindVertexArrayOES.set(this.vao), l = 0, this.boundProgram = t1, this.boundLayoutVertexBuffer = e1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = a, this.boundDynamicVertexBuffer = r, this.boundDynamicVertexBuffer2 = s, this.boundDynamicVertexBuffer3 = n;
                else {
                    l = h.currentNumAttributes || 0;
                    for(let t1 = c; t1 < l; t1++)u.disableVertexAttribArray(t1);
                }
                e1.enableAttributes(u, t1);
                for (const e1 of i)e1.enableAttributes(u, t1);
                r && r.enableAttributes(u, t1), s && s.enableAttributes(u, t1), n && n.enableAttributes(u, t1), e1.bind(), e1.setVertexAttribPointers(u, t1, a);
                for (const e1 of i)e1.bind(), e1.setVertexAttribPointers(u, t1, a);
                r && (r.bind(), r.setVertexAttribPointers(u, t1, a)), o && o.bind(), s && (s.bind(), s.setVertexAttribPointers(u, t1, a)), n && (n.bind(), n.setVertexAttribPointers(u, t1, a)), h.currentNumAttributes = c;
            }
            destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
        }
        function se(t1) {
            const e1 = [];
            for(let i = 0; i < t1.length; i++){
                if (null === t1[i]) continue;
                const o = t1[i].split(" ");
                e1.push(o.pop());
            }
            return e1;
        }
        class ne {
            constructor(e1, i, o, a, r, s, n){
                const l = e1.gl;
                this.program = l.createProgram();
                const c = se(o.staticAttributes), h = a ? a.getBinderAttributes() : [], u = c.concat(h), d = oe.prelude.staticUniforms ? se(oe.prelude.staticUniforms) : [], m = o.staticUniforms ? se(o.staticUniforms) : [], _ = a ? a.getBinderUniforms() : [], p = d.concat(m).concat(_), f = [];
                for (const t1 of p)f.indexOf(t1) < 0 && f.push(t1);
                const g = a ? a.defines() : [];
                s && g.push("#define OVERDRAW_INSPECTOR;"), n && g.push("#define TERRAIN3D;");
                const x = g.concat(oe.prelude.fragmentSource, o.fragmentSource).join("\n"), v = g.concat(oe.prelude.vertexSource, o.vertexSource).join("\n"), y = l.createShader(l.FRAGMENT_SHADER);
                if (l.isContextLost()) return void (this.failedToCreate = !0);
                l.shaderSource(y, x), l.compileShader(y), l.attachShader(this.program, y);
                const b = l.createShader(l.VERTEX_SHADER);
                if (l.isContextLost()) return void (this.failedToCreate = !0);
                l.shaderSource(b, v), l.compileShader(b), l.attachShader(this.program, b), this.attributes = {};
                const w = {};
                this.numAttributes = u.length;
                for(let t1 = 0; t1 < this.numAttributes; t1++)u[t1] && (l.bindAttribLocation(this.program, t1, u[t1]), this.attributes[u[t1]] = t1);
                l.linkProgram(this.program), l.deleteShader(b), l.deleteShader(y);
                for(let t1 = 0; t1 < f.length; t1++){
                    const e1 = f[t1];
                    if (e1 && !w[e1]) {
                        const t1 = l.getUniformLocation(this.program, e1);
                        t1 && (w[e1] = t1);
                    }
                }
                this.fixedUniforms = r(e1, w), this.terrainUniforms = ((e1, i)=>({
                        u_depth: new t1.Uniform1i(e1, i.u_depth),
                        u_terrain: new t1.Uniform1i(e1, i.u_terrain),
                        u_terrain_dim: new t1.Uniform1f(e1, i.u_terrain_dim),
                        u_terrain_matrix: new t1.UniformMatrix4f(e1, i.u_terrain_matrix),
                        u_terrain_unpack: new t1.Uniform4f(e1, i.u_terrain_unpack),
                        u_terrain_offset: new t1.Uniform1f(e1, i.u_terrain_offset),
                        u_terrain_exaggeration: new t1.Uniform1f(e1, i.u_terrain_exaggeration)
                    }))(e1, w), this.binderUniforms = a ? a.getUniforms(e1, w) : [];
            }
            draw(t1, e1, i, o, a, r, s, n, l, c, h, u, d, m, _, p, f, g) {
                const x = t1.gl;
                if (this.failedToCreate) return;
                if (t1.program.set(this.program), t1.setDepthMode(i), t1.setStencilMode(o), t1.setColorMode(a), t1.setCullFace(r), n) {
                    t1.activeTexture.set(x.TEXTURE2), x.bindTexture(x.TEXTURE_2D, n.depthTexture), t1.activeTexture.set(x.TEXTURE3), x.bindTexture(x.TEXTURE_2D, n.texture);
                    for(const t1 in this.terrainUniforms)this.terrainUniforms[t1].set(n[t1]);
                }
                for(const t1 in this.fixedUniforms)this.fixedUniforms[t1].set(s[t1]);
                _ && _.setUniforms(t1, this.binderUniforms, d, {
                    zoom: m
                });
                let v = 0;
                switch(e1){
                    case x.LINES:
                        v = 2;
                        break;
                    case x.TRIANGLES:
                        v = 3;
                        break;
                    case x.LINE_STRIP:
                        v = 1;
                }
                for (const i of u.get()){
                    const o = i.vaos || (i.vaos = {});
                    (o[l] || (o[l] = new re)).bind(t1, this, c, _ ? _.getPaintVertexBuffers() : [], h, i.vertexOffset, p, f, g), x.drawElements(e1, i.primitiveLength * v, x.UNSIGNED_SHORT, i.primitiveOffset * v * 2);
                }
            }
        }
        function le(t1, e1, i) {
            const o = 1 / bt(i, 1, e1.transform.tileZoom), a = Math.pow(2, i.tileID.overscaledZ), r = i.tileSize * Math.pow(2, e1.transform.tileZoom) / a, s = r * (i.tileID.canonical.x + i.tileID.wrap * a), n = r * i.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: i.imageAtlasTexture.size,
                u_scale: [
                    o,
                    t1.fromScale,
                    t1.toScale
                ],
                u_fade: t1.t,
                u_pixel_coord_upper: [
                    s >> 16,
                    n >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & s,
                    65535 & n
                ]
            };
        }
        const ce = (e1, i, o, a)=>{
            const r = i.style.light, s = r.properties.get("position"), n = [
                s.x,
                s.y,
                s.z
            ], l = t1.create$1();
            "viewport" === r.properties.get("anchor") && t1.fromRotation(l, -i.transform.angle), t1.transformMat3(n, n, l);
            const c = r.properties.get("color");
            return {
                u_matrix: e1,
                u_lightpos: n,
                u_lightintensity: r.properties.get("intensity"),
                u_lightcolor: [
                    c.r,
                    c.g,
                    c.b
                ],
                u_vertical_gradient: +o,
                u_opacity: a
            };
        }, he = (e1, i, o, a, r, s, n)=>t1.extend(ce(e1, i, o, a), le(s, i, n), {
                u_height_factor: -Math.pow(2, r.overscaledZ) / n.tileSize / 8
            }), ue = (t1)=>({
                u_matrix: t1
            }), de = (e1, i, o, a)=>t1.extend(ue(e1), le(o, i, a)), me = (t1, e1)=>({
                u_matrix: t1,
                u_world: e1
            }), _e = (e1, i, o, a, r)=>t1.extend(de(e1, i, o, a), {
                u_world: r
            }), pe = (t1, e1, i, o)=>{
            const a = t1.transform;
            let r, s;
            if ("map" === o.paint.get("circle-pitch-alignment")) {
                const t1 = bt(i, 1, a.zoom);
                r = !0, s = [
                    t1,
                    t1
                ];
            } else r = !1, s = a.pixelsToGLUnits;
            return {
                u_camera_to_center_distance: a.cameraToCenterDistance,
                u_scale_with_map: +("map" === o.paint.get("circle-pitch-scale")),
                u_matrix: t1.translatePosMatrix(e1.posMatrix, i, o.paint.get("circle-translate"), o.paint.get("circle-translate-anchor")),
                u_pitch_with_map: +r,
                u_device_pixel_ratio: t1.pixelRatio,
                u_extrude_scale: s
            };
        }, fe = (t1, e1, i)=>{
            const o = bt(i, 1, e1.zoom), a = Math.pow(2, e1.zoom - i.tileID.overscaledZ), r = i.tileID.overscaleFactor();
            return {
                u_matrix: t1,
                u_camera_to_center_distance: e1.cameraToCenterDistance,
                u_pixels_to_tile_units: o,
                u_extrude_scale: [
                    e1.pixelsToGLUnits[0] / (o * a),
                    e1.pixelsToGLUnits[1] / (o * a)
                ],
                u_overscale_factor: r
            };
        }, ge = (t1, e1, i = 1)=>({
                u_matrix: t1,
                u_color: e1,
                u_overlay: 0,
                u_overlay_scale: i
            }), xe = (t1)=>({
                u_matrix: t1
            }), ve = (t1, e1, i, o)=>({
                u_matrix: t1,
                u_extrude_scale: bt(e1, 1, i),
                u_intensity: o
            });
        function ye(e1, i) {
            const o = Math.pow(2, i.canonical.z), a = i.canonical.y;
            return [
                new t1.MercatorCoordinate(0, a / o).toLngLat().lat,
                new t1.MercatorCoordinate(0, (a + 1) / o).toLngLat().lat
            ];
        }
        const be = (t1, e1, i, o)=>{
            const a = t1.transform;
            return {
                u_matrix: Ce(t1, e1, i, o),
                u_ratio: 1 / bt(e1, 1, a.zoom),
                u_device_pixel_ratio: t1.pixelRatio,
                u_units_to_pixels: [
                    1 / a.pixelsToGLUnits[0],
                    1 / a.pixelsToGLUnits[1]
                ]
            };
        }, we = (e1, i, o, a, r)=>t1.extend(be(e1, i, o, r), {
                u_image: 0,
                u_image_height: a
            }), Te = (t1, e1, i, o, a)=>{
            const r = t1.transform, s = Ie(e1, r);
            return {
                u_matrix: Ce(t1, e1, i, a),
                u_texsize: e1.imageAtlasTexture.size,
                u_ratio: 1 / bt(e1, 1, r.zoom),
                u_device_pixel_ratio: t1.pixelRatio,
                u_image: 0,
                u_scale: [
                    s,
                    o.fromScale,
                    o.toScale
                ],
                u_fade: o.t,
                u_units_to_pixels: [
                    1 / r.pixelsToGLUnits[0],
                    1 / r.pixelsToGLUnits[1]
                ]
            };
        }, Ee = (e1, i, o, a, r, s)=>{
            const n = e1.lineAtlas, l = Ie(i, e1.transform), c = "round" === o.layout.get("line-cap"), h = n.getDash(a.from, c), u = n.getDash(a.to, c), d = h.width * r.fromScale, m = u.width * r.toScale;
            return t1.extend(be(e1, i, o, s), {
                u_patternscale_a: [
                    l / d,
                    -h.height / 2
                ],
                u_patternscale_b: [
                    l / m,
                    -u.height / 2
                ],
                u_sdfgamma: n.width / (256 * Math.min(d, m) * e1.pixelRatio) / 2,
                u_image: 0,
                u_tex_y_a: h.y,
                u_tex_y_b: u.y,
                u_mix: r.t
            });
        };
        function Ie(t1, e1) {
            return 1 / bt(t1, 1, e1.tileZoom);
        }
        function Ce(t1, e1, i, o) {
            return t1.translatePosMatrix(o ? o.posMatrix : e1.tileID.posMatrix, e1, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
        }
        const Se = (t1, e1, i, o, a)=>{
            var r, s;
            return {
                u_matrix: t1,
                u_tl_parent: e1,
                u_scale_parent: i,
                u_buffer_scale: 1,
                u_fade_t: o.mix,
                u_opacity: o.opacity * a.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: a.paint.get("raster-brightness-min"),
                u_brightness_high: a.paint.get("raster-brightness-max"),
                u_saturation_factor: (s = a.paint.get("raster-saturation"), s > 0 ? 1 - 1 / (1.001 - s) : -s),
                u_contrast_factor: (r = a.paint.get("raster-contrast"), r > 0 ? 1 / (1 - r) : 1 + r),
                u_spin_weights: De(a.paint.get("raster-hue-rotate"))
            };
        };
        function De(t1) {
            t1 *= Math.PI / 180;
            const e1 = Math.sin(t1), i = Math.cos(t1);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * e1 - i + 1) / 3,
                (Math.sqrt(3) * e1 - i + 1) / 3
            ];
        }
        const ze = (t1, e1, i, o, a, r, s, n, l, c)=>{
            const h = a.transform;
            return {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: e1 ? e1.uSizeT : 0,
                u_size: e1 ? e1.uSize : 0,
                u_camera_to_center_distance: h.cameraToCenterDistance,
                u_pitch: h.pitch / 360 * 2 * Math.PI,
                u_rotate_symbol: +i,
                u_aspect_ratio: h.width / h.height,
                u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1,
                u_matrix: r,
                u_label_plane_matrix: s,
                u_coord_matrix: n,
                u_is_text: +l,
                u_pitch_with_map: +o,
                u_texsize: c,
                u_texture: 0
            };
        }, Pe = (e1, i, o, a, r, s, n, l, c, h, u)=>{
            const d = r.transform;
            return t1.extend(ze(e1, i, o, a, r, s, n, l, c, h), {
                u_gamma_scale: a ? Math.cos(d._pitch) * d.cameraToCenterDistance : 1,
                u_device_pixel_ratio: r.pixelRatio,
                u_is_halo: +u
            });
        }, Me = (e1, i, o, a, r, s, n, l, c, h)=>t1.extend(Pe(e1, i, o, a, r, s, n, l, !0, c, !0), {
                u_texsize_icon: h,
                u_texture_icon: 1
            }), Ae = (t1, e1, i)=>({
                u_matrix: t1,
                u_opacity: e1,
                u_color: i
            }), Le = (e1, i, o, a, r, s)=>t1.extend(function(t1, e1, i, o) {
                const a = i.imageManager.getPattern(t1.from.toString()), r = i.imageManager.getPattern(t1.to.toString()), { width: s, height: n } = i.imageManager.getPixelSize(), l = Math.pow(2, o.tileID.overscaledZ), c = o.tileSize * Math.pow(2, i.transform.tileZoom) / l, h = c * (o.tileID.canonical.x + o.tileID.wrap * l), u = c * o.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl_a: a.tl,
                    u_pattern_br_a: a.br,
                    u_pattern_tl_b: r.tl,
                    u_pattern_br_b: r.br,
                    u_texsize: [
                        s,
                        n
                    ],
                    u_mix: e1.t,
                    u_pattern_size_a: a.displaySize,
                    u_pattern_size_b: r.displaySize,
                    u_scale_a: e1.fromScale,
                    u_scale_b: e1.toScale,
                    u_tile_units_to_pixels: 1 / bt(o, 1, i.transform.tileZoom),
                    u_pixel_coord_upper: [
                        h >> 16,
                        u >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & h,
                        65535 & u
                    ]
                };
            }(a, s, o, r), {
                u_matrix: e1,
                u_opacity: i
            }), Re = {
            fillExtrusion: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_lightpos: new t1.Uniform3f(e1, i.u_lightpos),
                    u_lightintensity: new t1.Uniform1f(e1, i.u_lightintensity),
                    u_lightcolor: new t1.Uniform3f(e1, i.u_lightcolor),
                    u_vertical_gradient: new t1.Uniform1f(e1, i.u_vertical_gradient),
                    u_opacity: new t1.Uniform1f(e1, i.u_opacity)
                }),
            fillExtrusionPattern: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_lightpos: new t1.Uniform3f(e1, i.u_lightpos),
                    u_lightintensity: new t1.Uniform1f(e1, i.u_lightintensity),
                    u_lightcolor: new t1.Uniform3f(e1, i.u_lightcolor),
                    u_vertical_gradient: new t1.Uniform1f(e1, i.u_vertical_gradient),
                    u_height_factor: new t1.Uniform1f(e1, i.u_height_factor),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_pixel_coord_upper: new t1.Uniform2f(e1, i.u_pixel_coord_upper),
                    u_pixel_coord_lower: new t1.Uniform2f(e1, i.u_pixel_coord_lower),
                    u_scale: new t1.Uniform3f(e1, i.u_scale),
                    u_fade: new t1.Uniform1f(e1, i.u_fade),
                    u_opacity: new t1.Uniform1f(e1, i.u_opacity)
                }),
            fill: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix)
                }),
            fillPattern: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_pixel_coord_upper: new t1.Uniform2f(e1, i.u_pixel_coord_upper),
                    u_pixel_coord_lower: new t1.Uniform2f(e1, i.u_pixel_coord_lower),
                    u_scale: new t1.Uniform3f(e1, i.u_scale),
                    u_fade: new t1.Uniform1f(e1, i.u_fade)
                }),
            fillOutline: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_world: new t1.Uniform2f(e1, i.u_world)
                }),
            fillOutlinePattern: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_world: new t1.Uniform2f(e1, i.u_world),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_pixel_coord_upper: new t1.Uniform2f(e1, i.u_pixel_coord_upper),
                    u_pixel_coord_lower: new t1.Uniform2f(e1, i.u_pixel_coord_lower),
                    u_scale: new t1.Uniform3f(e1, i.u_scale),
                    u_fade: new t1.Uniform1f(e1, i.u_fade)
                }),
            circle: (e1, i)=>({
                    u_camera_to_center_distance: new t1.Uniform1f(e1, i.u_camera_to_center_distance),
                    u_scale_with_map: new t1.Uniform1i(e1, i.u_scale_with_map),
                    u_pitch_with_map: new t1.Uniform1i(e1, i.u_pitch_with_map),
                    u_extrude_scale: new t1.Uniform2f(e1, i.u_extrude_scale),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix)
                }),
            collisionBox: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_camera_to_center_distance: new t1.Uniform1f(e1, i.u_camera_to_center_distance),
                    u_pixels_to_tile_units: new t1.Uniform1f(e1, i.u_pixels_to_tile_units),
                    u_extrude_scale: new t1.Uniform2f(e1, i.u_extrude_scale),
                    u_overscale_factor: new t1.Uniform1f(e1, i.u_overscale_factor)
                }),
            collisionCircle: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_inv_matrix: new t1.UniformMatrix4f(e1, i.u_inv_matrix),
                    u_camera_to_center_distance: new t1.Uniform1f(e1, i.u_camera_to_center_distance),
                    u_viewport_size: new t1.Uniform2f(e1, i.u_viewport_size)
                }),
            debug: (e1, i)=>({
                    u_color: new t1.UniformColor(e1, i.u_color),
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_overlay: new t1.Uniform1i(e1, i.u_overlay),
                    u_overlay_scale: new t1.Uniform1f(e1, i.u_overlay_scale)
                }),
            clippingMask: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix)
                }),
            heatmap: (e1, i)=>({
                    u_extrude_scale: new t1.Uniform1f(e1, i.u_extrude_scale),
                    u_intensity: new t1.Uniform1f(e1, i.u_intensity),
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix)
                }),
            heatmapTexture: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_world: new t1.Uniform2f(e1, i.u_world),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_color_ramp: new t1.Uniform1i(e1, i.u_color_ramp),
                    u_opacity: new t1.Uniform1f(e1, i.u_opacity)
                }),
            hillshade: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_latrange: new t1.Uniform2f(e1, i.u_latrange),
                    u_light: new t1.Uniform2f(e1, i.u_light),
                    u_shadow: new t1.UniformColor(e1, i.u_shadow),
                    u_highlight: new t1.UniformColor(e1, i.u_highlight),
                    u_accent: new t1.UniformColor(e1, i.u_accent)
                }),
            hillshadePrepare: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_dimension: new t1.Uniform2f(e1, i.u_dimension),
                    u_zoom: new t1.Uniform1f(e1, i.u_zoom),
                    u_unpack: new t1.Uniform4f(e1, i.u_unpack)
                }),
            line: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_ratio: new t1.Uniform1f(e1, i.u_ratio),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_units_to_pixels: new t1.Uniform2f(e1, i.u_units_to_pixels)
                }),
            lineGradient: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_ratio: new t1.Uniform1f(e1, i.u_ratio),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_units_to_pixels: new t1.Uniform2f(e1, i.u_units_to_pixels),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_image_height: new t1.Uniform1f(e1, i.u_image_height)
                }),
            linePattern: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_ratio: new t1.Uniform1f(e1, i.u_ratio),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_units_to_pixels: new t1.Uniform2f(e1, i.u_units_to_pixels),
                    u_scale: new t1.Uniform3f(e1, i.u_scale),
                    u_fade: new t1.Uniform1f(e1, i.u_fade)
                }),
            lineSDF: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_ratio: new t1.Uniform1f(e1, i.u_ratio),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_units_to_pixels: new t1.Uniform2f(e1, i.u_units_to_pixels),
                    u_patternscale_a: new t1.Uniform2f(e1, i.u_patternscale_a),
                    u_patternscale_b: new t1.Uniform2f(e1, i.u_patternscale_b),
                    u_sdfgamma: new t1.Uniform1f(e1, i.u_sdfgamma),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_tex_y_a: new t1.Uniform1f(e1, i.u_tex_y_a),
                    u_tex_y_b: new t1.Uniform1f(e1, i.u_tex_y_b),
                    u_mix: new t1.Uniform1f(e1, i.u_mix)
                }),
            raster: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_tl_parent: new t1.Uniform2f(e1, i.u_tl_parent),
                    u_scale_parent: new t1.Uniform1f(e1, i.u_scale_parent),
                    u_buffer_scale: new t1.Uniform1f(e1, i.u_buffer_scale),
                    u_fade_t: new t1.Uniform1f(e1, i.u_fade_t),
                    u_opacity: new t1.Uniform1f(e1, i.u_opacity),
                    u_image0: new t1.Uniform1i(e1, i.u_image0),
                    u_image1: new t1.Uniform1i(e1, i.u_image1),
                    u_brightness_low: new t1.Uniform1f(e1, i.u_brightness_low),
                    u_brightness_high: new t1.Uniform1f(e1, i.u_brightness_high),
                    u_saturation_factor: new t1.Uniform1f(e1, i.u_saturation_factor),
                    u_contrast_factor: new t1.Uniform1f(e1, i.u_contrast_factor),
                    u_spin_weights: new t1.Uniform3f(e1, i.u_spin_weights)
                }),
            symbolIcon: (e1, i)=>({
                    u_is_size_zoom_constant: new t1.Uniform1i(e1, i.u_is_size_zoom_constant),
                    u_is_size_feature_constant: new t1.Uniform1i(e1, i.u_is_size_feature_constant),
                    u_size_t: new t1.Uniform1f(e1, i.u_size_t),
                    u_size: new t1.Uniform1f(e1, i.u_size),
                    u_camera_to_center_distance: new t1.Uniform1f(e1, i.u_camera_to_center_distance),
                    u_pitch: new t1.Uniform1f(e1, i.u_pitch),
                    u_rotate_symbol: new t1.Uniform1i(e1, i.u_rotate_symbol),
                    u_aspect_ratio: new t1.Uniform1f(e1, i.u_aspect_ratio),
                    u_fade_change: new t1.Uniform1f(e1, i.u_fade_change),
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_label_plane_matrix: new t1.UniformMatrix4f(e1, i.u_label_plane_matrix),
                    u_coord_matrix: new t1.UniformMatrix4f(e1, i.u_coord_matrix),
                    u_is_text: new t1.Uniform1i(e1, i.u_is_text),
                    u_pitch_with_map: new t1.Uniform1i(e1, i.u_pitch_with_map),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_texture: new t1.Uniform1i(e1, i.u_texture)
                }),
            symbolSDF: (e1, i)=>({
                    u_is_size_zoom_constant: new t1.Uniform1i(e1, i.u_is_size_zoom_constant),
                    u_is_size_feature_constant: new t1.Uniform1i(e1, i.u_is_size_feature_constant),
                    u_size_t: new t1.Uniform1f(e1, i.u_size_t),
                    u_size: new t1.Uniform1f(e1, i.u_size),
                    u_camera_to_center_distance: new t1.Uniform1f(e1, i.u_camera_to_center_distance),
                    u_pitch: new t1.Uniform1f(e1, i.u_pitch),
                    u_rotate_symbol: new t1.Uniform1i(e1, i.u_rotate_symbol),
                    u_aspect_ratio: new t1.Uniform1f(e1, i.u_aspect_ratio),
                    u_fade_change: new t1.Uniform1f(e1, i.u_fade_change),
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_label_plane_matrix: new t1.UniformMatrix4f(e1, i.u_label_plane_matrix),
                    u_coord_matrix: new t1.UniformMatrix4f(e1, i.u_coord_matrix),
                    u_is_text: new t1.Uniform1i(e1, i.u_is_text),
                    u_pitch_with_map: new t1.Uniform1i(e1, i.u_pitch_with_map),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_texture: new t1.Uniform1i(e1, i.u_texture),
                    u_gamma_scale: new t1.Uniform1f(e1, i.u_gamma_scale),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_is_halo: new t1.Uniform1i(e1, i.u_is_halo)
                }),
            symbolTextAndIcon: (e1, i)=>({
                    u_is_size_zoom_constant: new t1.Uniform1i(e1, i.u_is_size_zoom_constant),
                    u_is_size_feature_constant: new t1.Uniform1i(e1, i.u_is_size_feature_constant),
                    u_size_t: new t1.Uniform1f(e1, i.u_size_t),
                    u_size: new t1.Uniform1f(e1, i.u_size),
                    u_camera_to_center_distance: new t1.Uniform1f(e1, i.u_camera_to_center_distance),
                    u_pitch: new t1.Uniform1f(e1, i.u_pitch),
                    u_rotate_symbol: new t1.Uniform1i(e1, i.u_rotate_symbol),
                    u_aspect_ratio: new t1.Uniform1f(e1, i.u_aspect_ratio),
                    u_fade_change: new t1.Uniform1f(e1, i.u_fade_change),
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_label_plane_matrix: new t1.UniformMatrix4f(e1, i.u_label_plane_matrix),
                    u_coord_matrix: new t1.UniformMatrix4f(e1, i.u_coord_matrix),
                    u_is_text: new t1.Uniform1i(e1, i.u_is_text),
                    u_pitch_with_map: new t1.Uniform1i(e1, i.u_pitch_with_map),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_texsize_icon: new t1.Uniform2f(e1, i.u_texsize_icon),
                    u_texture: new t1.Uniform1i(e1, i.u_texture),
                    u_texture_icon: new t1.Uniform1i(e1, i.u_texture_icon),
                    u_gamma_scale: new t1.Uniform1f(e1, i.u_gamma_scale),
                    u_device_pixel_ratio: new t1.Uniform1f(e1, i.u_device_pixel_ratio),
                    u_is_halo: new t1.Uniform1i(e1, i.u_is_halo)
                }),
            background: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_opacity: new t1.Uniform1f(e1, i.u_opacity),
                    u_color: new t1.UniformColor(e1, i.u_color)
                }),
            backgroundPattern: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_opacity: new t1.Uniform1f(e1, i.u_opacity),
                    u_image: new t1.Uniform1i(e1, i.u_image),
                    u_pattern_tl_a: new t1.Uniform2f(e1, i.u_pattern_tl_a),
                    u_pattern_br_a: new t1.Uniform2f(e1, i.u_pattern_br_a),
                    u_pattern_tl_b: new t1.Uniform2f(e1, i.u_pattern_tl_b),
                    u_pattern_br_b: new t1.Uniform2f(e1, i.u_pattern_br_b),
                    u_texsize: new t1.Uniform2f(e1, i.u_texsize),
                    u_mix: new t1.Uniform1f(e1, i.u_mix),
                    u_pattern_size_a: new t1.Uniform2f(e1, i.u_pattern_size_a),
                    u_pattern_size_b: new t1.Uniform2f(e1, i.u_pattern_size_b),
                    u_scale_a: new t1.Uniform1f(e1, i.u_scale_a),
                    u_scale_b: new t1.Uniform1f(e1, i.u_scale_b),
                    u_pixel_coord_upper: new t1.Uniform2f(e1, i.u_pixel_coord_upper),
                    u_pixel_coord_lower: new t1.Uniform2f(e1, i.u_pixel_coord_lower),
                    u_tile_units_to_pixels: new t1.Uniform1f(e1, i.u_tile_units_to_pixels)
                }),
            terrain: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_texture: new t1.Uniform1i(e1, i.u_texture)
                }),
            terrainDepth: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix)
                }),
            terrainCoords: (e1, i)=>({
                    u_matrix: new t1.UniformMatrix4f(e1, i.u_matrix),
                    u_texture: new t1.Uniform1i(e1, i.u_texture),
                    u_terrain_coords_id: new t1.Uniform1f(e1, i.u_terrain_coords_id)
                })
        };
        class ke {
            constructor(t1, e1, i){
                this.context = t1;
                const o = t1.gl;
                this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), t1.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, e1.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete e1.arrayBuffer;
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t1) {
                const e1 = this.context.gl;
                if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
                this.context.unbindVAO(), this.bind(), e1.bufferSubData(e1.ELEMENT_ARRAY_BUFFER, 0, t1.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        const Be = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class Fe {
            constructor(t1, e1, i, o){
                this.length = e1.length, this.attributes = i, this.itemSize = e1.bytesPerElement, this.dynamicDraw = o, this.context = t1;
                const a = t1.gl;
                this.buffer = a.createBuffer(), t1.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, e1.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || delete e1.arrayBuffer;
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t1) {
                if (t1.length !== this.length) throw new Error(`Length of new data is ${t1.length}, which doesn't match current length of ${this.length}`);
                const e1 = this.context.gl;
                this.bind(), e1.bufferSubData(e1.ARRAY_BUFFER, 0, t1.arrayBuffer);
            }
            enableAttributes(t1, e1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = e1.attributes[this.attributes[i].name];
                    void 0 !== o && t1.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(t1, e1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const a = this.attributes[o], r = e1.attributes[a.name];
                    void 0 !== r && t1.vertexAttribPointer(r, a.components, t1[Be[a.type]], !1, this.itemSize, a.offset + this.itemSize * (i || 0));
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class Oe {
            constructor(t1){
                this.gl = t1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(t1) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class Ue extends Oe {
            getDefault() {
                return t1.Color.transparent;
            }
            set(t1) {
                const e1 = this.current;
                (t1.r !== e1.r || t1.g !== e1.g || t1.b !== e1.b || t1.a !== e1.a || this.dirty) && (this.gl.clearColor(t1.r, t1.g, t1.b, t1.a), this.current = t1, this.dirty = !1);
            }
        }
        class Ne extends Oe {
            getDefault() {
                return 1;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.clearDepth(t1), this.current = t1, this.dirty = !1);
            }
        }
        class Ge extends Oe {
            getDefault() {
                return 0;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.clearStencil(t1), this.current = t1, this.dirty = !1);
            }
        }
        class Ze extends Oe {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(t1) {
                const e1 = this.current;
                (t1[0] !== e1[0] || t1[1] !== e1[1] || t1[2] !== e1[2] || t1[3] !== e1[3] || this.dirty) && (this.gl.colorMask(t1[0], t1[1], t1[2], t1[3]), this.current = t1, this.dirty = !1);
            }
        }
        class Ve extends Oe {
            getDefault() {
                return !0;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.depthMask(t1), this.current = t1, this.dirty = !1);
            }
        }
        class qe extends Oe {
            getDefault() {
                return 255;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.stencilMask(t1), this.current = t1, this.dirty = !1);
            }
        }
        class je extends Oe {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(t1) {
                const e1 = this.current;
                (t1.func !== e1.func || t1.ref !== e1.ref || t1.mask !== e1.mask || this.dirty) && (this.gl.stencilFunc(t1.func, t1.ref, t1.mask), this.current = t1, this.dirty = !1);
            }
        }
        class $e extends Oe {
            getDefault() {
                const t1 = this.gl;
                return [
                    t1.KEEP,
                    t1.KEEP,
                    t1.KEEP
                ];
            }
            set(t1) {
                const e1 = this.current;
                (t1[0] !== e1[0] || t1[1] !== e1[1] || t1[2] !== e1[2] || this.dirty) && (this.gl.stencilOp(t1[0], t1[1], t1[2]), this.current = t1, this.dirty = !1);
            }
        }
        class Xe extends Oe {
            getDefault() {
                return !1;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                t1 ? e1.enable(e1.STENCIL_TEST) : e1.disable(e1.STENCIL_TEST), this.current = t1, this.dirty = !1;
            }
        }
        class We extends Oe {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(t1) {
                const e1 = this.current;
                (t1[0] !== e1[0] || t1[1] !== e1[1] || this.dirty) && (this.gl.depthRange(t1[0], t1[1]), this.current = t1, this.dirty = !1);
            }
        }
        class He extends Oe {
            getDefault() {
                return !1;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                t1 ? e1.enable(e1.DEPTH_TEST) : e1.disable(e1.DEPTH_TEST), this.current = t1, this.dirty = !1;
            }
        }
        class Ke extends Oe {
            getDefault() {
                return this.gl.LESS;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.depthFunc(t1), this.current = t1, this.dirty = !1);
            }
        }
        class Ye extends Oe {
            getDefault() {
                return !1;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                t1 ? e1.enable(e1.BLEND) : e1.disable(e1.BLEND), this.current = t1, this.dirty = !1;
            }
        }
        class Je extends Oe {
            getDefault() {
                const t1 = this.gl;
                return [
                    t1.ONE,
                    t1.ZERO
                ];
            }
            set(t1) {
                const e1 = this.current;
                (t1[0] !== e1[0] || t1[1] !== e1[1] || this.dirty) && (this.gl.blendFunc(t1[0], t1[1]), this.current = t1, this.dirty = !1);
            }
        }
        class Qe extends Oe {
            getDefault() {
                return t1.Color.transparent;
            }
            set(t1) {
                const e1 = this.current;
                (t1.r !== e1.r || t1.g !== e1.g || t1.b !== e1.b || t1.a !== e1.a || this.dirty) && (this.gl.blendColor(t1.r, t1.g, t1.b, t1.a), this.current = t1, this.dirty = !1);
            }
        }
        class ti extends Oe {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.blendEquation(t1), this.current = t1, this.dirty = !1);
            }
        }
        class ei extends Oe {
            getDefault() {
                return !1;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                t1 ? e1.enable(e1.CULL_FACE) : e1.disable(e1.CULL_FACE), this.current = t1, this.dirty = !1;
            }
        }
        class ii extends Oe {
            getDefault() {
                return this.gl.BACK;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.cullFace(t1), this.current = t1, this.dirty = !1);
            }
        }
        class oi extends Oe {
            getDefault() {
                return this.gl.CCW;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.frontFace(t1), this.current = t1, this.dirty = !1);
            }
        }
        class ai extends Oe {
            getDefault() {
                return null;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.useProgram(t1), this.current = t1, this.dirty = !1);
            }
        }
        class ri extends Oe {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(t1) {
                (t1 !== this.current || this.dirty) && (this.gl.activeTexture(t1), this.current = t1, this.dirty = !1);
            }
        }
        class si extends Oe {
            getDefault() {
                const t1 = this.gl;
                return [
                    0,
                    0,
                    t1.drawingBufferWidth,
                    t1.drawingBufferHeight
                ];
            }
            set(t1) {
                const e1 = this.current;
                (t1[0] !== e1[0] || t1[1] !== e1[1] || t1[2] !== e1[2] || t1[3] !== e1[3] || this.dirty) && (this.gl.viewport(t1[0], t1[1], t1[2], t1[3]), this.current = t1, this.dirty = !1);
            }
        }
        class ni extends Oe {
            getDefault() {
                return null;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.bindFramebuffer(e1.FRAMEBUFFER, t1), this.current = t1, this.dirty = !1;
            }
        }
        class li extends Oe {
            getDefault() {
                return null;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.bindRenderbuffer(e1.RENDERBUFFER, t1), this.current = t1, this.dirty = !1;
            }
        }
        class ci extends Oe {
            getDefault() {
                return null;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.bindTexture(e1.TEXTURE_2D, t1), this.current = t1, this.dirty = !1;
            }
        }
        class hi extends Oe {
            getDefault() {
                return null;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.bindBuffer(e1.ARRAY_BUFFER, t1), this.current = t1, this.dirty = !1;
            }
        }
        class ui extends Oe {
            getDefault() {
                return null;
            }
            set(t1) {
                const e1 = this.gl;
                e1.bindBuffer(e1.ELEMENT_ARRAY_BUFFER, t1), this.current = t1, this.dirty = !1;
            }
        }
        class di extends Oe {
            constructor(t1){
                super(t1), this.vao = t1.extVertexArrayObject;
            }
            getDefault() {
                return null;
            }
            set(t1) {
                this.vao && (t1 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t1), this.current = t1, this.dirty = !1);
            }
        }
        class mi extends Oe {
            getDefault() {
                return 4;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.pixelStorei(e1.UNPACK_ALIGNMENT, t1), this.current = t1, this.dirty = !1;
            }
        }
        class _i extends Oe {
            getDefault() {
                return !1;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.pixelStorei(e1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t1), this.current = t1, this.dirty = !1;
            }
        }
        class pi extends Oe {
            getDefault() {
                return !1;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                const e1 = this.gl;
                e1.pixelStorei(e1.UNPACK_FLIP_Y_WEBGL, t1), this.current = t1, this.dirty = !1;
            }
        }
        class fi extends Oe {
            constructor(t1, e1){
                super(t1), this.context = t1, this.parent = e1;
            }
            getDefault() {
                return null;
            }
        }
        class gi extends fi {
            setDirty() {
                this.dirty = !0;
            }
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const e1 = this.gl;
                e1.framebufferTexture2D(e1.FRAMEBUFFER, e1.COLOR_ATTACHMENT0, e1.TEXTURE_2D, t1, 0), this.current = t1, this.dirty = !1;
            }
        }
        class xi extends fi {
            set(t1) {
                if (t1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const e1 = this.gl;
                e1.framebufferRenderbuffer(e1.FRAMEBUFFER, e1.DEPTH_ATTACHMENT, e1.RENDERBUFFER, t1), this.current = t1, this.dirty = !1;
            }
        }
        class vi {
            constructor(t1, e1, i, o){
                this.context = t1, this.width = e1, this.height = i;
                const a = t1.gl, r = this.framebuffer = a.createFramebuffer();
                if (this.colorAttachment = new gi(t1, r), o && (this.depthAttachment = new xi(t1, r)), a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
            }
            destroy() {
                const t1 = this.context.gl, e1 = this.colorAttachment.get();
                if (e1 && t1.deleteTexture(e1), this.depthAttachment) {
                    const e1 = this.depthAttachment.get();
                    e1 && t1.deleteRenderbuffer(e1);
                }
                t1.deleteFramebuffer(this.framebuffer);
            }
        }
        class yi {
            constructor(t1, e1, i){
                this.blendFunction = t1, this.blendColor = e1, this.mask = i;
            }
        }
        yi.Replace = [
            1,
            0
        ], yi.disabled = new yi(yi.Replace, t1.Color.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), yi.unblended = new yi(yi.Replace, t1.Color.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), yi.alphaBlended = new yi([
            1,
            771
        ], t1.Color.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        class bi {
            constructor(t1){
                this.gl = t1, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new Ue(this), this.clearDepth = new Ne(this), this.clearStencil = new Ge(this), this.colorMask = new Ze(this), this.depthMask = new Ve(this), this.stencilMask = new qe(this), this.stencilFunc = new je(this), this.stencilOp = new $e(this), this.stencilTest = new Xe(this), this.depthRange = new We(this), this.depthTest = new He(this), this.depthFunc = new Ke(this), this.blend = new Ye(this), this.blendFunc = new Je(this), this.blendColor = new Qe(this), this.blendEquation = new ti(this), this.cullFace = new ei(this), this.cullFaceSide = new ii(this), this.frontFace = new oi(this), this.program = new ai(this), this.activeTexture = new ri(this), this.viewport = new si(this), this.bindFramebuffer = new ni(this), this.bindRenderbuffer = new li(this), this.bindTexture = new ci(this), this.bindVertexBuffer = new hi(this), this.bindElementBuffer = new ui(this), this.bindVertexArrayOES = this.extVertexArrayObject && new di(this), this.pixelStoreUnpack = new mi(this), this.pixelStoreUnpackPremultiplyAlpha = new _i(this), this.pixelStoreUnpackFlipY = new pi(this), this.extTextureFilterAnisotropic = t1.getExtension("EXT_texture_filter_anisotropic") || t1.getExtension("MOZ_EXT_texture_filter_anisotropic") || t1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t1.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t1.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t1.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t1.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t1.getParameter(t1.MAX_TEXTURE_SIZE);
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(t1, e1) {
                return new ke(this, t1, e1);
            }
            createVertexBuffer(t1, e1, i) {
                return new Fe(this, t1, e1, i);
            }
            createRenderbuffer(t1, e1, i) {
                const o = this.gl, a = o.createRenderbuffer();
                return this.bindRenderbuffer.set(a), o.renderbufferStorage(o.RENDERBUFFER, t1, e1, i), this.bindRenderbuffer.set(null), a;
            }
            createFramebuffer(t1, e1, i) {
                return new vi(this, t1, e1, i);
            }
            clear({ color: t1, depth: e1 }) {
                const i = this.gl;
                let o = 0;
                t1 && (o |= i.COLOR_BUFFER_BIT, this.clearColor.set(t1), this.colorMask.set([
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== e1 && (o |= i.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(e1), this.depthMask.set(!0)), i.clear(o);
            }
            setCullFace(t1) {
                !1 === t1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t1.mode), this.frontFace.set(t1.frontFace));
            }
            setDepthMode(t1) {
                t1.func !== this.gl.ALWAYS || t1.mask ? (this.depthTest.set(!0), this.depthFunc.set(t1.func), this.depthMask.set(t1.mask), this.depthRange.set(t1.range)) : this.depthTest.set(!1);
            }
            setStencilMode(t1) {
                t1.test.func !== this.gl.ALWAYS || t1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t1.mask), this.stencilOp.set([
                    t1.fail,
                    t1.depthFail,
                    t1.pass
                ]), this.stencilFunc.set({
                    func: t1.test.func,
                    ref: t1.ref,
                    mask: t1.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(t1) {
                a(t1.blendFunction, yi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t1.blendFunction), this.blendColor.set(t1.blendColor)), this.colorMask.set(t1.mask);
            }
            unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
        }
        class wi {
            constructor(t1, e1, i){
                this.func = t1, this.mask = e1, this.range = i;
            }
        }
        wi.ReadOnly = !1, wi.ReadWrite = !0, wi.disabled = new wi(519, wi.ReadOnly, [
            0,
            1
        ]);
        const Ti = 7680;
        class Ei {
            constructor(t1, e1, i, o, a, r){
                this.test = t1, this.ref = e1, this.mask = i, this.fail = o, this.depthFail = a, this.pass = r;
            }
        }
        Ei.disabled = new Ei({
            func: 519,
            mask: 0
        }, 0, 0, Ti, Ti, Ti);
        class Ii {
            constructor(t1, e1, i){
                this.enable = t1, this.mode = e1, this.frontFace = i;
            }
        }
        let Ci;
        function Si(e1, i, o, a, r, s, n) {
            const l = e1.context, c = l.gl, h = e1.useProgram("collisionBox"), u = [];
            let d = 0, m = 0;
            for(let _ = 0; _ < a.length; _++){
                const p = a[_], f = i.getTile(p), g = f.getBucket(o);
                if (!g) continue;
                let x = p.posMatrix;
                0 === r[0] && 0 === r[1] || (x = e1.translatePosMatrix(p.posMatrix, f, r, s));
                const v = n ? g.textCollisionBox : g.iconCollisionBox, y = g.collisionCircleArray;
                if (y.length > 0) {
                    const i = t1.create(), o = x;
                    t1.mul(i, g.placementInvProjMatrix, e1.transform.glCoordMatrix), t1.mul(i, i, g.placementViewportMatrix), u.push({
                        circleArray: y,
                        circleOffset: m,
                        transform: o,
                        invTransform: i,
                        coord: p
                    }), d += y.length / 4, m = d;
                }
                v && h.draw(l, c.LINES, wi.disabled, Ei.disabled, e1.colorModeForRenderPass(), Ii.disabled, fe(x, e1.transform, f), e1.style.terrain && e1.style.terrain.getTerrainData(p), o.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, null, e1.transform.zoom, null, null, v.collisionVertexBuffer);
            }
            if (!n || !u.length) return;
            const _ = e1.useProgram("collisionCircle"), p = new t1.CollisionCircleLayoutArray;
            p.resize(4 * d), p._trim();
            let f = 0;
            for (const t1 of u)for(let e1 = 0; e1 < t1.circleArray.length / 4; e1++){
                const i = 4 * e1, o = t1.circleArray[i + 0], a = t1.circleArray[i + 1], r = t1.circleArray[i + 2], s = t1.circleArray[i + 3];
                p.emplace(f++, o, a, r, s, 0), p.emplace(f++, o, a, r, s, 1), p.emplace(f++, o, a, r, s, 2), p.emplace(f++, o, a, r, s, 3);
            }
            (!Ci || Ci.length < 2 * d) && (Ci = function(e1) {
                const i = 2 * e1, o = new t1.QuadTriangleArray;
                o.resize(i), o._trim();
                for(let t1 = 0; t1 < i; t1++){
                    const e1 = 6 * t1;
                    o.uint16[e1 + 0] = 4 * t1 + 0, o.uint16[e1 + 1] = 4 * t1 + 1, o.uint16[e1 + 2] = 4 * t1 + 2, o.uint16[e1 + 3] = 4 * t1 + 2, o.uint16[e1 + 4] = 4 * t1 + 3, o.uint16[e1 + 5] = 4 * t1 + 0;
                }
                return o;
            }(d));
            const g = l.createIndexBuffer(Ci, !0), x = l.createVertexBuffer(p, t1.collisionCircleLayout.members, !0);
            for (const i of u){
                const a = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (v = e1.transform).cameraToCenterDistance,
                    u_viewport_size: [
                        v.width,
                        v.height
                    ]
                };
                _.draw(l, c.TRIANGLES, wi.disabled, Ei.disabled, e1.colorModeForRenderPass(), Ii.disabled, a, e1.style.terrain && e1.style.terrain.getTerrainData(i.coord), o.id, x, g, t1.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, e1.transform.zoom, null, null, null);
            }
            var v;
            x.destroy(), g.destroy();
        }
        Ii.disabled = new Ii(!1, 1029, 2305), Ii.backCCW = new Ii(!0, 1029, 2305);
        const Di = t1.identity(new Float32Array(16));
        function zi(e1, i, o, a, r, s) {
            const { horizontalAlign: n, verticalAlign: l } = t1.getAnchorAlignment(e1), c = -(n - .5) * i, h = -(l - .5) * o, u = t1.evaluateVariableOffset(e1, a);
            return new t1.pointGeometry((c / r + u[0]) * s, (h / r + u[1]) * s);
        }
        function Pi(e1, i, o, a, r, s, n, l, c, h, u) {
            const d = e1.text.placedSymbolArray, m = e1.text.dynamicLayoutVertexArray, _ = e1.icon.dynamicLayoutVertexArray, p = {};
            m.clear();
            for(let _ = 0; _ < d.length; _++){
                const f = d.get(_), g = e1.allowVerticalPlacement && !f.placedOrientation, x = f.hidden || !f.crossTileID || g ? null : a[f.crossTileID];
                if (x) {
                    const a = new t1.pointGeometry(f.anchorX, f.anchorY), d = nt(a, o ? n : s, u), _ = lt(r.cameraToCenterDistance, d.signedDistanceFromCamera);
                    let g = t1.evaluateSizeForFeature(e1.textSizeData, c, f) * _ / t1.ONE_EM;
                    o && (g *= e1.tilePixelRatio / l);
                    const { width: v, height: y, anchor: b, textOffset: w, textBoxScale: T } = x, E = zi(b, v, y, w, T, g), I = o ? nt(a.add(E), s, u).point : d.point.add(i ? E.rotate(-r.angle) : E), C = e1.allowVerticalPlacement && f.placedOrientation === t1.WritingMode.vertical ? Math.PI / 2 : 0;
                    for(let e1 = 0; e1 < f.numGlyphs; e1++)t1.addDynamicAttributes(m, I, C);
                    h && f.associatedIconIndex >= 0 && (p[f.associatedIconIndex] = {
                        shiftedAnchor: I,
                        angle: C
                    });
                } else gt(f.numGlyphs, m);
            }
            if (h) {
                _.clear();
                const i = e1.icon.placedSymbolArray;
                for(let e1 = 0; e1 < i.length; e1++){
                    const o = i.get(e1);
                    if (o.hidden) gt(o.numGlyphs, _);
                    else {
                        const i = p[e1];
                        if (i) for(let e1 = 0; e1 < o.numGlyphs; e1++)t1.addDynamicAttributes(_, i.shiftedAnchor, i.angle);
                        else gt(o.numGlyphs, _);
                    }
                }
                e1.icon.dynamicLayoutVertexBuffer.updateData(_);
            }
            e1.text.dynamicLayoutVertexBuffer.updateData(m);
        }
        function Mi(t1, e1, i) {
            return i.iconsInText && e1 ? "symbolTextAndIcon" : t1 ? "symbolSDF" : "symbolIcon";
        }
        function Ai(e1, i, o, a, r, s, n, l, c, h, u, d) {
            const m = e1.context, _ = m.gl, p = e1.transform, f = "map" === l, g = "map" === c, x = "viewport" !== l && "point" !== o.layout.get("symbol-placement"), v = f && !g && !x, y = !o.layout.get("symbol-sort-key").isConstant();
            let b = !1;
            const w = e1.depthModeForSublayer(0, wi.ReadOnly), T = o.layout.get("text-variable-anchor"), E = [];
            for (const l of a){
                const a = i.getTile(l), c = a.getBucket(o);
                if (!c) continue;
                const u = r ? c.text : c.icon;
                if (!u || !u.segments.get().length) continue;
                const d = u.programConfigurations.get(o.id), m = r || c.sdfIcons, w = r ? c.textSizeData : c.iconSizeData, I = g || 0 !== p.pitch, C = e1.useProgram(Mi(m, r, c), d), S = t1.evaluateSizeForZoom(w, p.zoom), D = e1.style.terrain && e1.style.terrain.getTerrainData(l);
                let z, P, M, A, L = [
                    0,
                    0
                ], R = null;
                if (r) {
                    if (P = a.glyphAtlasTexture, M = _.LINEAR, z = a.glyphAtlasTexture.size, c.iconsInText) {
                        L = a.imageAtlasTexture.size, R = a.imageAtlasTexture;
                        const t1 = "composite" === w.kind || "camera" === w.kind;
                        A = I || e1.options.rotating || e1.options.zooming || t1 ? _.LINEAR : _.NEAREST;
                    }
                } else {
                    const t1 = 1 !== o.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                    P = a.imageAtlasTexture, M = m || e1.options.rotating || e1.options.zooming || t1 || I ? _.LINEAR : _.NEAREST, z = a.imageAtlasTexture.size;
                }
                const k = bt(a, 1, e1.transform.zoom), B = rt(l.posMatrix, g, f, e1.transform, k), F = st(l.posMatrix, g, f, e1.transform, k), O = T && c.hasTextData(), U = "none" !== o.layout.get("icon-text-fit") && O && c.hasIconData();
                if (x) {
                    const t1 = e1.style.terrain ? (t1, i)=>e1.style.terrain.getElevation(l, t1, i) : null, i = "map" === o.layout.get("text-rotation-alignment");
                    ht(c, l.posMatrix, e1, r, B, F, g, h, i, t1);
                }
                const N = e1.translatePosMatrix(l.posMatrix, a, s, n), G = x || r && T || U ? Di : B, Z = e1.translatePosMatrix(F, a, s, n, !0), V = m && 0 !== o.paint.get(r ? "text-halo-width" : "icon-halo-width").constantOr(1);
                let q;
                q = m ? c.iconsInText ? Me(w.kind, S, v, g, e1, N, G, Z, z, L) : Pe(w.kind, S, v, g, e1, N, G, Z, r, z, !0) : ze(w.kind, S, v, g, e1, N, G, Z, r, z);
                const j = {
                    program: C,
                    buffers: u,
                    uniformValues: q,
                    atlasTexture: P,
                    atlasTextureIcon: R,
                    atlasInterpolation: M,
                    atlasInterpolationIcon: A,
                    isSDF: m,
                    hasHalo: V
                };
                if (y && c.canOverlap) {
                    b = !0;
                    const e1 = u.segments.get();
                    for (const i of e1)E.push({
                        segments: new t1.SegmentVector([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: j,
                        terrainData: D
                    });
                } else E.push({
                    segments: u.segments,
                    sortKey: 0,
                    state: j,
                    terrainData: D
                });
            }
            b && E.sort((t1, e1)=>t1.sortKey - e1.sortKey);
            for (const t1 of E){
                const i = t1.state;
                if (m.activeTexture.set(_.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, _.CLAMP_TO_EDGE), i.atlasTextureIcon && (m.activeTexture.set(_.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, _.CLAMP_TO_EDGE)), i.isSDF) {
                    const a = i.uniformValues;
                    i.hasHalo && (a.u_is_halo = 1, Li(i.buffers, t1.segments, o, e1, i.program, w, u, d, a, t1.terrainData)), a.u_is_halo = 0;
                }
                Li(i.buffers, t1.segments, o, e1, i.program, w, u, d, i.uniformValues, t1.terrainData);
            }
        }
        function Li(t1, e1, i, o, a, r, s, n, l, c) {
            const h = o.context;
            a.draw(h, h.gl.TRIANGLES, r, s, n, Ii.disabled, l, c, i.id, t1.layoutVertexBuffer, t1.indexBuffer, e1, i.paint, o.transform.zoom, t1.programConfigurations.get(i.id), t1.dynamicLayoutVertexBuffer, t1.opacityVertexBuffer);
        }
        function Ri(t1, e1, i, o, a, r, s) {
            const n = t1.context.gl, l = i.paint.get("fill-pattern"), c = l && l.constantOr(1), h = i.getCrossfadeParameters();
            let u, d, m, _, p;
            s ? (d = c && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u = n.LINES) : (d = c ? "fillPattern" : "fill", u = n.TRIANGLES);
            for (const f of o){
                const o = e1.getTile(f);
                if (c && !o.patternsLoaded()) continue;
                const g = o.getBucket(i);
                if (!g) continue;
                const x = g.programConfigurations.get(i.id), v = t1.useProgram(d, x), y = t1.style.terrain && t1.style.terrain.getTerrainData(f);
                c && (t1.context.activeTexture.set(n.TEXTURE0), o.imageAtlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), x.updatePaintBuffers(h));
                const b = l.constantOr(null);
                if (b && o.imageAtlas) {
                    const t1 = o.imageAtlas, e1 = t1.patternPositions[b.to.toString()], i = t1.patternPositions[b.from.toString()];
                    e1 && i && x.setConstantPatternPositions(e1, i);
                }
                const w = y ? f : null, T = t1.translatePosMatrix(w ? w.posMatrix : f.posMatrix, o, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor"));
                if (s) {
                    _ = g.indexBuffer2, p = g.segments2;
                    const e1 = [
                        n.drawingBufferWidth,
                        n.drawingBufferHeight
                    ];
                    m = "fillOutlinePattern" === d && c ? _e(T, t1, h, o, e1) : me(T, e1);
                } else _ = g.indexBuffer, p = g.segments, m = c ? de(T, t1, h, o) : ue(T);
                v.draw(t1.context, u, a, t1.stencilModeForClipping(f), r, Ii.disabled, m, y, i.id, g.layoutVertexBuffer, _, p, i.paint, t1.transform.zoom, x);
            }
        }
        function ki(t1, e1, i, o, a, r, s) {
            const n = t1.context, l = n.gl, c = i.paint.get("fill-extrusion-pattern"), h = c.constantOr(1), u = i.getCrossfadeParameters(), d = i.paint.get("fill-extrusion-opacity");
            for (const m of o){
                const o = e1.getTile(m), _ = o.getBucket(i);
                if (!_) continue;
                const p = t1.style.terrain && t1.style.terrain.getTerrainData(m), f = _.programConfigurations.get(i.id), g = t1.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", f);
                h && (t1.context.activeTexture.set(l.TEXTURE0), o.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), f.updatePaintBuffers(u));
                const x = c.constantOr(null);
                if (x && o.imageAtlas) {
                    const t1 = o.imageAtlas, e1 = t1.patternPositions[x.to.toString()], i = t1.patternPositions[x.from.toString()];
                    e1 && i && f.setConstantPatternPositions(e1, i);
                }
                const v = t1.translatePosMatrix(m.posMatrix, o, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), y = i.paint.get("fill-extrusion-vertical-gradient"), b = h ? he(v, t1, y, d, m, u, o) : ce(v, t1, y, d);
                g.draw(n, n.gl.TRIANGLES, a, r, s, Ii.backCCW, b, p, i.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, i.paint, t1.transform.zoom, f, t1.style.terrain && _.centroidVertexBuffer);
            }
        }
        function Bi(t1, e1, i, o, a, r, s) {
            const n = t1.context, l = n.gl, c = i.fbo;
            if (!c) return;
            const h = t1.useProgram("hillshade"), u = t1.style.terrain && t1.style.terrain.getTerrainData(e1);
            n.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get()), h.draw(n, l.TRIANGLES, a, r, s, Ii.disabled, ((t1, e1, i, o)=>{
                const a = i.paint.get("hillshade-shadow-color"), r = i.paint.get("hillshade-highlight-color"), s = i.paint.get("hillshade-accent-color");
                let n = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === i.paint.get("hillshade-illumination-anchor") && (n -= t1.transform.angle);
                const l = !t1.options.moving;
                return {
                    u_matrix: o ? o.posMatrix : t1.transform.calculatePosMatrix(e1.tileID.toUnwrapped(), l),
                    u_image: 0,
                    u_latrange: ye(0, e1.tileID),
                    u_light: [
                        i.paint.get("hillshade-exaggeration"),
                        n
                    ],
                    u_shadow: a,
                    u_highlight: r,
                    u_accent: s
                };
            })(t1, i, o, u ? e1 : null), u, o.id, t1.rasterBoundsBuffer, t1.quadTriangleIndexBuffer, t1.rasterBoundsSegments);
        }
        function Fi(e1, i, o, a, r, s) {
            const n = e1.context, c = n.gl, h = i.dem;
            if (h && h.data) {
                const u = h.dim, d = h.stride, m = h.getPixels();
                if (n.activeTexture.set(c.TEXTURE1), n.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e1.getTileTexture(d), i.demTexture) {
                    const t1 = i.demTexture;
                    t1.update(m, {
                        premultiply: !1
                    }), t1.bind(c.NEAREST, c.CLAMP_TO_EDGE);
                } else i.demTexture = new l(n, m, c.RGBA, {
                    premultiply: !1
                }), i.demTexture.bind(c.NEAREST, c.CLAMP_TO_EDGE);
                n.activeTexture.set(c.TEXTURE0);
                let _ = i.fbo;
                if (!_) {
                    const t1 = new l(n, {
                        width: u,
                        height: u,
                        data: null
                    }, c.RGBA);
                    t1.bind(c.LINEAR, c.CLAMP_TO_EDGE), _ = i.fbo = n.createFramebuffer(u, u, !0), _.colorAttachment.set(t1.texture);
                }
                n.bindFramebuffer.set(_.framebuffer), n.viewport.set([
                    0,
                    0,
                    u,
                    u
                ]), e1.useProgram("hillshadePrepare").draw(n, c.TRIANGLES, a, r, s, Ii.disabled, ((e1, i)=>{
                    const o = i.stride, a = t1.create();
                    return t1.ortho(a, 0, t1.EXTENT, -t1.EXTENT, 0, 0, 1), t1.translate(a, a, [
                        0,
                        -t1.EXTENT,
                        0
                    ]), {
                        u_matrix: a,
                        u_image: 1,
                        u_dimension: [
                            o,
                            o
                        ],
                        u_zoom: e1.overscaledZ,
                        u_unpack: i.getUnpackVector()
                    };
                })(i.tileID, h), null, o.id, e1.rasterBoundsBuffer, e1.quadTriangleIndexBuffer, e1.rasterBoundsSegments), i.needsHillshadePrepare = !1;
            }
        }
        function Oi(e1, i, o, a, r, s) {
            const n = a.paint.get("raster-fade-duration");
            if (!s && n > 0) {
                const a = t1.exported.now(), s = (a - e1.timeAdded) / n, l = i ? (a - i.timeAdded) / n : -1, c = o.getSource(), h = r.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e1.tileID.overscaledZ - h), d = u && e1.refreshedUponExpiration ? 1 : t1.clamp(u ? s : 1 - l, 0, 1);
                return e1.refreshedUponExpiration && s >= 1 && (e1.refreshedUponExpiration = !1), i ? {
                    opacity: 1,
                    mix: 1 - d
                } : {
                    opacity: d,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        const Ui = new t1.Color(1, 0, 0, 1), Ni = new t1.Color(0, 1, 0, 1), Gi = new t1.Color(0, 0, 1, 1), Zi = new t1.Color(1, 0, 1, 1), Vi = new t1.Color(0, 1, 1, 1);
        function qi(t1, e1, i, o) {
            $i(t1, 0, e1 + i / 2, t1.transform.width, i, o);
        }
        function ji(t1, e1, i, o) {
            $i(t1, e1 - i / 2, 0, i, t1.transform.height, o);
        }
        function $i(t1, e1, i, o, a, r) {
            const s = t1.context, n = s.gl;
            n.enable(n.SCISSOR_TEST), n.scissor(e1 * t1.pixelRatio, i * t1.pixelRatio, o * t1.pixelRatio, a * t1.pixelRatio), s.clear({
                color: r
            }), n.disable(n.SCISSOR_TEST);
        }
        function Xi(e1, i, o) {
            const a = e1.context, r = a.gl, s = o.posMatrix, n = e1.useProgram("debug"), l = wi.disabled, c = Ei.disabled, h = e1.colorModeForRenderPass(), u = "$debug", d = e1.style.terrain && e1.style.terrain.getTerrainData(o);
            a.activeTexture.set(r.TEXTURE0), e1.emptyTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
            const m = i.getTileByID(o.key).latestRawTileData, _ = Math.floor((m && m.byteLength || 0) / 1024), p = i.getTile(o).tileSize, f = 512 / Math.min(p, 512) * (o.overscaledZ / e1.transform.zoom) * .5;
            let g = o.canonical.toString();
            o.overscaledZ !== o.canonical.z && (g += ` => ${o.overscaledZ}`), function(t1, e1) {
                t1.initDebugOverlayCanvas();
                const i = t1.debugOverlayCanvas, o = t1.context.gl, a = t1.debugOverlayCanvas.getContext("2d");
                a.clearRect(0, 0, i.width, i.height), a.shadowColor = "white", a.shadowBlur = 2, a.lineWidth = 1.5, a.strokeStyle = "white", a.textBaseline = "top", a.font = "bold 36px Open Sans, sans-serif", a.fillText(e1, 5, 5), a.strokeText(e1, 5, 5), t1.debugOverlayTexture.update(i), t1.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }(e1, `${g} ${_}kB`), n.draw(a, r.TRIANGLES, l, c, yi.alphaBlended, Ii.disabled, ge(s, t1.Color.transparent, f), null, u, e1.debugBuffer, e1.quadTriangleIndexBuffer, e1.debugSegments), n.draw(a, r.LINE_STRIP, l, c, h, Ii.disabled, ge(s, t1.Color.red), d, u, e1.debugBuffer, e1.tileBorderIndexBuffer, e1.debugSegments);
        }
        function Wi(t1, e1, i) {
            const o = t1.context, a = o.gl, r = t1.colorModeForRenderPass(), s = new wi(a.LEQUAL, wi.ReadWrite, t1.depthRangeFor3D), n = t1.useProgram("terrain"), l = e1.getTerrainMesh(), c = e1.getTerrainData(i.tileID);
            o.bindFramebuffer.set(null), o.viewport.set([
                0,
                0,
                t1.width,
                t1.height
            ]), o.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e1.getRTTFramebuffer().colorAttachment.get());
            const h = t1.transform.calculatePosMatrix(i.tileID.toUnwrapped());
            n.draw(o, a.TRIANGLES, s, Ei.disabled, r, Ii.backCCW, {
                u_matrix: h,
                u_texture: 0
            }, c, "terrain", l.vertexBuffer, l.indexBuffer, l.segments);
        }
        function Hi(t1, e1, i, o) {
            const a = t1.context, r = i.tileSize * e1.qualityFactor;
            i.textures[o] || (i.textures[o] = t1.getTileTexture(r) || new l(a, {
                width: r,
                height: r,
                data: null
            }, a.gl.RGBA), i.textures[o].bind(a.gl.LINEAR, a.gl.CLAMP_TO_EDGE), 0 === o && e1.sourceCache.renderHistory.unshift(i.tileID.key));
            const s = e1.getRTTFramebuffer();
            s.colorAttachment.set(i.textures[o].texture), a.bindFramebuffer.set(s.framebuffer), a.viewport.set([
                0,
                0,
                r,
                r
            ]);
        }
        class Ki {
            constructor(t1){
                this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this.painter = t1, this._renderToTexture = {
                    background: !0,
                    fill: !0,
                    line: !0,
                    raster: !0
                }, this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this._stacks = [], this._prevType = null, this._rerender = {}, this._renderableTiles = t1.style.terrain.sourceCache.getRenderableTiles(), this._init();
            }
            _init() {
                const t1 = this.painter.style, e1 = t1.terrain;
                for(const i in t1.sourceCaches){
                    this._coordsDescendingInv[i] = {};
                    const o = t1.sourceCaches[i].getVisibleCoordinates();
                    for (const t1 of o){
                        const o = e1.sourceCache.getTerrainCoords(t1);
                        for(const t1 in o)this._coordsDescendingInv[i][t1] || (this._coordsDescendingInv[i][t1] = []), this._coordsDescendingInv[i][t1].push(o[t1]);
                    }
                }
                for (const e1 of t1._order){
                    const i = t1._layers[e1], o = i.source;
                    if (this._renderToTexture[i.type] && !this._coordsDescendingInvStr[o]) {
                        this._coordsDescendingInvStr[o] = {};
                        for(const t1 in this._coordsDescendingInv[o])this._coordsDescendingInvStr[o][t1] = this._coordsDescendingInv[o][t1].map((t1)=>t1.key).sort().join();
                    }
                }
                return this._renderableTiles.forEach((t1)=>{
                    for(const i in this._coordsDescendingInvStr){
                        const o = this._coordsDescendingInvStr[i][t1.tileID.key];
                        o && o !== t1.textureCoords[i] && t1.clearTextures(this.painter), e1.needsRerender(i, t1.tileID) && t1.clearTextures(this.painter);
                    }
                    this._rerender[t1.tileID.key] = !t1.textures.length;
                }), e1.clearRerenderCache(), e1.sourceCache.removeOutdated(this.painter), this;
            }
            renderLayer(e1) {
                const i = e1.type, o = this.painter, a = o.style._order, r = o.currentLayer, s = r + 1 === a.length;
                if (this._renderToTexture[i] && (this._prevType && this._renderToTexture[this._prevType] || this._stacks.push([]), this._prevType = i, this._stacks[this._stacks.length - 1].push(a[r]), !s)) return !0;
                if (this._renderToTexture[this._prevType] || "hillshade" === i || this._renderToTexture[i] && s) {
                    this._prevType = i;
                    const s = this._stacks.length - 1, n = this._stacks[s] || [];
                    for (const e1 of this._renderableTiles){
                        if (Hi(o, o.style.terrain, e1, s), this._rerender[e1.tileID.key]) {
                            o.context.clear({
                                color: t1.Color.transparent
                            });
                            for(let t1 = 0; t1 < n.length; t1++){
                                const i = o.style._layers[n[t1]], a = i.source ? this._coordsDescendingInv[i.source][e1.tileID.key] : [
                                    e1.tileID
                                ];
                                o._renderTileClippingMasks(i, a), o.renderLayer(o, o.style.sourceCaches[i.source], i, a), i.source && (e1.textureCoords[i.source] = this._coordsDescendingInvStr[i.source][e1.tileID.key]);
                            }
                        }
                        Wi(o, o.style.terrain, e1);
                    }
                    if ("hillshade" === i) {
                        this._stacks.push([
                            a[r]
                        ]);
                        for (const i of this._renderableTiles){
                            const a = this._coordsDescendingInv[e1.source][i.tileID.key];
                            Hi(o, o.style.terrain, i, this._stacks.length - 1), o.context.clear({
                                color: t1.Color.transparent
                            }), o._renderTileClippingMasks(e1, a), o.renderLayer(o, o.style.sourceCaches[e1.source], e1, a), Wi(o, o.style.terrain, i);
                        }
                        return !0;
                    }
                    return this._renderToTexture[i];
                }
                return !1;
            }
        }
        const Yi = {
            symbol: function(e1, i, o, a, r) {
                if ("translucent" !== e1.renderPass) return;
                const s = Ei.disabled, n = e1.colorModeForRenderPass();
                o.layout.get("text-variable-anchor") && function(e1, i, o, a, r, s, n) {
                    const l = i.transform, c = "map" === r, h = "map" === s;
                    for (const r of e1){
                        const e1 = a.getTile(r), s = e1.getBucket(o);
                        if (!s || !s.text || !s.text.segments.get().length) continue;
                        const u = t1.evaluateSizeForZoom(s.textSizeData, l.zoom), d = bt(e1, 1, i.transform.zoom), m = rt(r.posMatrix, h, c, i.transform, d), _ = "none" !== o.layout.get("icon-text-fit") && s.hasIconData();
                        if (u) {
                            const t1 = Math.pow(2, l.zoom - e1.tileID.overscaledZ);
                            Pi(s, c, h, n, l, m, r.posMatrix, t1, u, _, i.style.terrain ? (t1, e1)=>i.style.terrain.getElevation(r, t1, e1) : null);
                        }
                    }
                }(a, e1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), r), 0 !== o.paint.get("icon-opacity").constantOr(1) && Ai(e1, i, o, a, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), s, n), 0 !== o.paint.get("text-opacity").constantOr(1) && Ai(e1, i, o, a, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), s, n), i.map.showCollisionBoxes && (Si(e1, i, o, a, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), Si(e1, i, o, a, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(e1, i, o, a) {
                if ("translucent" !== e1.renderPass) return;
                const r = o.paint.get("circle-opacity"), s = o.paint.get("circle-stroke-width"), n = o.paint.get("circle-stroke-opacity"), l = !o.layout.get("circle-sort-key").isConstant();
                if (0 === r.constantOr(1) && (0 === s.constantOr(1) || 0 === n.constantOr(1))) return;
                const c = e1.context, h = c.gl, u = e1.depthModeForSublayer(0, wi.ReadOnly), d = Ei.disabled, m = e1.colorModeForRenderPass(), _ = [];
                for(let r = 0; r < a.length; r++){
                    const s = a[r], n = i.getTile(s), c = n.getBucket(o);
                    if (!c) continue;
                    const h = c.programConfigurations.get(o.id), u = e1.useProgram("circle", h), d = c.layoutVertexBuffer, m = c.indexBuffer, p = e1.style.terrain && e1.style.terrain.getTerrainData(s), f = {
                        programConfiguration: h,
                        program: u,
                        layoutVertexBuffer: d,
                        indexBuffer: m,
                        uniformValues: pe(e1, s, n, o),
                        terrainData: p
                    };
                    if (l) {
                        const e1 = c.segments.get();
                        for (const i of e1)_.push({
                            segments: new t1.SegmentVector([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: f
                        });
                    } else _.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: f
                    });
                }
                l && _.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                for (const t1 of _){
                    const { programConfiguration: i, program: a, layoutVertexBuffer: r, indexBuffer: s, uniformValues: n, terrainData: l } = t1.state;
                    a.draw(c, h.TRIANGLES, u, d, m, Ii.disabled, n, l, o.id, r, s, t1.segments, o.paint, e1.transform.zoom, i);
                }
            },
            heatmap: function(e1, i, o, a) {
                if (0 !== o.paint.get("heatmap-opacity")) {
                    if ("offscreen" === e1.renderPass) {
                        const r = e1.context, s = r.gl, n = Ei.disabled, l = new yi([
                            s.ONE,
                            s.ONE
                        ], t1.Color.transparent, [
                            !0,
                            !0,
                            !0,
                            !0
                        ]);
                        !function(t1, e1, i) {
                            const o = t1.gl;
                            t1.activeTexture.set(o.TEXTURE1), t1.viewport.set([
                                0,
                                0,
                                e1.width / 4,
                                e1.height / 4
                            ]);
                            let a = i.heatmapFbo;
                            if (a) o.bindTexture(o.TEXTURE_2D, a.colorAttachment.get()), t1.bindFramebuffer.set(a.framebuffer);
                            else {
                                const r = o.createTexture();
                                o.bindTexture(o.TEXTURE_2D, r), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), a = i.heatmapFbo = t1.createFramebuffer(e1.width / 4, e1.height / 4, !1), function(t1, e1, i, o) {
                                    const a = t1.gl;
                                    a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, e1.width / 4, e1.height / 4, 0, a.RGBA, t1.extRenderToTextureHalfFloat ? t1.extTextureHalfFloat.HALF_FLOAT_OES : a.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                                }(t1, e1, r, a);
                            }
                        }(r, e1, o), r.clear({
                            color: t1.Color.transparent
                        });
                        for(let t1 = 0; t1 < a.length; t1++){
                            const c = a[t1];
                            if (i.hasRenderableParent(c)) continue;
                            const h = i.getTile(c), u = h.getBucket(o);
                            if (!u) continue;
                            const d = u.programConfigurations.get(o.id), m = e1.useProgram("heatmap", d), { zoom: _ } = e1.transform;
                            m.draw(r, s.TRIANGLES, wi.disabled, n, l, Ii.disabled, ve(c.posMatrix, h, _, o.paint.get("heatmap-intensity")), null, o.id, u.layoutVertexBuffer, u.indexBuffer, u.segments, o.paint, e1.transform.zoom, d);
                        }
                        r.viewport.set([
                            0,
                            0,
                            e1.width,
                            e1.height
                        ]);
                    } else "translucent" === e1.renderPass && (e1.context.setColorMode(e1.colorModeForRenderPass()), function(e1, i) {
                        const o = e1.context, a = o.gl, r = i.heatmapFbo;
                        if (!r) return;
                        o.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, r.colorAttachment.get()), o.activeTexture.set(a.TEXTURE1);
                        let s = i.colorRampTexture;
                        s || (s = i.colorRampTexture = new l(o, i.colorRamp, a.RGBA)), s.bind(a.LINEAR, a.CLAMP_TO_EDGE), e1.useProgram("heatmapTexture").draw(o, a.TRIANGLES, wi.disabled, Ei.disabled, e1.colorModeForRenderPass(), Ii.disabled, ((e1, i, o, a)=>{
                            const r = t1.create();
                            t1.ortho(r, 0, e1.width, e1.height, 0, 0, 1);
                            const s = e1.context.gl;
                            return {
                                u_matrix: r,
                                u_world: [
                                    s.drawingBufferWidth,
                                    s.drawingBufferHeight
                                ],
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: i.paint.get("heatmap-opacity")
                            };
                        })(e1, i), null, i.id, e1.viewportBuffer, e1.quadTriangleIndexBuffer, e1.viewportSegments, i.paint, e1.transform.zoom);
                    }(e1, o));
                }
            },
            line: function(e1, i, o, a) {
                if ("translucent" !== e1.renderPass) return;
                const r = o.paint.get("line-opacity"), s = o.paint.get("line-width");
                if (0 === r.constantOr(1) || 0 === s.constantOr(1)) return;
                const n = e1.depthModeForSublayer(0, wi.ReadOnly), c = e1.colorModeForRenderPass(), h = o.paint.get("line-dasharray"), u = o.paint.get("line-pattern"), d = u.constantOr(1), m = o.paint.get("line-gradient"), _ = o.getCrossfadeParameters(), p = d ? "linePattern" : h ? "lineSDF" : m ? "lineGradient" : "line", f = e1.context, g = f.gl;
                let x = !0;
                for (const r of a){
                    const a = i.getTile(r);
                    if (d && !a.patternsLoaded()) continue;
                    const s = a.getBucket(o);
                    if (!s) continue;
                    const v = s.programConfigurations.get(o.id), y = e1.context.program.get(), b = e1.useProgram(p, v), w = x || b.program !== y, T = e1.style.terrain && e1.style.terrain.getTerrainData(r), E = u.constantOr(null);
                    if (E && a.imageAtlas) {
                        const t1 = a.imageAtlas, e1 = t1.patternPositions[E.to.toString()], i = t1.patternPositions[E.from.toString()];
                        e1 && i && v.setConstantPatternPositions(e1, i);
                    }
                    const I = T ? r : null, C = d ? Te(e1, a, o, _, I) : h ? Ee(e1, a, o, h, _, I) : m ? we(e1, a, o, s.lineClipsArray.length, I) : be(e1, a, o, I);
                    if (d) f.activeTexture.set(g.TEXTURE0), a.imageAtlasTexture.bind(g.LINEAR, g.CLAMP_TO_EDGE), v.updatePaintBuffers(_);
                    else if (h && (w || e1.lineAtlas.dirty)) f.activeTexture.set(g.TEXTURE0), e1.lineAtlas.bind(f);
                    else if (m) {
                        const a = s.gradients[o.id];
                        let n = a.texture;
                        if (o.gradientVersion !== a.version) {
                            let c = 256;
                            if (o.stepInterpolant) {
                                const o = i.getSource().maxzoom, a = r.canonical.z === o ? Math.ceil(1 << e1.transform.maxZoom - r.canonical.z) : 1;
                                c = t1.clamp(t1.nextPowerOfTwo(s.maxLineLength / t1.EXTENT * 1024 * a), 256, f.maxTextureSize);
                            }
                            a.gradient = t1.renderColorRamp({
                                expression: o.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: c,
                                image: a.gradient || void 0,
                                clips: s.lineClipsArray
                            }), a.texture ? a.texture.update(a.gradient) : a.texture = new l(f, a.gradient, g.RGBA), a.version = o.gradientVersion, n = a.texture;
                        }
                        f.activeTexture.set(g.TEXTURE0), n.bind(o.stepInterpolant ? g.NEAREST : g.LINEAR, g.CLAMP_TO_EDGE);
                    }
                    b.draw(f, g.TRIANGLES, n, e1.stencilModeForClipping(r), c, Ii.disabled, C, T, o.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, o.paint, e1.transform.zoom, v, s.layoutVertexBuffer2), x = !1;
                }
            },
            fill: function(e1, i, o, a) {
                const r = o.paint.get("fill-color"), s = o.paint.get("fill-opacity");
                if (0 === s.constantOr(1)) return;
                const n = e1.colorModeForRenderPass(), l = o.paint.get("fill-pattern"), c = e1.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === r.constantOr(t1.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";
                if (e1.renderPass === c) {
                    const t1 = e1.depthModeForSublayer(1, "opaque" === e1.renderPass ? wi.ReadWrite : wi.ReadOnly);
                    Ri(e1, i, o, a, t1, n, !1);
                }
                if ("translucent" === e1.renderPass && o.paint.get("fill-antialias")) {
                    const t1 = e1.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, wi.ReadOnly);
                    Ri(e1, i, o, a, t1, n, !0);
                }
            },
            "fill-extrusion": function(t1, e1, i, o) {
                const a = i.paint.get("fill-extrusion-opacity");
                if (0 !== a && "translucent" === t1.renderPass) {
                    const r = new wi(t1.context.gl.LEQUAL, wi.ReadWrite, t1.depthRangeFor3D);
                    if (1 !== a || i.paint.get("fill-extrusion-pattern").constantOr(1)) ki(t1, e1, i, o, r, Ei.disabled, yi.disabled), ki(t1, e1, i, o, r, t1.stencilModeFor3D(), t1.colorModeForRenderPass());
                    else {
                        const a = t1.colorModeForRenderPass();
                        ki(t1, e1, i, o, r, Ei.disabled, a);
                    }
                }
            },
            hillshade: function(t1, e1, i, o) {
                if ("offscreen" !== t1.renderPass && "translucent" !== t1.renderPass) return;
                const a = t1.context, r = t1.depthModeForSublayer(0, wi.ReadOnly), s = t1.colorModeForRenderPass(), [n, l] = "translucent" === t1.renderPass ? t1.stencilConfigForOverlap(o) : [
                    {},
                    o
                ];
                for (const o of l){
                    const a = e1.getTile(o);
                    void 0 !== a.needsHillshadePrepare && a.needsHillshadePrepare && "offscreen" === t1.renderPass ? Fi(t1, a, i, r, Ei.disabled, s) : "translucent" === t1.renderPass && Bi(t1, o, a, i, r, n[o.overscaledZ], s);
                }
                a.viewport.set([
                    0,
                    0,
                    t1.width,
                    t1.height
                ]);
            },
            raster: function(t1, e1, i, o) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === i.paint.get("raster-opacity")) return;
                if (!o.length) return;
                const a = t1.context, r = a.gl, s = e1.getSource(), n = t1.useProgram("raster"), l = t1.colorModeForRenderPass(), [c, h] = s instanceof D ? [
                    {},
                    o
                ] : t1.stencilConfigForOverlap(o), u = h[h.length - 1].overscaledZ, d = !t1.options.moving;
                for (const o of h){
                    const h = t1.depthModeForSublayer(o.overscaledZ - u, 1 === i.paint.get("raster-opacity") ? wi.ReadWrite : wi.ReadOnly, r.LESS), m = e1.getTile(o);
                    m.registerFadeDuration(i.paint.get("raster-fade-duration"));
                    const _ = e1.findLoadedParent(o, 0), p = Oi(m, _, e1, i, t1.transform, t1.style.terrain);
                    let f, g;
                    const x = "nearest" === i.paint.get("raster-resampling") ? r.NEAREST : r.LINEAR;
                    a.activeTexture.set(r.TEXTURE0), m.texture.bind(x, r.CLAMP_TO_EDGE, r.LINEAR_MIPMAP_NEAREST), a.activeTexture.set(r.TEXTURE1), _ ? (_.texture.bind(x, r.CLAMP_TO_EDGE, r.LINEAR_MIPMAP_NEAREST), f = Math.pow(2, _.tileID.overscaledZ - m.tileID.overscaledZ), g = [
                        m.tileID.canonical.x * f % 1,
                        m.tileID.canonical.y * f % 1
                    ]) : m.texture.bind(x, r.CLAMP_TO_EDGE, r.LINEAR_MIPMAP_NEAREST);
                    const v = t1.style.terrain && t1.style.terrain.getTerrainData(o), y = v ? o : null, b = y ? y.posMatrix : t1.transform.calculatePosMatrix(o.toUnwrapped(), d), w = Se(b, g || [
                        0,
                        0
                    ], f || 1, p, i);
                    s instanceof D ? n.draw(a, r.TRIANGLES, h, Ei.disabled, l, Ii.disabled, w, v, i.id, s.boundsBuffer, t1.quadTriangleIndexBuffer, s.boundsSegments) : n.draw(a, r.TRIANGLES, h, c[o.overscaledZ], l, Ii.disabled, w, v, i.id, t1.rasterBoundsBuffer, t1.quadTriangleIndexBuffer, t1.rasterBoundsSegments);
                }
            },
            background: function(t1, e1, i, o) {
                const a = i.paint.get("background-color"), r = i.paint.get("background-opacity");
                if (0 === r) return;
                const s = t1.context, n = s.gl, l = t1.transform, c = l.tileSize, h = i.paint.get("background-pattern");
                if (t1.isPatternMissing(h)) return;
                const u = !h && 1 === a.a && 1 === r && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== u) return;
                const d = Ei.disabled, m = t1.depthModeForSublayer(0, "opaque" === u ? wi.ReadWrite : wi.ReadOnly), _ = t1.colorModeForRenderPass(), p = t1.useProgram(h ? "backgroundPattern" : "background"), f = o || l.coveringTiles({
                    tileSize: c,
                    terrain: t1.style.terrain
                });
                h && (s.activeTexture.set(n.TEXTURE0), t1.imageManager.bind(t1.context));
                const g = i.getCrossfadeParameters();
                for (const e1 of f){
                    const l = o ? e1.posMatrix : t1.transform.calculatePosMatrix(e1.toUnwrapped()), u = h ? Le(l, r, t1, h, {
                        tileID: e1,
                        tileSize: c
                    }, g) : Ae(l, r, a), f = t1.style.terrain && t1.style.terrain.getTerrainData(e1);
                    p.draw(s, n.TRIANGLES, m, d, _, Ii.disabled, u, f, i.id, t1.tileExtentBuffer, t1.quadTriangleIndexBuffer, t1.tileExtentSegments);
                }
            },
            debug: function(t1, e1, i) {
                for(let o = 0; o < i.length; o++)Xi(t1, e1, i[o]);
            },
            custom: function(t1, e1, i) {
                const o = t1.context, a = i.implementation;
                if ("offscreen" === t1.renderPass) {
                    const e1 = a.prerender;
                    e1 && (t1.setCustomLayerDefaults(), o.setColorMode(t1.colorModeForRenderPass()), e1.call(a, o.gl, t1.transform.customLayerMatrix()), o.setDirty(), t1.setBaseState());
                } else if ("translucent" === t1.renderPass) {
                    t1.setCustomLayerDefaults(), o.setColorMode(t1.colorModeForRenderPass()), o.setStencilMode(Ei.disabled);
                    const e1 = "3d" === a.renderingMode ? new wi(t1.context.gl.LEQUAL, wi.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, wi.ReadOnly);
                    o.setDepthMode(e1), a.render(o.gl, t1.transform.customLayerMatrix()), o.setDirty(), t1.setBaseState(), o.bindFramebuffer.set(null);
                }
            }
        };
        class Ji {
            constructor(e1, i){
                this.context = new bi(e1), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = {
                    dirty: !0,
                    matrix: t1.create(),
                    renderTime: 0
                }, this.setup(), this.numSublayers = O.maxUnderzooming + O.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Xt, this.gpuTimers = {};
            }
            resize(t1, e1, i) {
                if (this.width = t1 * i, this.height = e1 * i, this.pixelRatio = i, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const t1 of this.style._order)this.style._layers[t1].resize();
            }
            setup() {
                const e1 = this.context, i = new t1.PosArray;
                i.emplaceBack(0, 0), i.emplaceBack(t1.EXTENT, 0), i.emplaceBack(0, t1.EXTENT), i.emplaceBack(t1.EXTENT, t1.EXTENT), this.tileExtentBuffer = e1.createVertexBuffer(i, Wt.members), this.tileExtentSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const o = new t1.PosArray;
                o.emplaceBack(0, 0), o.emplaceBack(t1.EXTENT, 0), o.emplaceBack(0, t1.EXTENT), o.emplaceBack(t1.EXTENT, t1.EXTENT), this.debugBuffer = e1.createVertexBuffer(o, Wt.members), this.debugSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 5);
                const a = new t1.RasterBoundsArray;
                a.emplaceBack(0, 0, 0, 0), a.emplaceBack(t1.EXTENT, 0, t1.EXTENT, 0), a.emplaceBack(0, t1.EXTENT, 0, t1.EXTENT), a.emplaceBack(t1.EXTENT, t1.EXTENT, t1.EXTENT, t1.EXTENT), this.rasterBoundsBuffer = e1.createVertexBuffer(a, S.members), this.rasterBoundsSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const r = new t1.PosArray;
                r.emplaceBack(0, 0), r.emplaceBack(1, 0), r.emplaceBack(0, 1), r.emplaceBack(1, 1), this.viewportBuffer = e1.createVertexBuffer(r, Wt.members), this.viewportSegments = t1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const s = new t1.LineStripIndexArray;
                s.emplaceBack(0), s.emplaceBack(1), s.emplaceBack(3), s.emplaceBack(2), s.emplaceBack(0), this.tileBorderIndexBuffer = e1.createIndexBuffer(s);
                const n = new t1.TriangleIndexArray;
                n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e1.createIndexBuffer(n), this.emptyTexture = new l(e1, {
                    width: 1,
                    height: 1,
                    data: new Uint8Array([
                        0,
                        0,
                        0,
                        0
                    ])
                }, e1.gl.RGBA);
                const c = this.context.gl;
                this.stencilClearMode = new Ei({
                    func: c.ALWAYS,
                    mask: 0
                }, 0, 255, c.ZERO, c.ZERO, c.ZERO);
            }
            clearStencil() {
                const e1 = this.context, i = e1.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0;
                const o = t1.create();
                t1.ortho(o, 0, this.width, this.height, 0, 0, 1), t1.scale(o, o, [
                    i.drawingBufferWidth,
                    i.drawingBufferHeight,
                    0
                ]), this.useProgram("clippingMask").draw(e1, i.TRIANGLES, wi.disabled, this.stencilClearMode, yi.disabled, Ii.disabled, xe(o), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(t1, e1) {
                if (this.currentStencilSource === t1.source || !t1.isTileClipped() || !e1 || !e1.length) return;
                this.currentStencilSource = t1.source;
                const i = this.context, o = i.gl;
                this.nextStencilID + e1.length > 256 && this.clearStencil(), i.setColorMode(yi.disabled), i.setDepthMode(wi.disabled);
                const a = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const t1 of e1){
                    const e1 = this._tileClippingMaskIDs[t1.key] = this.nextStencilID++, r = this.style.terrain && this.style.terrain.getTerrainData(t1);
                    a.draw(i, o.TRIANGLES, wi.disabled, new Ei({
                        func: o.ALWAYS,
                        mask: 0
                    }, e1, 255, o.KEEP, o.KEEP, o.REPLACE), yi.disabled, Ii.disabled, xe(t1.posMatrix), r, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const t1 = this.nextStencilID++, e1 = this.context.gl;
                return new Ei({
                    func: e1.NOTEQUAL,
                    mask: 255
                }, t1, 255, e1.KEEP, e1.KEEP, e1.REPLACE);
            }
            stencilModeForClipping(t1) {
                const e1 = this.context.gl;
                return new Ei({
                    func: e1.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[t1.key], 0, e1.KEEP, e1.KEEP, e1.REPLACE);
            }
            stencilConfigForOverlap(t1) {
                const e1 = this.context.gl, i = t1.sort((t1, e1)=>e1.overscaledZ - t1.overscaledZ), o = i[i.length - 1].overscaledZ, a = i[0].overscaledZ - o + 1;
                if (a > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();
                    const t1 = {};
                    for(let i = 0; i < a; i++)t1[i + o] = new Ei({
                        func: e1.GEQUAL,
                        mask: 255
                    }, i + this.nextStencilID, 255, e1.KEEP, e1.KEEP, e1.REPLACE);
                    return this.nextStencilID += a, [
                        t1,
                        i
                    ];
                }
                return [
                    {
                        [o]: Ei.disabled
                    },
                    i
                ];
            }
            colorModeForRenderPass() {
                const e1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new yi([
                        e1.CONSTANT_COLOR,
                        e1.ONE
                    ], new t1.Color(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? yi.unblended : yi.alphaBlended;
            }
            depthModeForSublayer(t1, e1, i) {
                if (!this.opaquePassEnabledForLayer()) return wi.disabled;
                const o = 1 - ((1 + this.currentLayer) * this.numSublayers + t1) * this.depthEpsilon;
                return new wi(i || this.context.gl.LEQUAL, e1, [
                    o,
                    o
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            render(e1, i) {
                this.style = e1, this.options = i, this.lineAtlas = e1.lineAtlas, this.imageManager = e1.imageManager, this.glyphManager = e1.glyphManager, this.symbolFadeChange = e1.placement.symbolFadeChange(t1.exported.now()), this.imageManager.beginFrame();
                const o = this.style._order, a = this.style.sourceCaches, r = this.style.terrain && new Ki(this);
                for(const t1 in a){
                    const e1 = a[t1];
                    e1.used && e1.prepare(this.context);
                }
                const s = {}, n = {}, l = {};
                for(const t1 in a){
                    const e1 = a[t1];
                    s[t1] = e1.getVisibleCoordinates(), n[t1] = s[t1].slice().reverse(), l[t1] = e1.getVisibleCoordinates(!0).reverse();
                }
                this.opaquePassCutoff = 1 / 0;
                for(let t1 = 0; t1 < o.length; t1++)if (this.style._layers[o[t1]].is3D()) {
                    this.opaquePassCutoff = t1;
                    break;
                }
                if (r) {
                    this.opaquePassCutoff = 0;
                    const e1 = this.style.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
                    (this.terrainFacilitator.dirty || !t1.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e1.length) && (t1.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e1, i) {
                        const o = e1.context, a = o.gl, r = yi.unblended, s = new wi(a.LEQUAL, wi.ReadWrite, [
                            0,
                            1
                        ]), n = i.getTerrainMesh(), l = i.sourceCache.getRenderableTiles(), c = e1.useProgram("terrainDepth");
                        o.bindFramebuffer.set(i.getFramebuffer("depth").framebuffer), o.viewport.set([
                            0,
                            0,
                            e1.width / devicePixelRatio,
                            e1.height / devicePixelRatio
                        ]), o.clear({
                            color: t1.Color.transparent,
                            depth: 1
                        });
                        for (const t1 of l){
                            const l = i.getTerrainData(t1.tileID), h = e1.transform.calculatePosMatrix(t1.tileID.toUnwrapped());
                            c.draw(o, a.TRIANGLES, s, Ei.disabled, r, Ii.backCCW, {
                                u_matrix: h
                            }, l, "terrain", n.vertexBuffer, n.indexBuffer, n.segments);
                        }
                        o.bindFramebuffer.set(null), o.viewport.set([
                            0,
                            0,
                            e1.width,
                            e1.height
                        ]);
                    }(this, this.style.terrain), function(e1, i) {
                        const o = e1.context, a = o.gl, r = yi.unblended, s = new wi(a.LEQUAL, wi.ReadWrite, [
                            0,
                            1
                        ]), n = i.getTerrainMesh(), l = i.getCoordsTexture(), c = i.sourceCache.getRenderableTiles(), h = e1.useProgram("terrainCoords");
                        o.bindFramebuffer.set(i.getFramebuffer("coords").framebuffer), o.viewport.set([
                            0,
                            0,
                            e1.width / devicePixelRatio,
                            e1.height / devicePixelRatio
                        ]), o.clear({
                            color: t1.Color.transparent,
                            depth: 1
                        }), i.coordsIndex = [];
                        for (const t1 of c){
                            const c = i.getTerrainData(t1.tileID);
                            o.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, l.texture);
                            const u = e1.transform.calculatePosMatrix(t1.tileID.toUnwrapped());
                            h.draw(o, a.TRIANGLES, s, Ei.disabled, r, Ii.backCCW, {
                                u_matrix: u,
                                u_terrain_coords_id: (255 - i.coordsIndex.length) / 255,
                                u_texture: 0
                            }, c, "terrain", n.vertexBuffer, n.indexBuffer, n.segments), i.coordsIndex.push(t1.tileID.key);
                        }
                        o.bindFramebuffer.set(null), o.viewport.set([
                            0,
                            0,
                            e1.width,
                            e1.height
                        ]);
                    }(this, this.style.terrain));
                }
                this.renderPass = "offscreen";
                for (const t1 of o){
                    const e1 = this.style._layers[t1];
                    if (!e1.hasOffscreenPass() || e1.isHidden(this.transform.zoom)) continue;
                    const i = n[e1.source];
                    ("custom" === e1.type || i.length) && this.renderLayer(this, a[e1.source], e1, i);
                }
                if (this.context.bindFramebuffer.set(null), this.context.clear({
                    color: i.showOverdrawInspector ? t1.Color.black : t1.Color.transparent,
                    depth: 1
                }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [
                    0,
                    1 - (e1._order.length + 2) * this.numSublayers * this.depthEpsilon
                ], !r) for(this.renderPass = "opaque", this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--){
                    const t1 = this.style._layers[o[this.currentLayer]], e1 = a[t1.source], i = s[t1.source];
                    this._renderTileClippingMasks(t1, i), this.renderLayer(this, e1, t1, i);
                }
                for(this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++){
                    const t1 = this.style._layers[o[this.currentLayer]], e1 = a[t1.source];
                    if (r && r.renderLayer(t1)) continue;
                    const i = ("symbol" === t1.type ? l : n)[t1.source];
                    this._renderTileClippingMasks(t1, s[t1.source]), this.renderLayer(this, e1, t1, i);
                }
                if (this.options.showTileBoundaries) {
                    let t1, e1;
                    Object.values(this.style._layers).forEach((i)=>{
                        i.source && !i.isHidden(this.transform.zoom) && (i.source !== (e1 && e1.id) && (e1 = this.style.sourceCaches[i.source]), (!t1 || t1.getSource().maxzoom < e1.getSource().maxzoom) && (t1 = e1));
                    }), t1 && Yi.debug(this, t1, t1.getVisibleCoordinates());
                }
                this.options.showPadding && function(t1) {
                    const e1 = t1.transform.padding;
                    qi(t1, t1.transform.height - (e1.top || 0), 3, Ui), qi(t1, e1.bottom || 0, 3, Ni), ji(t1, e1.left || 0, 3, Gi), ji(t1, t1.transform.width - (e1.right || 0), 3, Zi);
                    const i = t1.transform.centerPoint;
                    !function(t1, e1, i, o) {
                        $i(t1, e1 - 1, i - 10, 2, 20, o), $i(t1, e1 - 10, i - 1, 20, 2, o);
                    }(t1, i.x, t1.transform.height - i.y, Vi);
                }(this), this.context.setDefault();
            }
            renderLayer(t1, e1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "custom" === i.type || (o || []).length) && (this.id = i.id, this.gpuTimingStart(i), Yi[i.type](t1, e1, i, o, this.style.placement.variableOffsets), this.gpuTimingEnd());
            }
            gpuTimingStart(t1) {
                if (!this.options.gpuTiming) return;
                const e1 = this.context.extTimerQuery;
                let i = this.gpuTimers[t1.id];
                i || (i = this.gpuTimers[t1.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: e1.createQueryEXT()
                }), i.calls++, e1.beginQueryEXT(e1.TIME_ELAPSED_EXT, i.query);
            }
            gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery;
                t1.endQueryEXT(t1.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const t1 = this.gpuTimers;
                return this.gpuTimers = {}, t1;
            }
            queryGpuTimers(t1) {
                const e1 = {};
                for(const i in t1){
                    const o = t1[i], a = this.context.extTimerQuery, r = a.getQueryObjectEXT(o.query, a.QUERY_RESULT_EXT) / 1e6;
                    a.deleteQueryEXT(o.query), e1[i] = r;
                }
                return e1;
            }
            translatePosMatrix(e1, i, o, a, r) {
                if (!o[0] && !o[1]) return e1;
                const s = r ? "map" === a ? this.transform.angle : 0 : "viewport" === a ? -this.transform.angle : 0;
                if (s) {
                    const t1 = Math.sin(s), e1 = Math.cos(s);
                    o = [
                        o[0] * e1 - o[1] * t1,
                        o[0] * t1 + o[1] * e1
                    ];
                }
                const n = [
                    r ? o[0] : bt(i, o[0], this.transform.zoom),
                    r ? o[1] : bt(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return t1.translate(l, e1, n), l;
            }
            saveTileTexture(t1) {
                const e1 = this._tileTextures[t1.size[0]];
                e1 ? e1.push(t1) : this._tileTextures[t1.size[0]] = [
                    t1
                ];
            }
            getTileTexture(t1) {
                const e1 = this._tileTextures[t1];
                return e1 && e1.length > 0 ? e1.pop() : null;
            }
            isPatternMissing(t1) {
                if (!t1) return !1;
                if (!t1.from || !t1.to) return !0;
                const e1 = this.imageManager.getPattern(t1.from.toString()), i = this.imageManager.getPattern(t1.to.toString());
                return !e1 || !i;
            }
            useProgram(t1, e1) {
                this.cache = this.cache || {};
                const i = t1 + (e1 ? e1.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.terrain ? "/terrain" : "");
                return this.cache[i] || (this.cache[i] = new ne(this.context, t1, oe[t1], e1, Re[t1], this._showOverdrawInspector, this.style.terrain)), this.cache[i];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const t1 = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(t1.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new l(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
                this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
        }
        class Qi {
            constructor(t1, e1){
                this.points = t1, this.planes = e1;
            }
            static fromInvProjectionMatrix(e1, i, o) {
                const a = Math.pow(2, o), r = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((o)=>{
                    const r = 1 / (o = t1.transformMat4([], o, e1))[3] / i * a;
                    return t1.mul$1(o, o, [
                        r,
                        r,
                        1 / o[3],
                        r
                    ]);
                }), s = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((e1)=>{
                    const i = t1.sub([], r[e1[0]], r[e1[1]]), o = t1.sub([], r[e1[2]], r[e1[1]]), a = t1.normalize([], t1.cross([], i, o)), s = -t1.dot(a, r[e1[1]]);
                    return a.concat(s);
                });
                return new Qi(r, s);
            }
        }
        class to {
            constructor(e1, i){
                this.min = e1, this.max = i, this.center = t1.scale$1([], t1.add([], this.min, this.max), .5);
            }
            quadrant(e1) {
                const i = [
                    e1 % 2 == 0,
                    e1 < 2
                ], o = t1.clone$2(this.min), a = t1.clone$2(this.max);
                for(let t1 = 0; t1 < i.length; t1++)o[t1] = i[t1] ? this.min[t1] : this.center[t1], a[t1] = i[t1] ? this.center[t1] : this.max[t1];
                return a[2] = this.max[2], new to(o, a);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            intersects(e1) {
                const i = [
                    [
                        this.min[0],
                        this.min[1],
                        this.min[2],
                        1
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        this.min[2],
                        1
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        this.min[2],
                        1
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        this.min[2],
                        1
                    ],
                    [
                        this.min[0],
                        this.min[1],
                        this.max[2],
                        1
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        this.max[2],
                        1
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        this.max[2],
                        1
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        this.max[2],
                        1
                    ]
                ];
                let o = !0;
                for(let a = 0; a < e1.planes.length; a++){
                    const r = e1.planes[a];
                    let s = 0;
                    for(let e1 = 0; e1 < i.length; e1++)t1.dot$1(r, i[e1]) >= 0 && s++;
                    if (0 === s) return 0;
                    s !== i.length && (o = !1);
                }
                if (o) return 2;
                for(let t1 = 0; t1 < 3; t1++){
                    let i = Number.MAX_VALUE, o = -Number.MAX_VALUE;
                    for(let a = 0; a < e1.points.length; a++){
                        const r = e1.points[a][t1] - this.min[t1];
                        i = Math.min(i, r), o = Math.max(o, r);
                    }
                    if (o < 0 || i > this.max[t1] - this.min[t1]) return 0;
                }
                return 1;
            }
        }
        class eo {
            constructor(t1 = 0, e1 = 0, i = 0, o = 0){
                if (isNaN(t1) || t1 < 0 || isNaN(e1) || e1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = t1, this.bottom = e1, this.left = i, this.right = o;
            }
            interpolate(e1, i, o) {
                return null != i.top && null != e1.top && (this.top = t1.number(e1.top, i.top, o)), null != i.bottom && null != e1.bottom && (this.bottom = t1.number(e1.bottom, i.bottom, o)), null != i.left && null != e1.left && (this.left = t1.number(e1.left, i.left, o)), null != i.right && null != e1.right && (this.right = t1.number(e1.right, i.right, o)), this;
            }
            getCenter(e1, i) {
                const o = t1.clamp((this.left + e1 - this.right) / 2, 0, e1), a = t1.clamp((this.top + i - this.bottom) / 2, 0, i);
                return new t1.pointGeometry(o, a);
            }
            equals(t1) {
                return this.top === t1.top && this.bottom === t1.bottom && this.left === t1.left && this.right === t1.right;
            }
            clone() {
                return new eo(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        class io {
            constructor(e1, i, o, a, r){
                this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = !1, this._renderWorldCopies = void 0 === r || !!r, this._minZoom = e1 || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == a ? 60 : a, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t1.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new eo, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            clone() {
                const t1 = new io(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
                return t1.tileSize = this.tileSize, t1.latRange = this.latRange, t1.width = this.width, t1.height = this.height, t1._center = this._center, t1._elevation = this._elevation, t1.zoom = this.zoom, t1.angle = this.angle, t1._fov = this._fov, t1._pitch = this._pitch, t1._unmodified = this._unmodified, t1._edgeInsets = this._edgeInsets.clone(), t1._calcMatrices(), t1;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(t1) {
                this._minZoom !== t1 && (this._minZoom = t1, this.zoom = Math.max(this.zoom, t1));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(t1) {
                this._maxZoom !== t1 && (this._maxZoom = t1, this.zoom = Math.min(this.zoom, t1));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(t1) {
                this._minPitch !== t1 && (this._minPitch = t1, this.pitch = Math.max(this.pitch, t1));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(t1) {
                this._maxPitch !== t1 && (this._maxPitch = t1, this.pitch = Math.min(this.pitch, t1));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies;
            }
            set renderWorldCopies(t1) {
                void 0 === t1 ? t1 = !0 : null === t1 && (t1 = !1), this._renderWorldCopies = t1;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new t1.pointGeometry(this.width, this.height);
            }
            get bearing() {
                return -this.angle / Math.PI * 180;
            }
            set bearing(e1) {
                const i = -t1.wrap(e1, -180, 180) * Math.PI / 180;
                var o;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new t1.ARRAY_TYPE(4), t1.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function(t1, e1, i) {
                    var o = e1[0], a = e1[1], r = e1[2], s = e1[3], n = Math.sin(i), l = Math.cos(i);
                    t1[0] = o * l + r * n, t1[1] = a * l + s * n, t1[2] = o * -n + r * l, t1[3] = a * -n + s * l;
                }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(e1) {
                const i = t1.clamp(e1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get fov() {
                return this._fov / Math.PI * 180;
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = t1 / 180 * Math.PI, this._calcMatrices());
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(t1) {
                const e1 = Math.min(Math.max(t1, this.minZoom), this.maxZoom);
                this._zoom !== e1 && (this._unmodified = !1, this._zoom = e1, this.scale = this.zoomScale(e1), this.tileZoom = Math.floor(e1), this.zoomFraction = e1 - this.tileZoom, this._constrain(), this._calcMatrices());
            }
            get center() {
                return this._center;
            }
            set center(t1) {
                t1.lat === this._center.lat && t1.lng === this._center.lng || (this._unmodified = !1, this._center = t1, this._constrain(), this._calcMatrices());
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(t1) {
                t1 !== this._elevation && (this._elevation = t1, this._constrain(), this._calcMatrices());
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(t1) {
                this._edgeInsets.equals(t1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t1, 1), this._calcMatrices());
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            isPaddingEqual(t1) {
                return this._edgeInsets.equals(t1);
            }
            interpolatePadding(t1, e1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(t1, e1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(t1) {
                const e1 = (t1.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t1.tileSize));
                return Math.max(0, e1);
            }
            getVisibleUnwrappedCoordinates(e1) {
                const i = [
                    new t1.UnwrappedTileID(0, e1)
                ];
                if (this._renderWorldCopies) {
                    const o = this.pointCoordinate(new t1.pointGeometry(0, 0)), a = this.pointCoordinate(new t1.pointGeometry(this.width, 0)), r = this.pointCoordinate(new t1.pointGeometry(this.width, this.height)), s = this.pointCoordinate(new t1.pointGeometry(0, this.height)), n = Math.floor(Math.min(o.x, a.x, r.x, s.x)), l = Math.floor(Math.max(o.x, a.x, r.x, s.x)), c = 1;
                    for(let o = n - c; o <= l + c; o++)0 !== o && i.push(new t1.UnwrappedTileID(o, e1));
                }
                return i;
            }
            coveringTiles(e1) {
                var i, o;
                let a = this.coveringZoomLevel(e1);
                const r = a;
                if (void 0 !== e1.minzoom && a < e1.minzoom) return [];
                void 0 !== e1.maxzoom && a > e1.maxzoom && (a = e1.maxzoom);
                const s = this.pointCoordinate(this.getCameraPoint()), n = t1.MercatorCoordinate.fromLngLat(this.center), l = Math.pow(2, a), c = [
                    l * s.x,
                    l * s.y,
                    0
                ], h = [
                    l * n.x,
                    l * n.y,
                    0
                ], u = Qi.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a);
                let d = e1.minzoom || 0;
                !e1.terrain && this.pitch <= 60 && this._edgeInsets.top < .1 && (d = a);
                const m = e1.terrain ? 2 / Math.min(this.tileSize, e1.tileSize) * this.tileSize : 3, _ = (t1)=>({
                        aabb: new to([
                            t1 * l,
                            0,
                            0
                        ], [
                            (t1 + 1) * l,
                            l,
                            0
                        ]),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        wrap: t1,
                        fullyVisible: !1
                    }), p = [], f = [], g = a, x = e1.reparseOverscaled ? r : a;
                if (this._renderWorldCopies) for(let t1 = 1; t1 <= 3; t1++)p.push(_(-t1)), p.push(_(t1));
                for(p.push(_(0)); p.length > 0;){
                    const a = p.pop(), r = a.x, s = a.y;
                    let n = a.fullyVisible;
                    if (!n) {
                        const t1 = a.aabb.intersects(u);
                        if (0 === t1) continue;
                        n = 2 === t1;
                    }
                    const l = e1.terrain ? c : h, _ = a.aabb.distanceX(l), v = a.aabb.distanceY(l), y = Math.max(Math.abs(_), Math.abs(v)), b = m + (1 << g - a.zoom) - 2;
                    if (a.zoom === g || y > b && a.zoom >= d) {
                        const e1 = g - a.zoom, i = c[0] - .5 - (r << e1), o = c[1] - .5 - (s << e1);
                        f.push({
                            tileID: new t1.OverscaledTileID(a.zoom === g ? x : a.zoom, a.wrap, a.zoom, r, s),
                            distanceSq: t1.sqrLen([
                                h[0] - .5 - r,
                                h[1] - .5 - s
                            ]),
                            tileDistanceToCamera: Math.sqrt(i * i + o * o)
                        });
                    } else for(let l = 0; l < 4; l++){
                        const c = (r << 1) + l % 2, h = (s << 1) + (l >> 1), u = a.zoom + 1;
                        let d = a.aabb.quadrant(l);
                        if (e1.terrain) {
                            const r = new t1.OverscaledTileID(u, a.wrap, u, c, h), s = e1.terrain.getMinMaxElevation(r), n = null !== (i = s.minElevation) && void 0 !== i ? i : this.elevation, l = null !== (o = s.maxElevation) && void 0 !== o ? o : this.elevation;
                            d = new to([
                                d.min[0],
                                d.min[1],
                                n
                            ], [
                                d.max[0],
                                d.max[1],
                                l
                            ]);
                        }
                        p.push({
                            aabb: d,
                            zoom: u,
                            x: c,
                            y: h,
                            wrap: a.wrap,
                            fullyVisible: n
                        });
                    }
                }
                return f.sort((t1, e1)=>t1.distanceSq - e1.distanceSq).map((t1)=>t1.tileID);
            }
            resize(t1, e1) {
                this.width = t1, this.height = e1, this.pixelsToGLUnits = [
                    2 / t1,
                    -2 / e1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(t1) {
                return Math.pow(2, t1);
            }
            scaleZoom(t1) {
                return Math.log(t1) / Math.LN2;
            }
            project(e1) {
                const i = t1.clamp(e1.lat, -this.maxValidLatitude, this.maxValidLatitude);
                return new t1.pointGeometry(t1.mercatorXfromLng(e1.lng) * this.worldSize, t1.mercatorYfromLat(i) * this.worldSize);
            }
            unproject(e1) {
                return new t1.MercatorCoordinate(e1.x / this.worldSize, e1.y / this.worldSize).toLngLat();
            }
            get point() {
                return this.project(this.center);
            }
            updateElevation(t1) {
                this.freezeElevation || (this.elevation = t1 ? this.getElevation(this._center, t1) : 0);
            }
            getElevation(e1, i) {
                const o = t1.MercatorCoordinate.fromLngLat(e1), a = (1 << this.tileZoom) * t1.EXTENT, r = o.x * a, s = o.y * a, n = Math.floor(r / t1.EXTENT), l = Math.floor(s / t1.EXTENT), c = new t1.OverscaledTileID(this.tileZoom, 0, this.tileZoom, n, l);
                return i.getElevation(c, r % t1.EXTENT, s % t1.EXTENT, t1.EXTENT);
            }
            getCameraPosition() {
                return {
                    lngLat: this.pointLocation(this.getCameraPoint()),
                    altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation
                };
            }
            recalculateZoom(e1) {
                const i = this.pointLocation(this.centerPoint, e1), o = this.getElevation(i, e1);
                if (!(this.elevation - o)) return;
                const a = this.getCameraPosition(), r = t1.MercatorCoordinate.fromLngLat(a.lngLat, a.altitude), s = t1.MercatorCoordinate.fromLngLat(i, o), n = r.x - s.x, l = r.y - s.y, c = r.z - s.z, h = Math.sqrt(n * n + l * l + c * c), u = this.scaleZoom(this.cameraToCenterDistance / h / this.tileSize);
                this._elevation = o, this._center = i, this.zoom = u;
            }
            setLocationAtPoint(e1, i) {
                const o = this.pointCoordinate(i), a = this.pointCoordinate(this.centerPoint), r = this.locationCoordinate(e1), s = new t1.MercatorCoordinate(r.x - (o.x - a.x), r.y - (o.y - a.y));
                this.center = this.coordinateLocation(s), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            locationPoint(t1, e1) {
                return e1 ? this.coordinatePoint(this.locationCoordinate(t1), this.getElevation(t1, e1), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t1));
            }
            pointLocation(t1, e1) {
                return this.coordinateLocation(this.pointCoordinate(t1, e1));
            }
            locationCoordinate(e1) {
                return t1.MercatorCoordinate.fromLngLat(e1);
            }
            coordinateLocation(t1) {
                return t1 && t1.toLngLat();
            }
            pointCoordinate(e1, i) {
                if (i) {
                    const t1 = i.pointCoordinate(e1);
                    if (null != t1) return t1;
                }
                const o = [
                    e1.x,
                    e1.y,
                    0,
                    1
                ], a = [
                    e1.x,
                    e1.y,
                    1,
                    1
                ];
                t1.transformMat4(o, o, this.pixelMatrixInverse), t1.transformMat4(a, a, this.pixelMatrixInverse);
                const r = o[3], s = a[3], n = o[1] / r, l = a[1] / s, c = o[2] / r, h = a[2] / s, u = c === h ? 0 : (0 - c) / (h - c);
                return new t1.MercatorCoordinate(t1.number(o[0] / r, a[0] / s, u) / this.worldSize, t1.number(n, l, u) / this.worldSize);
            }
            coordinatePoint(e1, i = 0, o = this.pixelMatrix) {
                const a = [
                    e1.x * this.worldSize,
                    e1.y * this.worldSize,
                    i,
                    1
                ];
                return t1.transformMat4(a, a, o), new t1.pointGeometry(a[0] / a[3], a[1] / a[3]);
            }
            getBounds() {
                const e1 = Math.max(0, this.height / 2 - this.getHorizon());
                return (new t1.LngLatBounds).extend(this.pointLocation(new t1.pointGeometry(0, e1))).extend(this.pointLocation(new t1.pointGeometry(this.width, e1))).extend(this.pointLocation(new t1.pointGeometry(this.width, this.height))).extend(this.pointLocation(new t1.pointGeometry(0, this.height)));
            }
            getMaxBounds() {
                return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t1.LngLatBounds([
                    this.lngRange[0],
                    this.latRange[0]
                ], [
                    this.lngRange[1],
                    this.latRange[1]
                ]) : null;
            }
            getHorizon() {
                return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * .85;
            }
            setMaxBounds(t1) {
                t1 ? (this.lngRange = [
                    t1.getWest(),
                    t1.getEast()
                ], this.latRange = [
                    t1.getSouth(),
                    t1.getNorth()
                ], this._constrain()) : (this.lngRange = null, this.latRange = [
                    -this.maxValidLatitude,
                    this.maxValidLatitude
                ]);
            }
            calculatePosMatrix(e1, i = !1) {
                const o = e1.key, a = i ? this._alignedPosMatrixCache : this._posMatrixCache;
                if (a[o]) return a[o];
                const r = e1.canonical, s = this.worldSize / this.zoomScale(r.z), n = r.x + Math.pow(2, r.z) * e1.wrap, l = t1.identity(new Float64Array(16));
                return t1.translate(l, l, [
                    n * s,
                    r.y * s,
                    0
                ]), t1.scale(l, l, [
                    s / t1.EXTENT,
                    s / t1.EXTENT,
                    1
                ]), t1.multiply(l, i ? this.alignedProjMatrix : this.projMatrix, l), a[o] = new Float32Array(l), a[o];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                let e1, i, o, a, r = -90, s = 90, n = -180, l = 180;
                const c = this.size, h = this._unmodified;
                if (this.latRange) {
                    const i = this.latRange;
                    r = t1.mercatorYfromLat(i[1]) * this.worldSize, s = t1.mercatorYfromLat(i[0]) * this.worldSize, e1 = s - r < c.y ? c.y / (s - r) : 0;
                }
                if (this.lngRange) {
                    const e1 = this.lngRange;
                    n = t1.wrap(t1.mercatorXfromLng(e1[0]) * this.worldSize, 0, this.worldSize), l = t1.wrap(t1.mercatorXfromLng(e1[1]) * this.worldSize, 0, this.worldSize), l < n && (l += this.worldSize), i = l - n < c.x ? c.x / (l - n) : 0;
                }
                const u = this.point, d = Math.max(i || 0, e1 || 0);
                if (d) return this.center = this.unproject(new t1.pointGeometry(i ? (l + n) / 2 : u.x, e1 ? (s + r) / 2 : u.y)), this.zoom += this.scaleZoom(d), this._unmodified = h, void (this._constraining = !1);
                if (this.latRange) {
                    const t1 = u.y, e1 = c.y / 2;
                    t1 - e1 < r && (a = r + e1), t1 + e1 > s && (a = s - e1);
                }
                if (this.lngRange) {
                    const e1 = (n + l) / 2, i = t1.wrap(u.x, e1 - this.worldSize / 2, e1 + this.worldSize / 2), a = c.x / 2;
                    i - a < n && (o = n + a), i + a > l && (o = l - a);
                }
                void 0 === o && void 0 === a || (this.center = this.unproject(new t1.pointGeometry(void 0 !== o ? o : u.x, void 0 !== a ? a : u.y)).wrap()), this._unmodified = h, this._constraining = !1;
            }
            _calcMatrices() {
                if (!this.height) return;
                const e1 = this.centerOffset, i = this.point.x, o = this.point.y;
                this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t1.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
                let a = t1.identity(new Float64Array(16));
                t1.scale(a, a, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), t1.translate(a, a, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = a, a = t1.identity(new Float64Array(16)), t1.scale(a, a, [
                    1,
                    -1,
                    1
                ]), t1.translate(a, a, [
                    -1,
                    -1,
                    0
                ]), t1.scale(a, a, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = a, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
                const r = Math.PI / 2 + this._pitch, s = this._fov * (.5 + e1.y / this.height), n = Math.sin(s) * this.cameraToSeaLevelDistance / Math.sin(t1.clamp(Math.PI - r - s, .01, Math.PI - .01)), l = this.getHorizon(), c = 2 * Math.atan(l / this.cameraToCenterDistance) * (.5 + e1.y / (2 * l)), h = Math.sin(c) * this.cameraToSeaLevelDistance / Math.sin(t1.clamp(Math.PI - r - c, .01, Math.PI - .01)), u = Math.cos(Math.PI / 2 - this._pitch) * n + this.cameraToSeaLevelDistance, d = Math.cos(Math.PI / 2 - this._pitch) * h + this.cameraToSeaLevelDistance, m = 1.01 * Math.min(u, d), _ = this.height / 50;
                a = new Float64Array(16), t1.perspective(a, this._fov, this.width / this.height, _, m), a[8] = 2 * -e1.x / this.width, a[9] = 2 * e1.y / this.height, t1.scale(a, a, [
                    1,
                    -1,
                    1
                ]), t1.translate(a, a, [
                    0,
                    0,
                    -this.cameraToCenterDistance
                ]), t1.rotateX(a, a, this._pitch), t1.rotateZ(a, a, this.angle), t1.translate(a, a, [
                    -i,
                    -o,
                    0
                ]), this.mercatorMatrix = t1.scale([], a, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize
                ]), t1.scale(a, a, [
                    1,
                    1,
                    this._pixelPerMeter
                ]), this.pixelMatrix = t1.multiply(new Float64Array(16), this.labelPlaneMatrix, a), t1.translate(a, a, [
                    0,
                    0,
                    -this.elevation
                ]), this.projMatrix = a, this.invProjMatrix = t1.invert([], a), this.pixelMatrix3D = t1.multiply(new Float64Array(16), this.labelPlaneMatrix, a);
                const p = this.width % 2 / 2, f = this.height % 2 / 2, g = Math.cos(this.angle), x = Math.sin(this.angle), v = i - Math.round(i) + g * p + x * f, y = o - Math.round(o) + g * f + x * p, b = new Float64Array(a);
                if (t1.translate(b, b, [
                    v > .5 ? v - 1 : v,
                    y > .5 ? y - 1 : y,
                    0
                ]), this.alignedProjMatrix = b, a = t1.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix");
                this.pixelMatrixInverse = a, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            maxPitchScaleFactor() {
                if (!this.pixelMatrixInverse) return 1;
                const e1 = this.pointCoordinate(new t1.pointGeometry(0, 0)), i = [
                    e1.x * this.worldSize,
                    e1.y * this.worldSize,
                    0,
                    1
                ];
                return t1.transformMat4(i, i, this.pixelMatrix)[3] / this.cameraToCenterDistance;
            }
            getCameraPoint() {
                const e1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                return this.centerPoint.add(new t1.pointGeometry(0, e1));
            }
            getCameraQueryGeometry(e1) {
                const i = this.getCameraPoint();
                if (1 === e1.length) return [
                    e1[0],
                    i
                ];
                {
                    let o = i.x, a = i.y, r = i.x, s = i.y;
                    for (const t1 of e1)o = Math.min(o, t1.x), a = Math.min(a, t1.y), r = Math.max(r, t1.x), s = Math.max(s, t1.y);
                    return [
                        new t1.pointGeometry(o, a),
                        new t1.pointGeometry(r, a),
                        new t1.pointGeometry(r, s),
                        new t1.pointGeometry(o, s),
                        new t1.pointGeometry(o, a)
                    ];
                }
            }
        }
        class oo {
            constructor(e1){
                this._hashName = e1 && encodeURIComponent(e1), t1.bindAll([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = function(t1, e1) {
                    let i = !1, o = null;
                    const a = ()=>{
                        o = null, i && (t1(), o = setTimeout(a, 300), i = !1);
                    };
                    return ()=>(i = !0, o || a(), o);
                }(this._updateHashUnthrottled.bind(this));
            }
            addTo(t1) {
                return this._map = t1, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
                return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
            }
            getHashString(t1) {
                const e1 = this._map.getCenter(), i = Math.round(100 * this._map.getZoom()) / 100, o = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), a = Math.pow(10, o), r = Math.round(e1.lng * a) / a, s = Math.round(e1.lat * a) / a, n = this._map.getBearing(), l = this._map.getPitch();
                let c = "";
                if (c += t1 ? `/${r}/${s}/${i}` : `${i}/${s}/${r}`, (n || l) && (c += "/" + Math.round(10 * n) / 10), l && (c += `/${Math.round(l)}`), this._hashName) {
                    const t1 = this._hashName;
                    let e1 = !1;
                    const i = window.location.hash.slice(1).split("&").map((i)=>{
                        const o = i.split("=")[0];
                        return o === t1 ? (e1 = !0, `${o}=${c}`) : i;
                    }).filter((t1)=>t1);
                    return e1 || i.push(`${t1}=${c}`), `#${i.join("&")}`;
                }
                return `#${c}`;
            }
            _getCurrentHash() {
                const t1 = window.location.hash.replace("#", "");
                if (this._hashName) {
                    let e1;
                    return t1.split("&").map((t1)=>t1.split("=")).forEach((t1)=>{
                        t1[0] === this._hashName && (e1 = t1);
                    }), (e1 && e1[1] || "").split("/");
                }
                return t1.split("/");
            }
            _onHashChange() {
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((t1)=>isNaN(t1))) {
                    const e1 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : this._map.getBearing();
                    return this._map.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: e1,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                const t1 = window.location.href.replace(/(#.+)?$/, this.getHashString());
                try {
                    window.history.replaceState(window.history.state, null, t1);
                } catch (t1) {}
            }
        }
        const ao = {
            linearity: .3,
            easing: t1.bezier(0, 0, .3, 1)
        }, ro = t1.extend({
            deceleration: 2500,
            maxSpeed: 1400
        }, ao), so = t1.extend({
            deceleration: 20,
            maxSpeed: 1400
        }, ao), no = t1.extend({
            deceleration: 1e3,
            maxSpeed: 360
        }, ao), lo = t1.extend({
            deceleration: 1e3,
            maxSpeed: 90
        }, ao);
        class co {
            constructor(t1){
                this._map = t1, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(e1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: t1.exported.now(),
                    settings: e1
                });
            }
            _drainInertiaBuffer() {
                const e1 = this._inertiaBuffer, i = t1.exported.now();
                for(; e1.length > 0 && i - e1[0].time > 160;)e1.shift();
            }
            _onMoveEnd(e1) {
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new t1.pointGeometry(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: t1 } of this._inertiaBuffer)i.zoom += t1.zoomDelta || 0, i.bearing += t1.bearingDelta || 0, i.pitch += t1.pitchDelta || 0, t1.panDelta && i.pan._add(t1.panDelta), t1.around && (i.around = t1.around), t1.pinchAround && (i.pinchAround = t1.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a = {};
                if (i.pan.mag()) {
                    const r = uo(i.pan.mag(), o, t1.extend({}, ro, e1 || {}));
                    a.offset = i.pan.mult(r.amount / i.pan.mag()), a.center = this._map.transform.center, ho(a, r);
                }
                if (i.zoom) {
                    const t1 = uo(i.zoom, o, so);
                    a.zoom = this._map.transform.zoom + t1.amount, ho(a, t1);
                }
                if (i.bearing) {
                    const e1 = uo(i.bearing, o, no);
                    a.bearing = this._map.transform.bearing + t1.clamp(e1.amount, -179, 179), ho(a, e1);
                }
                if (i.pitch) {
                    const t1 = uo(i.pitch, o, lo);
                    a.pitch = this._map.transform.pitch + t1.amount, ho(a, t1);
                }
                if (a.zoom || a.bearing) {
                    const t1 = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    a.around = t1 ? this._map.unproject(t1) : this._map.getCenter();
                }
                return this.clear(), t1.extend(a, {
                    noMoveStart: !0
                });
            }
        }
        function ho(t1, e1) {
            (!t1.duration || t1.duration < e1.duration) && (t1.duration = e1.duration, t1.easing = e1.easing);
        }
        function uo(e1, i, o) {
            const { maxSpeed: a, linearity: r, deceleration: s } = o, n = t1.clamp(e1 * r / (i / 1e3), -a, a), l = Math.abs(n) / (s * r);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: n * (l / 2)
            };
        }
        class mo extends t1.Event {
            constructor(e1, i, o, a = {}){
                const s = r.mousePos(i.getCanvasContainer(), o), n = i.unproject(s);
                super(e1, t1.extend({
                    point: s,
                    lngLat: n,
                    originalEvent: o
                }, a)), this._defaultPrevented = !1, this.target = i;
            }
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
        }
        class _o extends t1.Event {
            constructor(e1, i, o){
                const a = "touchend" === e1 ? o.changedTouches : o.touches, s = r.touchPos(i.getCanvasContainer(), a), n = s.map((t1)=>i.unproject(t1)), l = s.reduce((t1, e1, i, o)=>t1.add(e1.div(o.length)), new t1.pointGeometry(0, 0));
                super(e1, {
                    points: s,
                    point: l,
                    lngLats: n,
                    lngLat: i.unproject(l),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
        }
        class po extends t1.Event {
            constructor(t1, e1, i){
                super(t1, {
                    originalEvent: i
                }), this._defaultPrevented = !1;
            }
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
        }
        class fo {
            constructor(t1, e1){
                this._map = t1, this._clickTolerance = e1.clickTolerance;
            }
            reset() {
                delete this._mousedownPos;
            }
            wheel(t1) {
                return this._firePreventable(new po(t1.type, this._map, t1));
            }
            mousedown(t1, e1) {
                return this._mousedownPos = e1, this._firePreventable(new mo(t1.type, this._map, t1));
            }
            mouseup(t1) {
                this._map.fire(new mo(t1.type, this._map, t1));
            }
            click(t1, e1) {
                this._mousedownPos && this._mousedownPos.dist(e1) >= this._clickTolerance || this._map.fire(new mo(t1.type, this._map, t1));
            }
            dblclick(t1) {
                return this._firePreventable(new mo(t1.type, this._map, t1));
            }
            mouseover(t1) {
                this._map.fire(new mo(t1.type, this._map, t1));
            }
            mouseout(t1) {
                this._map.fire(new mo(t1.type, this._map, t1));
            }
            touchstart(t1) {
                return this._firePreventable(new _o(t1.type, this._map, t1));
            }
            touchmove(t1) {
                this._map.fire(new _o(t1.type, this._map, t1));
            }
            touchend(t1) {
                this._map.fire(new _o(t1.type, this._map, t1));
            }
            touchcancel(t1) {
                this._map.fire(new _o(t1.type, this._map, t1));
            }
            _firePreventable(t1) {
                if (this._map.fire(t1), t1.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class go {
            constructor(t1){
                this._map = t1;
            }
            reset() {
                this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
            }
            mousemove(t1) {
                this._map.fire(new mo(t1.type, this._map, t1));
            }
            mousedown() {
                this._delayContextMenu = !0, this._ignoreContextMenu = !1;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new mo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(t1) {
                this._delayContextMenu ? this._contextMenuEvent = t1 : this._ignoreContextMenu || this._map.fire(new mo(t1.type, this._map, t1)), this._map.listens("contextmenu") && t1.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class xo {
            constructor(t1, e1){
                this._map = t1, this._el = t1.getCanvasContainer(), this._container = t1.getContainer(), this._clickTolerance = e1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(t1, e1) {
                this.isEnabled() && t1.shiftKey && 0 === t1.button && (r.disableDrag(), this._startPos = this._lastPos = e1, this._active = !0);
            }
            mousemoveWindow(t1, e1) {
                if (!this._active) return;
                const i = e1;
                if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;
                const o = this._startPos;
                this._lastPos = i, this._box || (this._box = r.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t1));
                const a = Math.min(o.x, i.x), s = Math.max(o.x, i.x), n = Math.min(o.y, i.y), l = Math.max(o.y, i.y);
                r.setTransform(this._box, `translate(${a}px,${n}px)`), this._box.style.width = s - a + "px", this._box.style.height = l - n + "px";
            }
            mouseupWindow(e1, i) {
                if (!this._active) return;
                if (0 !== e1.button) return;
                const o = this._startPos, a = i;
                if (this.reset(), r.suppressClick(), o.x !== a.x || o.y !== a.y) return this._map.fire(new t1.Event("boxzoomend", {
                    originalEvent: e1
                })), {
                    cameraAnimation: (t1)=>t1.fitScreenCoordinates(o, a, this._map.getBearing(), {
                            linear: !0
                        })
                };
                this._fireEvent("boxzoomcancel", e1);
            }
            keydown(t1) {
                this._active && 27 === t1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t1));
            }
            reset() {
                this._active = !1, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e1, i) {
                return this._map.fire(new t1.Event(e1, {
                    originalEvent: i
                }));
            }
        }
        function vo(t1, e1) {
            if (t1.length !== e1.length) throw new Error(`The number of touches and points are not equal - touches ${t1.length}, points ${e1.length}`);
            const i = {};
            for(let o = 0; o < t1.length; o++)i[t1[o].identifier] = e1[o];
            return i;
        }
        class yo {
            constructor(t1){
                this.reset(), this.numTouches = t1.numTouches;
            }
            reset() {
                delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
            }
            touchstart(e1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e1.timeStamp), o.length === this.numTouches && (this.centroid = function(e1) {
                    const i = new t1.pointGeometry(0, 0);
                    for (const t1 of e1)i._add(t1);
                    return i.div(e1.length);
                }(i), this.touches = vo(o, i)));
            }
            touchmove(t1, e1, i) {
                if (this.aborted || !this.centroid) return;
                const o = vo(i, e1);
                for(const t1 in this.touches){
                    const e1 = this.touches[t1], i = o[t1];
                    (!i || i.dist(e1) > 30) && (this.aborted = !0);
                }
            }
            touchend(t1, e1, i) {
                if ((!this.centroid || t1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const t1 = !this.aborted && this.centroid;
                    if (this.reset(), t1) return t1;
                }
            }
        }
        class bo {
            constructor(t1){
                this.singleTap = new yo(t1), this.numTaps = t1.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(t1, e1, i) {
                this.singleTap.touchstart(t1, e1, i);
            }
            touchmove(t1, e1, i) {
                this.singleTap.touchmove(t1, e1, i);
            }
            touchend(t1, e1, i) {
                const o = this.singleTap.touchend(t1, e1, i);
                if (o) {
                    const e1 = t1.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (e1 && i || this.reset(), this.count++, this.lastTime = t1.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class wo {
            constructor(){
                this._zoomIn = new bo({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new bo({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(t1, e1, i) {
                this._zoomIn.touchstart(t1, e1, i), this._zoomOut.touchstart(t1, e1, i);
            }
            touchmove(t1, e1, i) {
                this._zoomIn.touchmove(t1, e1, i), this._zoomOut.touchmove(t1, e1, i);
            }
            touchend(t1, e1, i) {
                const o = this._zoomIn.touchend(t1, e1, i), a = this._zoomOut.touchend(t1, e1, i);
                return o ? (this._active = !0, t1.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (e1)=>e1.easeTo({
                            duration: 300,
                            zoom: e1.getZoom() + 1,
                            around: e1.unproject(o)
                        }, {
                            originalEvent: t1
                        })
                }) : a ? (this._active = !0, t1.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (e1)=>e1.easeTo({
                            duration: 300,
                            zoom: e1.getZoom() - 1,
                            around: e1.unproject(a)
                        }, {
                            originalEvent: t1
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const To = {
            0: 1,
            2: 2
        };
        class Eo {
            constructor(t1){
                this.reset(), this._clickTolerance = t1.clickTolerance || 1;
            }
            reset() {
                this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
            }
            _correctButton(t1, e1) {
                return !1;
            }
            _move(t1, e1) {
                return {};
            }
            mousedown(t1, e1) {
                if (this._lastPoint) return;
                const i = r.mouseButton(t1);
                this._correctButton(t1, i) && (this._lastPoint = e1, this._eventButton = i);
            }
            mousemoveWindow(t1, e1) {
                const i = this._lastPoint;
                if (i) {
                    if (t1.preventDefault(), function(t1, e1) {
                        const i = To[e1];
                        return void 0 === t1.buttons || (t1.buttons & i) !== i;
                    }(t1, this._eventButton)) this.reset();
                    else if (this._moved || !(e1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e1, this._move(i, e1);
                }
            }
            mouseupWindow(t1) {
                this._lastPoint && r.mouseButton(t1) === this._eventButton && (this._moved && r.suppressClick(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Io extends Eo {
            mousedown(t1, e1) {
                super.mousedown(t1, e1), this._lastPoint && (this._active = !0);
            }
            _correctButton(t1, e1) {
                return 0 === e1 && !t1.ctrlKey;
            }
            _move(t1, e1) {
                return {
                    around: e1,
                    panDelta: e1.sub(t1)
                };
            }
        }
        class Co extends Eo {
            _correctButton(t1, e1) {
                return 0 === e1 && t1.ctrlKey || 2 === e1;
            }
            _move(t1, e1) {
                const i = .8 * (e1.x - t1.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(t1) {
                t1.preventDefault();
            }
        }
        class So extends Eo {
            _correctButton(t1, e1) {
                return 0 === e1 && t1.ctrlKey || 2 === e1;
            }
            _move(t1, e1) {
                const i = -0.5 * (e1.y - t1.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(t1) {
                t1.preventDefault();
            }
        }
        class Do {
            constructor(t1, e1){
                this._minTouches = t1.cooperativeGestures ? 2 : 1, this._clickTolerance = t1.clickTolerance || 1, this._map = e1, this.reset();
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new t1.pointGeometry(0, 0), setTimeout(()=>{
                    this._cancelCooperativeMessage = !1;
                }, 200);
            }
            touchstart(t1, e1, i) {
                return this._calculateTransform(t1, e1, i);
            }
            touchmove(t1, e1, i) {
                if (this._map._cooperativeGestures && (2 === this._minTouches && i.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t1, !1, i.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = !0)), this._active && !(i.length < this._minTouches)) return t1.preventDefault(), this._calculateTransform(t1, e1, i);
            }
            touchend(t1, e1, i) {
                this._calculateTransform(t1, e1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(e1, i, o) {
                o.length > 0 && (this._active = !0);
                const a = vo(o, i), r = new t1.pointGeometry(0, 0), s = new t1.pointGeometry(0, 0);
                let n = 0;
                for(const t1 in a){
                    const e1 = a[t1], i = this._touches[t1];
                    i && (r._add(e1), s._add(e1.sub(i)), n++, a[t1] = e1);
                }
                if (this._touches = a, n < this._minTouches || !s.mag()) return;
                const l = s.div(n);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: r.div(n),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class zo {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, delete this._firstTwoTouches;
            }
            _start(t1) {}
            _move(t1, e1, i) {
                return {};
            }
            touchstart(t1, e1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    e1[0],
                    e1[1]
                ]));
            }
            touchmove(t1, e1, i) {
                if (!this._firstTwoTouches) return;
                t1.preventDefault();
                const [o, a] = this._firstTwoTouches, r = Po(i, e1, o), s = Po(i, e1, a);
                if (!r || !s) return;
                const n = this._aroundCenter ? null : r.add(s).div(2);
                return this._move([
                    r,
                    s
                ], n, t1);
            }
            touchend(t1, e1, i) {
                if (!this._firstTwoTouches) return;
                const [o, a] = this._firstTwoTouches, s = Po(i, e1, o), n = Po(i, e1, a);
                s && n || (this._active && r.suppressClick(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(t1) {
                this._enabled = !0, this._aroundCenter = !!t1 && "center" === t1.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function Po(t1, e1, i) {
            for(let o = 0; o < t1.length; o++)if (t1[o].identifier === i) return e1[o];
        }
        function Mo(t1, e1) {
            return Math.log(t1 / e1) / Math.LN2;
        }
        class Ao extends zo {
            reset() {
                super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(t1) {
                this._startDistance = this._distance = t1[0].dist(t1[1]);
            }
            _move(t1, e1) {
                const i = this._distance;
                if (this._distance = t1[0].dist(t1[1]), this._active || !(Math.abs(Mo(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: Mo(this._distance, i),
                    pinchAround: e1
                };
            }
        }
        function Lo(t1, e1) {
            return 180 * t1.angleWith(e1) / Math.PI;
        }
        class Ro extends zo {
            reset() {
                super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(t1) {
                this._startVector = this._vector = t1[0].sub(t1[1]), this._minDiameter = t1[0].dist(t1[1]);
            }
            _move(t1, e1) {
                const i = this._vector;
                if (this._vector = t1[0].sub(t1[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
                    bearingDelta: Lo(this._vector, i),
                    pinchAround: e1
                };
            }
            _isBelowThreshold(t1) {
                this._minDiameter = Math.min(this._minDiameter, t1.mag());
                const e1 = 25 / (Math.PI * this._minDiameter) * 360, i = Lo(t1, this._startVector);
                return Math.abs(i) < e1;
            }
        }
        function ko(t1) {
            return Math.abs(t1.y) > Math.abs(t1.x);
        }
        class Bo extends zo {
            constructor(t1){
                super(), this._map = t1;
            }
            reset() {
                super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            touchstart(t1, e1, i) {
                super.touchstart(t1, e1, i), this._currentTouchCount = i.length;
            }
            _start(t1) {
                this._lastPoints = t1, ko(t1[0].sub(t1[1])) && (this._valid = !1);
            }
            _move(t1, e1, i) {
                if (this._map._cooperativeGestures && this._currentTouchCount < 3) return;
                const o = t1[0].sub(this._lastPoints[0]), a = t1[1].sub(this._lastPoints[1]);
                return this._valid = this.gestureBeginsVertically(o, a, i.timeStamp), this._valid ? (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (o.y + a.y) / 2 * -0.5
                }) : void 0;
            }
            gestureBeginsVertically(t1, e1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = t1.mag() >= 2, a = e1.mag() >= 2;
                if (!o && !a) return;
                if (!o || !a) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const r = t1.y > 0 == e1.y > 0;
                return ko(t1) && ko(e1) && r;
            }
        }
        const Fo = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class Oo {
            constructor(){
                const t1 = Fo;
                this._panStep = t1.panStep, this._bearingStep = t1.bearingStep, this._pitchStep = t1.pitchStep, this._rotationDisabled = !1;
            }
            reset() {
                this._active = !1;
            }
            keydown(t1) {
                if (t1.altKey || t1.ctrlKey || t1.metaKey) return;
                let e1 = 0, i = 0, o = 0, a = 0, r = 0;
                switch(t1.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        e1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        e1 = -1;
                        break;
                    case 37:
                        t1.shiftKey ? i = -1 : (t1.preventDefault(), a = -1);
                        break;
                    case 39:
                        t1.shiftKey ? i = 1 : (t1.preventDefault(), a = 1);
                        break;
                    case 38:
                        t1.shiftKey ? o = 1 : (t1.preventDefault(), r = -1);
                        break;
                    case 40:
                        t1.shiftKey ? o = -1 : (t1.preventDefault(), r = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (s)=>{
                        const n = s.getZoom();
                        s.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: Uo,
                            zoom: e1 ? Math.round(n) + e1 * (t1.shiftKey ? 2 : 1) : n,
                            bearing: s.getBearing() + i * this._bearingStep,
                            pitch: s.getPitch() + o * this._pitchStep,
                            offset: [
                                -a * this._panStep,
                                -r * this._panStep
                            ],
                            center: s.getCenter()
                        }, {
                            originalEvent: t1
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function Uo(t1) {
            return t1 * (2 - t1);
        }
        const No = 4.000244140625;
        class Go {
            constructor(e1, i){
                this._map = e1, this._el = e1.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, t1.bindAll([
                    "_onTimeout"
                ], this);
            }
            setZoomRate(t1) {
                this._defaultZoomRate = t1;
            }
            setWheelZoomRate(t1) {
                this._wheelZoomRate = t1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(t1) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = t1 && "center" === t1.around);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            wheel(e1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!this._map._metaPress) return;
                    e1.preventDefault();
                }
                let i = e1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e1.deltaY : e1.deltaY;
                const o = t1.exported.now(), a = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % No == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : a > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e1)) : this._type || (this._type = Math.abs(a * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e1, this._delta -= i, this._active || this._start(e1)), e1.preventDefault();
            }
            _onTimeout(t1) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t1);
            }
            _start(e1) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const i = r.mousePos(this._el, e1);
                this._around = t1.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(i)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const e1 = this._map.transform;
                if (0 !== this._delta) {
                    const t1 = "wheel" === this._type && Math.abs(this._delta) > No ? this._wheelZoomRate : this._defaultZoomRate;
                    let i = 2 / (1 + Math.exp(-Math.abs(this._delta * t1)));
                    this._delta < 0 && 0 !== i && (i = 1 / i);
                    const o = "number" == typeof this._targetZoom ? e1.zoomScale(this._targetZoom) : e1.scale;
                    this._targetZoom = Math.min(e1.maxZoom, Math.max(e1.minZoom, e1.scaleZoom(o * i))), "wheel" === this._type && (this._startZoom = e1.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
                }
                const i = "number" == typeof this._targetZoom ? this._targetZoom : e1.zoom, o = this._startZoom, a = this._easing;
                let r, s = !1;
                if ("wheel" === this._type && o && a) {
                    const e1 = Math.min((t1.exported.now() - this._lastWheelEventTime) / 200, 1), n = a(e1);
                    r = t1.number(o, i, n), e1 < 1 ? this._frameId || (this._frameId = !0) : s = !0;
                } else r = i, s = !0;
                return this._active = !0, s && (this._active = !1, this._finishTimeout = setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200)), {
                    noInertia: !0,
                    needsRenderFrame: !s,
                    zoomDelta: r - e1.zoom,
                    around: this._aroundPoint,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(e1) {
                let i = t1.ease;
                if (this._prevEase) {
                    const e1 = this._prevEase, o = (t1.exported.now() - e1.start) / e1.duration, a = e1.easing(o + .01) - e1.easing(o), r = .27 / Math.sqrt(a * a + 1e-4) * .01, s = Math.sqrt(.0729 - r * r);
                    i = t1.bezier(r, s, .25, 1);
                }
                return this._prevEase = {
                    start: t1.exported.now(),
                    duration: e1,
                    easing: i
                }, i;
            }
            reset() {
                this._active = !1;
            }
        }
        class Zo {
            constructor(t1, e1){
                this._clickZoom = t1, this._tapZoom = e1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class Vo {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            dblclick(t1, e1) {
                return t1.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (t1.shiftKey ? -1 : 1),
                            around: i.unproject(e1)
                        }, {
                            originalEvent: t1
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class qo {
            constructor(){
                this._tap = new bo({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
            }
            touchstart(t1, e1, i) {
                this._swipePoint || (this._tapTime && t1.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = e1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(t1, e1, i));
            }
            touchmove(t1, e1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = e1[0], a = o.y - this._swipePoint.y;
                        return this._swipePoint = o, t1.preventDefault(), this._active = !0, {
                            zoomDelta: a / 128
                        };
                    }
                } else this._tap.touchmove(t1, e1, i);
            }
            touchend(t1, e1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t1, e1, i) && (this._tapTime = t1.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class jo {
            constructor(t1, e1, i){
                this._el = t1, this._mousePan = e1, this._touchPan = i;
            }
            enable(t1) {
                this._inertiaOptions = t1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class $o {
            constructor(t1, e1, i){
                this._pitchWithRotate = t1.pitchWithRotate, this._mouseRotate = e1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class Xo {
            constructor(t1, e1, i, o){
                this._el = t1, this._touchZoom = e1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(t1) {
                this._touchZoom.enable(t1), this._rotationDisabled || this._touchRotate.enable(t1), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const Wo = (t1)=>t1.zoom || t1.drag || t1.pitch || t1.rotate;
        class Ho extends t1.Event {
        }
        function Ko(t1) {
            return t1.panDelta && t1.panDelta.mag() || t1.zoomDelta || t1.bearingDelta || t1.pitchDelta;
        }
        class Yo {
            constructor(e1, i){
                this._map = e1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new co(e1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i), t1.bindAll([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [t1, e1, i] of this._listeners)r.addEventListener(t1, e1, t1 === document ? this.handleWindowEvent : this.handleEvent, i);
            }
            destroy() {
                for (const [t1, e1, i] of this._listeners)r.removeEventListener(t1, e1, t1 === document ? this.handleWindowEvent : this.handleEvent, i);
            }
            _addDefaultHandlers(t1) {
                const e1 = this._map, i = e1.getCanvasContainer();
                this._add("mapEvent", new fo(e1, t1));
                const o = e1.boxZoom = new xo(e1, t1);
                this._add("boxZoom", o);
                const a = new wo, r = new Vo;
                e1.doubleClickZoom = new Zo(r, a), this._add("tapZoom", a), this._add("clickZoom", r);
                const s = new qo;
                this._add("tapDragZoom", s);
                const n = e1.touchPitch = new Bo(e1);
                this._add("touchPitch", n);
                const l = new Co(t1), c = new So(t1);
                e1.dragRotate = new $o(t1, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new Io(t1), u = new Do(t1, e1);
                e1.dragPan = new jo(i, h, u), this._add("mousePan", h), this._add("touchPan", u, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const d = new Ro, m = new Ao;
                e1.touchZoomRotate = new Xo(i, m, d, s), this._add("touchRotate", d, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", m, [
                    "touchPan",
                    "touchRotate"
                ]);
                const _ = e1.scrollZoom = new Go(e1, this);
                this._add("scrollZoom", _, [
                    "mousePan"
                ]);
                const p = e1.keyboard = new Oo;
                this._add("keyboard", p), this._add("blockableMapEvent", new go(e1));
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])t1.interactive && t1[i] && e1[i].enable(t1[i]);
            }
            _add(t1, e1, i) {
                this._handlers.push({
                    handlerName: t1,
                    handler: e1,
                    allowed: i
                }), this._handlersById[t1] = e1;
            }
            stop(t1) {
                if (!this._updatingCamera) {
                    for (const { handler: t1 } of this._handlers)t1.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, t1), this._changes = [];
                }
            }
            isActive() {
                for (const { handler: t1 } of this._handlers)if (t1.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return Boolean(Wo(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(t1, e1, i) {
                for(const o in t1)if (o !== i && (!e1 || e1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(t1) {
                this.handleEvent(t1, `${t1.type}Window`);
            }
            _getMapTouches(t1) {
                const e1 = [];
                for (const i of t1)this._el.contains(i.target) && e1.push(i);
                return e1;
            }
            handleEvent(t1, e1) {
                if ("blur" === t1.type) return void this.stop(!0);
                this._updatingCamera = !0;
                const i = "renderFrame" === t1.type ? void 0 : t1, o = {
                    needsRenderFrame: !1
                }, a = {}, s = {}, n = t1.touches, l = n ? this._getMapTouches(n) : void 0, c = l ? r.touchPos(this._el, l) : r.mousePos(this._el, t1);
                for (const { handlerName: r, handler: n, allowed: h } of this._handlers){
                    if (!n.isEnabled()) continue;
                    let u;
                    this._blockedByActive(s, h, r) ? n.reset() : n[e1 || t1.type] && (u = n[e1 || t1.type](t1, c, l), this.mergeHandlerResult(o, a, u, r, i), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || n.isActive()) && (s[r] = n);
                }
                const h = {};
                for(const t1 in this._previousActiveHandlers)s[t1] || (h[t1] = i);
                this._previousActiveHandlers = s, (Object.keys(h).length || Ko(o)) && (this._changes.push([
                    o,
                    a,
                    h
                ]), this._triggerRenderFrame()), (Object.keys(s).length || Ko(o)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: u } = o;
                u && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], u(this._map));
            }
            mergeHandlerResult(e1, i, o, a, r) {
                if (!o) return;
                t1.extend(e1, o);
                const s = {
                    handlerName: a,
                    originalEvent: o.originalEvent || r
                };
                void 0 !== o.zoomDelta && (i.zoom = s), void 0 !== o.panDelta && (i.drag = s), void 0 !== o.pitchDelta && (i.pitch = s), void 0 !== o.bearingDelta && (i.rotate = s);
            }
            _applyChanges() {
                const e1 = {}, i = {}, o = {};
                for (const [a, r, s] of this._changes)a.panDelta && (e1.panDelta = (e1.panDelta || new t1.pointGeometry(0, 0))._add(a.panDelta)), a.zoomDelta && (e1.zoomDelta = (e1.zoomDelta || 0) + a.zoomDelta), a.bearingDelta && (e1.bearingDelta = (e1.bearingDelta || 0) + a.bearingDelta), a.pitchDelta && (e1.pitchDelta = (e1.pitchDelta || 0) + a.pitchDelta), void 0 !== a.around && (e1.around = a.around), void 0 !== a.pinchAround && (e1.pinchAround = a.pinchAround), a.noInertia && (e1.noInertia = a.noInertia), t1.extend(i, r), t1.extend(o, s);
                this._updateMapTransform(e1, i, o), this._changes = [];
            }
            _updateMapTransform(e1, i, o) {
                const a = this._map, r = a.transform, s = a.style && a.style.terrain;
                if (!(Ko(e1) || s && this._drag)) return this._fireEvents(i, o, !0);
                let { panDelta: n, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: u, pinchAround: d } = e1;
                void 0 !== d && (u = d), a._stop(!0), u = u || a.transform.centerPoint;
                const m = r.pointLocation(n ? u.sub(n) : u);
                c && (r.bearing += c), h && (r.pitch += h), l && (r.zoom += l), s ? i.drag && !this._drag ? (this._drag = {
                    center: r.centerPoint,
                    lngLat: r.pointLocation(u),
                    point: u,
                    handlerName: i.drag.handlerName
                }, a.fire(new t1.Event("freezeElevation", {
                    freeze: !0
                }))) : this._drag && o[this._drag.handlerName] ? (a.fire(new t1.Event("freezeElevation", {
                    freeze: !1
                })), this._drag = null) : i.drag && this._drag && (r.center = r.pointLocation(r.centerPoint.sub(n))) : r.setLocationAtPoint(m, u), this._map._update(), e1.noInertia || this._inertia.record(e1), this._fireEvents(i, o, !0);
            }
            _fireEvents(e1, i, o) {
                const a = Wo(this._eventsInProgress), r = Wo(e1), s = {};
                for(const t1 in e1){
                    const { originalEvent: i } = e1[t1];
                    this._eventsInProgress[t1] || (s[`${t1}start`] = i), this._eventsInProgress[t1] = e1[t1];
                }
                !a && r && this._fireEvent("movestart", r.originalEvent);
                for(const t1 in s)this._fireEvent(t1, s[t1]);
                r && this._fireEvent("move", r.originalEvent);
                for(const t1 in e1){
                    const { originalEvent: i } = e1[t1];
                    this._fireEvent(t1, i);
                }
                const n = {};
                let l;
                for(const t1 in this._eventsInProgress){
                    const { handlerName: e1, originalEvent: o } = this._eventsInProgress[t1];
                    this._handlersById[e1].isActive() || (delete this._eventsInProgress[t1], l = i[e1] || o, n[`${t1}end`] = l);
                }
                for(const t1 in n)this._fireEvent(t1, n[t1]);
                const c = Wo(this._eventsInProgress);
                if (o && (a || r) && !c) {
                    this._updatingCamera = !0;
                    const e1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (t1)=>0 !== t1 && -this._bearingSnap < t1 && t1 < this._bearingSnap;
                    e1 ? (i(e1.bearing || this._map.getBearing()) && (e1.bearing = 0), this._map.easeTo(e1, {
                        originalEvent: l
                    })) : (this._map.fire(new t1.Event("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(e1, i) {
                this._map.fire(new t1.Event(e1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t1)=>{
                    delete this._frameId, this.handleEvent(new Ho("renderFrame", {
                        timeStamp: t1
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const Jo = {
            extend: (e1, ...i)=>t1.extend(e1, ...i),
            run (t1) {
                t1();
            },
            logToElement (t1, e1 = !1, i = "log") {
                const o = window.document.getElementById(i);
                o && (e1 && (o.innerHTML = ""), o.innerHTML += `<br>${t1}`);
            }
        };
        class Qo extends t1.Evented {
            constructor(e1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = e1, this._bearingSnap = i.bearingSnap, t1.bindAll([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new t1.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(t1, e1) {
                return this.jumpTo({
                    center: t1
                }, e1);
            }
            panBy(e1, i, o) {
                return e1 = t1.pointGeometry.convert(e1).mult(-1), this.panTo(this.transform.center, t1.extend({
                    offset: e1
                }, i), o);
            }
            panTo(e1, i, o) {
                return this.easeTo(t1.extend({
                    center: e1
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(t1, e1) {
                return this.jumpTo({
                    zoom: t1
                }, e1), this;
            }
            zoomTo(e1, i, o) {
                return this.easeTo(t1.extend({
                    zoom: e1
                }, i), o);
            }
            zoomIn(t1, e1) {
                return this.zoomTo(this.getZoom() + 1, t1, e1), this;
            }
            zoomOut(t1, e1) {
                return this.zoomTo(this.getZoom() - 1, t1, e1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(t1, e1) {
                return this.jumpTo({
                    bearing: t1
                }, e1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(t1, e1) {
                return this.jumpTo({
                    padding: t1
                }, e1), this;
            }
            rotateTo(e1, i, o) {
                return this.easeTo(t1.extend({
                    bearing: e1
                }, i), o);
            }
            resetNorth(e1, i) {
                return this.rotateTo(0, t1.extend({
                    duration: 1e3
                }, e1), i), this;
            }
            resetNorthPitch(e1, i) {
                return this.easeTo(t1.extend({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, e1), i), this;
            }
            snapToNorth(t1, e1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t1, e1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(t1, e1) {
                return this.jumpTo({
                    pitch: t1
                }, e1), this;
            }
            cameraForBounds(e1, i) {
                e1 = t1.LngLatBounds.convert(e1);
                const o = i && i.bearing || 0;
                return this._cameraForBoxAndBearing(e1.getNorthWest(), e1.getSouthEast(), o, i);
            }
            _cameraForBoxAndBearing(e1, i, o, a) {
                const r = {
                    top: 0,
                    bottom: 0,
                    right: 0,
                    left: 0
                };
                if ("number" == typeof (a = t1.extend({
                    padding: r,
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, a)).padding) {
                    const t1 = a.padding;
                    a.padding = {
                        top: t1,
                        bottom: t1,
                        right: t1,
                        left: t1
                    };
                }
                a.padding = t1.extend(r, a.padding);
                const s = this.transform, n = s.padding, l = s.project(t1.LngLat.convert(e1)), c = s.project(t1.LngLat.convert(i)), h = l.rotate(-o * Math.PI / 180), u = c.rotate(-o * Math.PI / 180), d = new t1.pointGeometry(Math.max(h.x, u.x), Math.max(h.y, u.y)), m = new t1.pointGeometry(Math.min(h.x, u.x), Math.min(h.y, u.y)), _ = d.sub(m), p = (s.width - (n.left + n.right + a.padding.left + a.padding.right)) / _.x, f = (s.height - (n.top + n.bottom + a.padding.top + a.padding.bottom)) / _.y;
                if (f < 0 || p < 0) return void t1.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                const g = Math.min(s.scaleZoom(s.scale * Math.min(p, f)), a.maxZoom), x = t1.pointGeometry.convert(a.offset), v = new t1.pointGeometry((a.padding.left - a.padding.right) / 2, (a.padding.top - a.padding.bottom) / 2).rotate(o * Math.PI / 180), y = x.add(v).mult(s.scale / s.zoomScale(g));
                return {
                    center: s.unproject(l.add(c).div(2).sub(y)),
                    zoom: g,
                    bearing: o
                };
            }
            fitBounds(t1, e1, i) {
                return this._fitInternal(this.cameraForBounds(t1, e1), e1, i);
            }
            fitScreenCoordinates(e1, i, o, a, r) {
                return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t1.pointGeometry.convert(e1)), this.transform.pointLocation(t1.pointGeometry.convert(i)), o, a), a, r);
            }
            _fitInternal(e1, i, o) {
                return e1 ? (delete (i = t1.extend(e1, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
            }
            jumpTo(e1, i) {
                this.stop();
                const o = this.transform;
                let a = !1, r = !1, s = !1;
                return "zoom" in e1 && o.zoom !== +e1.zoom && (a = !0, o.zoom = +e1.zoom), void 0 !== e1.center && (o.center = t1.LngLat.convert(e1.center)), "bearing" in e1 && o.bearing !== +e1.bearing && (r = !0, o.bearing = +e1.bearing), "pitch" in e1 && o.pitch !== +e1.pitch && (s = !0, o.pitch = +e1.pitch), null == e1.padding || o.isPaddingEqual(e1.padding) || (o.padding = e1.padding), this.fire(new t1.Event("movestart", i)).fire(new t1.Event("move", i)), a && this.fire(new t1.Event("zoomstart", i)).fire(new t1.Event("zoom", i)).fire(new t1.Event("zoomend", i)), r && this.fire(new t1.Event("rotatestart", i)).fire(new t1.Event("rotate", i)).fire(new t1.Event("rotateend", i)), s && this.fire(new t1.Event("pitchstart", i)).fire(new t1.Event("pitch", i)).fire(new t1.Event("pitchend", i)), this.fire(new t1.Event("moveend", i));
            }
            calculateCameraOptionsFromTo(e1, i, o, a = 0) {
                const r = t1.MercatorCoordinate.fromLngLat(e1, i), s = t1.MercatorCoordinate.fromLngLat(o, a), n = s.x - r.x, l = s.y - r.y, c = s.z - r.z, h = Math.hypot(n, l, c);
                if (0 === h) throw new Error("Can't calculate camera options with same From and To");
                const u = Math.hypot(n, l), d = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h / this.transform.tileSize), m = 180 * Math.atan2(n, -l) / Math.PI;
                let _ = 180 * Math.acos(u / h) / Math.PI;
                return _ = c < 0 ? 90 - _ : 90 + _, {
                    center: s.toLngLat(),
                    zoom: d,
                    pitch: _,
                    bearing: m
                };
            }
            easeTo(e1, i) {
                this._stop(!1, e1.easeId), (!1 === (e1 = t1.extend({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: t1.ease
                }, e1)).animate || !e1.essential && t1.exported.prefersReducedMotion) && (e1.duration = 0);
                const o = this.transform, a = this.getZoom(), r = this.getBearing(), s = this.getPitch(), n = this.getPadding(), l = "zoom" in e1 ? +e1.zoom : a, c = "bearing" in e1 ? this._normalizeBearing(e1.bearing, r) : r, h = "pitch" in e1 ? +e1.pitch : s, u = "padding" in e1 ? e1.padding : o.padding, d = t1.pointGeometry.convert(e1.offset);
                let m = o.centerPoint.add(d);
                const _ = o.pointLocation(m), p = t1.LngLat.convert(e1.center || _);
                this._normalizeCenter(p);
                const f = o.project(_), g = o.project(p).sub(f), x = o.zoomScale(l - a);
                let v, y;
                e1.around && (v = t1.LngLat.convert(e1.around), y = o.locationPoint(v));
                const b = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = this._zooming || l !== a, this._rotating = this._rotating || r !== c, this._pitching = this._pitching || h !== s, this._padding = !o.isPaddingEqual(u), this._easeId = e1.easeId, this._prepareEase(i, e1.noMoveStart, b), this._ease((e1)=>{
                    if (this._zooming && (o.zoom = t1.number(a, l, e1)), this._rotating && (o.bearing = t1.number(r, c, e1)), this._pitching && (o.pitch = t1.number(s, h, e1)), this._padding && (o.interpolatePadding(n, u, e1), m = o.centerPoint.add(d)), v) o.setLocationAtPoint(v, y);
                    else {
                        const t1 = o.zoomScale(o.zoom - a), i = l > a ? Math.min(2, x) : Math.max(.5, x), r = Math.pow(i, 1 - e1), s = o.unproject(f.add(g.mult(e1 * r)).mult(t1));
                        o.setLocationAtPoint(o.renderWorldCopies ? s.wrap() : s, m);
                    }
                    this._fireMoveEvents(i);
                }, (t1)=>{
                    this._afterEase(i, t1);
                }, e1), this;
            }
            _prepareEase(e1, i, o = {}) {
                this._moving = !0, this.fire(new t1.Event("freezeElevation", {
                    freeze: !0
                })), i || o.moving || this.fire(new t1.Event("movestart", e1)), this._zooming && !o.zooming && this.fire(new t1.Event("zoomstart", e1)), this._rotating && !o.rotating && this.fire(new t1.Event("rotatestart", e1)), this._pitching && !o.pitching && this.fire(new t1.Event("pitchstart", e1));
            }
            _fireMoveEvents(e1) {
                this.fire(new t1.Event("move", e1)), this._zooming && this.fire(new t1.Event("zoom", e1)), this._rotating && this.fire(new t1.Event("rotate", e1)), this._pitching && this.fire(new t1.Event("pitch", e1));
            }
            _afterEase(e1, i) {
                if (this._easeId && i && this._easeId === i) return;
                delete this._easeId, this.fire(new t1.Event("freezeElevation", {
                    freeze: !1
                }));
                const o = this._zooming, a = this._rotating, r = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new t1.Event("zoomend", e1)), a && this.fire(new t1.Event("rotateend", e1)), r && this.fire(new t1.Event("pitchend", e1)), this.fire(new t1.Event("moveend", e1));
            }
            flyTo(e1, i) {
                if (!e1.essential && t1.exported.prefersReducedMotion) {
                    const o = t1.pick(e1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), e1 = t1.extend({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: t1.ease
                }, e1);
                const o = this.transform, a = this.getZoom(), r = this.getBearing(), s = this.getPitch(), n = this.getPadding(), l = "zoom" in e1 ? t1.clamp(+e1.zoom, o.minZoom, o.maxZoom) : a, c = "bearing" in e1 ? this._normalizeBearing(e1.bearing, r) : r, h = "pitch" in e1 ? +e1.pitch : s, u = "padding" in e1 ? e1.padding : o.padding, d = o.zoomScale(l - a), m = t1.pointGeometry.convert(e1.offset);
                let _ = o.centerPoint.add(m);
                const p = o.pointLocation(_), f = t1.LngLat.convert(e1.center || p);
                this._normalizeCenter(f);
                const g = o.project(p), x = o.project(f).sub(g);
                let v = e1.curve;
                const y = Math.max(o.width, o.height), b = y / d, w = x.mag();
                if ("minZoom" in e1) {
                    const i = t1.clamp(Math.min(e1.minZoom, a, l), o.minZoom, o.maxZoom), r = y / o.zoomScale(i - a);
                    v = Math.sqrt(r / w * 2);
                }
                const T = v * v;
                function E(t1) {
                    const e1 = (b * b - y * y + (t1 ? -1 : 1) * T * T * w * w) / (2 * (t1 ? b : y) * T * w);
                    return Math.log(Math.sqrt(e1 * e1 + 1) - e1);
                }
                function I(t1) {
                    return (Math.exp(t1) - Math.exp(-t1)) / 2;
                }
                function C(t1) {
                    return (Math.exp(t1) + Math.exp(-t1)) / 2;
                }
                const S = E(0);
                let D = function(t1) {
                    return C(S) / C(S + v * t1);
                }, z = function(t1) {
                    var e1;
                    return y * ((C(S) * (I(e1 = S + v * t1) / C(e1)) - I(S)) / T) / w;
                }, P = (E(1) - S) / v;
                if (Math.abs(w) < 1e-6 || !isFinite(P)) {
                    if (Math.abs(y - b) < 1e-6) return this.easeTo(e1, i);
                    const t1 = b < y ? -1 : 1;
                    P = Math.abs(Math.log(b / y)) / v, z = function() {
                        return 0;
                    }, D = function(e1) {
                        return Math.exp(t1 * v * e1);
                    };
                }
                return e1.duration = "duration" in e1 ? +e1.duration : 1e3 * P / ("screenSpeed" in e1 ? +e1.screenSpeed / v : +e1.speed), e1.maxDuration && e1.duration > e1.maxDuration && (e1.duration = 0), this._zooming = !0, this._rotating = r !== c, this._pitching = h !== s, this._padding = !o.isPaddingEqual(u), this._prepareEase(i, !1), this._ease((e1)=>{
                    const d = e1 * P, p = 1 / D(d);
                    o.zoom = 1 === e1 ? l : a + o.scaleZoom(p), this._rotating && (o.bearing = t1.number(r, c, e1)), this._pitching && (o.pitch = t1.number(s, h, e1)), this._padding && (o.interpolatePadding(n, u, e1), _ = o.centerPoint.add(m));
                    const v = 1 === e1 ? f : o.unproject(g.add(x.mult(z(d))).mult(p));
                    o.setLocationAtPoint(o.renderWorldCopies ? v.wrap() : v, _), this._fireMoveEvents(i);
                }, ()=>this._afterEase(i), e1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _stop(t1, e1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                    const t1 = this._onEaseEnd;
                    delete this._onEaseEnd, t1.call(this, e1);
                }
                if (!t1) {
                    const t1 = this.handlers;
                    t1 && t1.stop(!1);
                }
                return this;
            }
            _ease(e1, i, o) {
                !1 === o.animate || 0 === o.duration ? (e1(1), i()) : (this._easeStart = t1.exported.now(), this._easeOptions = o, this._onEaseFrame = e1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const e1 = Math.min((t1.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
                this._onEaseFrame(this._easeOptions.easing(e1)), e1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(e1, i) {
                e1 = t1.wrap(e1, -180, 180);
                const o = Math.abs(e1 - i);
                return Math.abs(e1 - 360 - i) < o && (e1 -= 360), Math.abs(e1 + 360 - i) < o && (e1 += 360), e1;
            }
            _normalizeCenter(t1) {
                const e1 = this.transform;
                if (!e1.renderWorldCopies || e1.lngRange) return;
                const i = t1.lng - e1.center.lng;
                t1.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
        }
        class ta {
            constructor(e1 = {}){
                this.options = e1, t1.bindAll([
                    "_toggleAttribution",
                    "_updateData",
                    "_updateCompact",
                    "_updateCompactMinimize"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(t1) {
                return this._map = t1, this._compact = this.options && this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
                r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(t1, e1) {
                const i = this._map._getUIString(`AttributionControl.${e1}`);
                t1.title = i, t1.setAttribute("aria-label", i);
            }
            _toggleAttribution() {
                this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._container.removeAttribute("open")));
            }
            _updateData(t1) {
                !t1 || "metadata" !== t1.sourceDataType && "visibility" !== t1.sourceDataType && "style" !== t1.dataType && "terrain" !== t1.type || this._updateAttributions();
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let t1 = [];
                if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t1 = t1.concat(this.options.customAttribution.map((t1)=>"string" != typeof t1 ? "" : t1)) : "string" == typeof this.options.customAttribution && t1.push(this.options.customAttribution)), this._map.style.stylesheet) {
                    const t1 = this._map.style.stylesheet;
                    this.styleOwner = t1.owner, this.styleId = t1.id;
                }
                const e1 = this._map.style.sourceCaches;
                for(const i in e1){
                    const o = e1[i];
                    if (o.used || o.usedForTerrain) {
                        const e1 = o.getSource();
                        e1.attribution && t1.indexOf(e1.attribution) < 0 && t1.push(e1.attribution);
                    }
                }
                t1 = t1.filter((t1)=>String(t1).trim()), t1.sort((t1, e1)=>t1.length - e1.length), t1 = t1.filter((e1, i)=>{
                    for(let o = i + 1; o < t1.length; o++)if (t1[o].indexOf(e1) >= 0) return !1;
                    return !0;
                });
                const i = t1.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, t1.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "mapboxgl-compact", "maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show"));
            }
            _updateCompactMinimize() {
                this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show");
            }
        }
        class ea {
            constructor(e1 = {}){
                this.options = e1, t1.bindAll([
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            onAdd(t1) {
                this._map = t1, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl mapboxgl-ctrl");
                const e1 = r.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");
                return e1.target = "_blank", e1.rel = "noopener nofollow", e1.href = "https://maplibre.org/", e1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e1), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
            _updateCompact() {
                const t1 = this._container.children;
                if (t1.length) {
                    const e1 = t1[0];
                    this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && e1.classList.add("maplibregl-compact", "mapboxgl-compact") : e1.classList.remove("maplibregl-compact", "mapboxgl-compact");
                }
            }
        }
        class ia {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(t1) {
                const e1 = ++this._id;
                return this._queue.push({
                    callback: t1,
                    id: e1,
                    cancelled: !1
                }), e1;
            }
            remove(t1) {
                const e1 = this._currentlyRunning, i = e1 ? this._queue.concat(e1) : this._queue;
                for (const e1 of i)if (e1.id === t1) return void (e1.cancelled = !0);
            }
            run(t1 = 0) {
                if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
                const e1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of e1)if (!i.cancelled && (i.callback(t1), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        const oa = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox logo",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "TerrainControl.enableTerrain": "Enable terrain",
            "TerrainControl.disableTerrain": "Disable terrain"
        }, aa = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: void 0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            maplibreLogo: !1,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            transformRequest: null,
            fadeDuration: 300,
            crossSourceCollisions: !0
        }, ra = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class sa {
            constructor(e1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new Co({
                    clickTolerance: e1.dragRotate._mouseRotate._clickTolerance
                }), this.map = e1, o && (this.mousePitch = new So({
                    clickTolerance: e1.dragRotate._mousePitch._clickTolerance
                })), t1.bindAll([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), r.addEventListener(i, "mousedown", this.mousedown), r.addEventListener(i, "touchstart", this.touchstart, {
                    passive: !1
                }), r.addEventListener(i, "touchmove", this.touchmove), r.addEventListener(i, "touchend", this.touchend), r.addEventListener(i, "touchcancel", this.reset);
            }
            down(t1, e1) {
                this.mouseRotate.mousedown(t1, e1), this.mousePitch && this.mousePitch.mousedown(t1, e1), r.disableDrag();
            }
            move(t1, e1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(t1, e1);
                if (o && o.bearingDelta && i.setBearing(i.getBearing() + o.bearingDelta), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(t1, e1);
                    o && o.pitchDelta && i.setPitch(i.getPitch() + o.pitchDelta);
                }
            }
            off() {
                const t1 = this.element;
                r.removeEventListener(t1, "mousedown", this.mousedown), r.removeEventListener(t1, "touchstart", this.touchstart, {
                    passive: !1
                }), r.removeEventListener(t1, "touchmove", this.touchmove), r.removeEventListener(t1, "touchend", this.touchend), r.removeEventListener(t1, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup);
            }
            mousedown(e1) {
                this.down(t1.extend({}, e1, {
                    ctrlKey: !0,
                    preventDefault: ()=>e1.preventDefault()
                }), r.mousePos(this.element, e1)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
            }
            mousemove(t1) {
                this.move(t1, r.mousePos(this.element, t1));
            }
            mouseup(t1) {
                this.mouseRotate.mouseupWindow(t1), this.mousePitch && this.mousePitch.mouseupWindow(t1), this.offTemp();
            }
            touchstart(t1) {
                1 !== t1.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t1.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>t1.preventDefault()
                }, this._startPos));
            }
            touchmove(t1) {
                1 !== t1.targetTouches.length ? this.reset() : (this._lastPos = r.touchPos(this.element, t1.targetTouches)[0], this.move({
                    preventDefault: ()=>t1.preventDefault()
                }, this._lastPos));
            }
            touchend(t1) {
                0 === t1.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        function na(e1, i, o) {
            if (e1 = new t1.LngLat(e1.lng, e1.lat), i) {
                const a = new t1.LngLat(e1.lng - 360, e1.lat), r = new t1.LngLat(e1.lng + 360, e1.lat), s = o.locationPoint(e1).distSqr(i);
                o.locationPoint(a).distSqr(i) < s ? e1 = a : o.locationPoint(r).distSqr(i) < s && (e1 = r);
            }
            for(; Math.abs(e1.lng - o.center.lng) > 180;){
                const t1 = o.locationPoint(e1);
                if (t1.x >= 0 && t1.y >= 0 && t1.x <= o.width && t1.y <= o.height) break;
                e1.lng > o.center.lng ? e1.lng -= 360 : e1.lng += 360;
            }
            return e1;
        }
        const la = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        function ca(t1, e1, i) {
            const o = t1.classList;
            for(const t1 in la)o.remove(`maplibregl-${i}-anchor-${t1}`, `mapboxgl-${i}-anchor-${t1}`);
            o.add(`maplibregl-${i}-anchor-${e1}`, `mapboxgl-${i}-anchor-${e1}`);
        }
        class ha extends t1.Evented {
            constructor(e1, i){
                if (super(), (e1 instanceof HTMLElement || i) && (e1 = t1.extend({
                    element: e1
                }, i)), t1.bindAll([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress"
                ], this), this._anchor = e1 && e1.anchor || "center", this._color = e1 && e1.color || "#3FB1CE", this._scale = e1 && e1.scale || 1, this._draggable = e1 && e1.draggable || !1, this._clickTolerance = e1 && e1.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = e1 && e1.rotation || 0, this._rotationAlignment = e1 && e1.rotationAlignment || "auto", this._pitchAlignment = e1 && e1.pitchAlignment && "auto" !== e1.pitchAlignment ? e1.pitchAlignment : this._rotationAlignment, e1 && e1.element) this._element = e1.element, this._offset = t1.pointGeometry.convert(e1 && e1.offset || [
                    0,
                    0
                ]);
                else {
                    this._defaultMarker = !0, this._element = r.create("div"), this._element.setAttribute("aria-label", "Map marker");
                    const i = r.createNS("http://www.w3.org/2000/svg", "svg"), o = 41, a = 27;
                    i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${o}px`), i.setAttributeNS(null, "width", `${a}px`), i.setAttributeNS(null, "viewBox", `0 0 ${a} ${o}`);
                    const s = r.createNS("http://www.w3.org/2000/svg", "g");
                    s.setAttributeNS(null, "stroke", "none"), s.setAttributeNS(null, "stroke-width", "1"), s.setAttributeNS(null, "fill", "none"), s.setAttributeNS(null, "fill-rule", "evenodd");
                    const n = r.createNS("http://www.w3.org/2000/svg", "g");
                    n.setAttributeNS(null, "fill-rule", "nonzero");
                    const l = r.createNS("http://www.w3.org/2000/svg", "g");
                    l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000");
                    const c = [
                        {
                            rx: "10.5",
                            ry: "5.25002273"
                        },
                        {
                            rx: "10.5",
                            ry: "5.25002273"
                        },
                        {
                            rx: "9.5",
                            ry: "4.77275007"
                        },
                        {
                            rx: "8.5",
                            ry: "4.29549936"
                        },
                        {
                            rx: "7.5",
                            ry: "3.81822308"
                        },
                        {
                            rx: "6.5",
                            ry: "3.34094679"
                        },
                        {
                            rx: "5.5",
                            ry: "2.86367051"
                        },
                        {
                            rx: "4.5",
                            ry: "2.38636864"
                        }
                    ];
                    for (const t1 of c){
                        const e1 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
                        e1.setAttributeNS(null, "opacity", "0.04"), e1.setAttributeNS(null, "cx", "10.5"), e1.setAttributeNS(null, "cy", "5.80029008"), e1.setAttributeNS(null, "rx", t1.rx), e1.setAttributeNS(null, "ry", t1.ry), l.appendChild(e1);
                    }
                    const h = r.createNS("http://www.w3.org/2000/svg", "g");
                    h.setAttributeNS(null, "fill", this._color);
                    const u = r.createNS("http://www.w3.org/2000/svg", "path");
                    u.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h.appendChild(u);
                    const d = r.createNS("http://www.w3.org/2000/svg", "g");
                    d.setAttributeNS(null, "opacity", "0.25"), d.setAttributeNS(null, "fill", "#000000");
                    const m = r.createNS("http://www.w3.org/2000/svg", "path");
                    m.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d.appendChild(m);
                    const _ = r.createNS("http://www.w3.org/2000/svg", "g");
                    _.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), _.setAttributeNS(null, "fill", "#FFFFFF");
                    const p = r.createNS("http://www.w3.org/2000/svg", "g");
                    p.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                    const f = r.createNS("http://www.w3.org/2000/svg", "circle");
                    f.setAttributeNS(null, "fill", "#000000"), f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "cx", "5.5"), f.setAttributeNS(null, "cy", "5.5"), f.setAttributeNS(null, "r", "5.4999962");
                    const g = r.createNS("http://www.w3.org/2000/svg", "circle");
                    g.setAttributeNS(null, "fill", "#FFFFFF"), g.setAttributeNS(null, "cx", "5.5"), g.setAttributeNS(null, "cy", "5.5"), g.setAttributeNS(null, "r", "5.4999962"), p.appendChild(f), p.appendChild(g), n.appendChild(l), n.appendChild(h), n.appendChild(d), n.appendChild(_), n.appendChild(p), i.appendChild(n), i.setAttributeNS(null, "height", o * this._scale + "px"), i.setAttributeNS(null, "width", a * this._scale + "px"), this._element.appendChild(i), this._offset = t1.pointGeometry.convert(e1 && e1.offset || [
                        0,
                        -14
                    ]);
                }
                this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", (t1)=>{
                    t1.preventDefault();
                }), this._element.addEventListener("mousedown", (t1)=>{
                    t1.preventDefault();
                }), ca(this._element, this._anchor, "marker"), this._popup = null;
            }
            addTo(t1) {
                return this.remove(), this._map = t1, t1.getCanvasContainer().appendChild(this._element), t1.on("move", this._update), t1.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
                return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(e1) {
                return this._lngLat = t1.LngLat.convert(e1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
                return this._element;
            }
            setPopup(t1) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t1) {
                    if (!("offset" in t1.options)) {
                        const e1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        t1.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -e1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (e1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (e1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (e1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (e1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = t1, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
                }
                return this;
            }
            _onKeyPress(t1) {
                const e1 = t1.code, i = t1.charCode || t1.keyCode;
                "Space" !== e1 && "Enter" !== e1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(t1) {
                const e1 = t1.originalEvent.target, i = this._element;
                this._popup && (e1 === i || i.contains(e1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const t1 = this._popup;
                return t1 ? (t1.isOpen() ? t1.remove() : t1.addTo(this._map), this) : this;
            }
            _update(t1) {
                if (!this._map) return;
                this._map.transform.renderWorldCopies && (this._lngLat = na(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
                let e1 = "";
                "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e1 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (e1 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                let i = "";
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? i = "rotateX(0deg)" : "map" === this._pitchAlignment && (i = `rotateX(${this._map.getPitch()}deg)`), t1 && "moveend" !== t1.type || (this._pos = this._pos.round()), r.setTransform(this._element, `${la[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i} ${e1}`), this._map.style && this._map.style.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(()=>{
                    const t1 = this._map.unproject(this._pos), e1 = 40075016.686 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                    this._element.style.opacity = t1.distanceTo(this._lngLat) > 20 * e1 ? "0.2" : "1.0", this._opacityTimeout = null;
                }, 100));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(e1) {
                return this._offset = t1.pointGeometry.convert(e1), this._update(), this;
            }
            _onMove(e1) {
                if (!this._isDragging) {
                    const t1 = this._clickTolerance || this._map._clickTolerance;
                    this._isDragging = e1.point.dist(this._pointerdownPos) >= t1;
                }
                this._isDragging && (this._pos = e1.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t1.Event("dragstart"))), this.fire(new t1.Event("drag")));
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t1.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(t1) {
                this._element.contains(t1.originalEvent.target) && (t1.preventDefault(), this._positionDelta = t1.point.sub(this._pos).add(this._offset), this._pointerdownPos = t1.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }
            setDraggable(t1) {
                return this._draggable = !!t1, this._map && (t1 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(t1) {
                return this._rotation = t1 || 0, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(t1) {
                return this._rotationAlignment = t1 || "auto", this._update(), this;
            }
            getRotationAlignment() {
                return this._rotationAlignment;
            }
            setPitchAlignment(t1) {
                return this._pitchAlignment = t1 && "auto" !== t1 ? t1 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
                return this._pitchAlignment;
            }
        }
        const ua = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0
        };
        let da, ma = 0, _a = !1;
        const pa = {
            maxWidth: 100,
            unit: "metric"
        };
        function fa(t1, e1, i) {
            const o = i && i.maxWidth || 100, a = t1._container.clientHeight / 2, r = t1.unproject([
                0,
                a
            ]), s = t1.unproject([
                o,
                a
            ]), n = r.distanceTo(s);
            if (i && "imperial" === i.unit) {
                const i = 3.2808 * n;
                i > 5280 ? ga(e1, o, i / 5280, t1._getUIString("ScaleControl.Miles")) : ga(e1, o, i, t1._getUIString("ScaleControl.Feet"));
            } else i && "nautical" === i.unit ? ga(e1, o, n / 1852, t1._getUIString("ScaleControl.NauticalMiles")) : n >= 1e3 ? ga(e1, o, n / 1e3, t1._getUIString("ScaleControl.Kilometers")) : ga(e1, o, n, t1._getUIString("ScaleControl.Meters"));
        }
        function ga(t1, e1, i, o) {
            const a = function(t1) {
                const e1 = Math.pow(10, `${Math.floor(t1)}`.length - 1);
                let i = t1 / e1;
                return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(t1) {
                    const e1 = Math.pow(10, Math.ceil(-Math.log(t1) / Math.LN10));
                    return Math.round(t1 * e1) / e1;
                }(i), e1 * i;
            }(i);
            t1.style.width = e1 * (a / i) + "px", t1.innerHTML = `${a}&nbsp;${o}`;
        }
        const xa = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }, va = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function ya(e1) {
            if (e1) {
                if ("number" == typeof e1) {
                    const i = Math.round(Math.sqrt(.5 * Math.pow(e1, 2)));
                    return {
                        center: new t1.pointGeometry(0, 0),
                        top: new t1.pointGeometry(0, e1),
                        "top-left": new t1.pointGeometry(i, i),
                        "top-right": new t1.pointGeometry(-i, i),
                        bottom: new t1.pointGeometry(0, -e1),
                        "bottom-left": new t1.pointGeometry(i, -i),
                        "bottom-right": new t1.pointGeometry(-i, -i),
                        left: new t1.pointGeometry(e1, 0),
                        right: new t1.pointGeometry(-e1, 0)
                    };
                }
                if (e1 instanceof t1.pointGeometry || Array.isArray(e1)) {
                    const i = t1.pointGeometry.convert(e1);
                    return {
                        center: i,
                        top: i,
                        "top-left": i,
                        "top-right": i,
                        bottom: i,
                        "bottom-left": i,
                        "bottom-right": i,
                        left: i,
                        right: i
                    };
                }
                return {
                    center: t1.pointGeometry.convert(e1.center || [
                        0,
                        0
                    ]),
                    top: t1.pointGeometry.convert(e1.top || [
                        0,
                        0
                    ]),
                    "top-left": t1.pointGeometry.convert(e1["top-left"] || [
                        0,
                        0
                    ]),
                    "top-right": t1.pointGeometry.convert(e1["top-right"] || [
                        0,
                        0
                    ]),
                    bottom: t1.pointGeometry.convert(e1.bottom || [
                        0,
                        0
                    ]),
                    "bottom-left": t1.pointGeometry.convert(e1["bottom-left"] || [
                        0,
                        0
                    ]),
                    "bottom-right": t1.pointGeometry.convert(e1["bottom-right"] || [
                        0,
                        0
                    ]),
                    left: t1.pointGeometry.convert(e1.left || [
                        0,
                        0
                    ]),
                    right: t1.pointGeometry.convert(e1.right || [
                        0,
                        0
                    ])
                };
            }
            return ya(new t1.pointGeometry(0, 0));
        }
        const ba = {
            supported: e1,
            setRTLTextPlugin: t1.setRTLTextPlugin,
            getRTLTextPluginStatus: t1.getRTLTextPluginStatus,
            Map: class extends Qo {
                constructor(e1){
                    var i;
                    if (t1.PerformanceUtils.mark(t1.PerformanceMarkers.create), null != (e1 = t1.extend({}, aa, e1)).minZoom && null != e1.maxZoom && e1.minZoom > e1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != e1.minPitch && null != e1.maxPitch && e1.minPitch > e1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != e1.minPitch && e1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != e1.maxPitch && e1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (super(new io(e1.minZoom, e1.maxZoom, e1.minPitch, e1.maxPitch, e1.renderWorldCopies), {
                        bearingSnap: e1.bearingSnap
                    }), this._interactive = e1.interactive, this._cooperativeGestures = e1.cooperativeGestures, this._maxTileCacheSize = e1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e1.preserveDrawingBuffer, this._antialias = e1.antialias, this._trackResize = e1.trackResize, this._bearingSnap = e1.bearingSnap, this._refreshExpiredTiles = e1.refreshExpiredTiles, this._fadeDuration = e1.fadeDuration, this._crossSourceCollisions = e1.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e1.collectResourceTiming, this._renderTaskQueue = new ia, this._controls = [], this._mapId = t1.uniqueId(), this._locale = t1.extend({}, oa, e1.locale), this._clickTolerance = e1.clickTolerance, this._pixelRatio = null !== (i = e1.pixelRatio) && void 0 !== i ? i : devicePixelRatio, this._requestManager = new s(e1.transformRequest), "string" == typeof e1.container) {
                        if (this._container = document.getElementById(e1.container), !this._container) throw new Error(`Container '${e1.container}' not found.`);
                    } else {
                        if (!(e1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = e1.container;
                    }
                    if (e1.maxBounds && this.setMaxBounds(e1.maxBounds), t1.bindAll([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), this.on("terrain", ()=>{
                        this.painter.terrainFacilitator.dirty = !0, this._update(!0);
                    }), "undefined" != typeof window && (addEventListener("online", this._onWindowOnline, !1), addEventListener("resize", this._onWindowResize, !1), addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Yo(this, e1), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e1.hash && new oo("string" == typeof e1.hash && e1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
                        center: e1.center,
                        zoom: e1.zoom,
                        bearing: e1.bearing,
                        pitch: e1.pitch
                    }), e1.bounds && (this.resize(), this.fitBounds(e1.bounds, t1.extend({}, e1.fitBoundsOptions, {
                        duration: 0
                    })))), this.resize(), this._localIdeographFontFamily = e1.localIdeographFontFamily, e1.style && this.setStyle(e1.style, {
                        localIdeographFontFamily: e1.localIdeographFontFamily
                    }), e1.attributionControl && this.addControl(new ta({
                        customAttribution: e1.customAttribution
                    })), e1.maplibreLogo && this.addControl(new ea, e1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                    }), this.on("data", (e1)=>{
                        this._update("style" === e1.dataType), this.fire(new t1.Event(`${e1.dataType}data`, e1));
                    }), this.on("dataloading", (e1)=>{
                        this.fire(new t1.Event(`${e1.dataType}dataloading`, e1));
                    }), this.on("dataabort", (e1)=>{
                        this.fire(new t1.Event("sourcedataabort", e1));
                    });
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(e1, i) {
                    if (void 0 === i && (i = e1.getDefaultPosition ? e1.getDefaultPosition() : "top-right"), !e1 || !e1.onAdd) return this.fire(new t1.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = e1.onAdd(this);
                    this._controls.push(e1);
                    const a = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? a.insertBefore(o, a.firstChild) : a.appendChild(o), this;
                }
                removeControl(e1) {
                    if (!e1 || !e1.onRemove) return this.fire(new t1.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(e1);
                    return i > -1 && this._controls.splice(i, 1), e1.onRemove(this), this;
                }
                hasControl(t1) {
                    return this._controls.indexOf(t1) > -1;
                }
                calculateCameraOptionsFromTo(t1, e1, i, o) {
                    return null == o && this.style.terrain && (o = this.transform.getElevation(i, this.style.terrain)), super.calculateCameraOptionsFromTo(t1, e1, i, o);
                }
                resize(e1) {
                    const i = this._containerDimensions(), o = i[0], a = i[1];
                    this._resizeCanvas(o, a, this.getPixelRatio()), this.transform.resize(o, a), this.painter.resize(o, a, this.getPixelRatio());
                    const r = !this._moving;
                    return r && (this.stop(), this.fire(new t1.Event("movestart", e1)).fire(new t1.Event("move", e1))), this.fire(new t1.Event("resize", e1)), r && this.fire(new t1.Event("moveend", e1)), this;
                }
                getPixelRatio() {
                    return this._pixelRatio;
                }
                setPixelRatio(t1) {
                    const [e1, i] = this._containerDimensions();
                    this._pixelRatio = t1, this._resizeCanvas(e1, i, t1), this.painter.resize(e1, i, t1);
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds();
                }
                setMaxBounds(e1) {
                    return this.transform.setMaxBounds(t1.LngLatBounds.convert(e1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = null == t1 ? -2 : t1) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 && this.setZoom(t1), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = null == t1 ? 22 : t1) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 && this.setZoom(t1), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = null == t1 ? 0 : t1) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 && this.setPitch(t1), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = null == t1 ? 60 : t1) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 && this.setPitch(t1), this;
                    throw new Error("maxPitch must be greater than the current minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(t1) {
                    return this.transform.renderWorldCopies = t1, this._update();
                }
                project(e1) {
                    return this.transform.locationPoint(t1.LngLat.convert(e1), this.style && this.style.terrain);
                }
                unproject(e1) {
                    return this.transform.pointLocation(t1.pointGeometry.convert(e1), this.style && this.style.terrain);
                }
                isMoving() {
                    return this._moving || this.handlers.isMoving();
                }
                isZooming() {
                    return this._zooming || this.handlers.isZooming();
                }
                isRotating() {
                    return this._rotating || this.handlers.isRotating();
                }
                _createDelegatedListener(t1, e1, i) {
                    if ("mouseenter" === t1 || "mouseover" === t1) {
                        let o = !1;
                        const a = (a)=>{
                            const r = this.getLayer(e1) ? this.queryRenderedFeatures(a.point, {
                                layers: [
                                    e1
                                ]
                            }) : [];
                            r.length ? o || (o = !0, i.call(this, new mo(t1, this, a.originalEvent, {
                                features: r
                            }))) : o = !1;
                        };
                        return {
                            layer: e1,
                            listener: i,
                            delegates: {
                                mousemove: a,
                                mouseout: ()=>{
                                    o = !1;
                                }
                            }
                        };
                    }
                    if ("mouseleave" === t1 || "mouseout" === t1) {
                        let o = !1;
                        const a = (a)=>{
                            (this.getLayer(e1) ? this.queryRenderedFeatures(a.point, {
                                layers: [
                                    e1
                                ]
                            }) : []).length ? o = !0 : o && (o = !1, i.call(this, new mo(t1, this, a.originalEvent)));
                        }, r = (e1)=>{
                            o && (o = !1, i.call(this, new mo(t1, this, e1.originalEvent)));
                        };
                        return {
                            layer: e1,
                            listener: i,
                            delegates: {
                                mousemove: a,
                                mouseout: r
                            }
                        };
                    }
                    {
                        const o = (t1)=>{
                            const o = this.getLayer(e1) ? this.queryRenderedFeatures(t1.point, {
                                layers: [
                                    e1
                                ]
                            }) : [];
                            o.length && (t1.features = o, i.call(this, t1), delete t1.features);
                        };
                        return {
                            layer: e1,
                            listener: i,
                            delegates: {
                                [t1]: o
                            }
                        };
                    }
                }
                on(t1, e1, i) {
                    if (void 0 === i) return super.on(t1, e1);
                    const o = this._createDelegatedListener(t1, e1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t1] = this._delegatedListeners[t1] || [], this._delegatedListeners[t1].push(o);
                    for(const t1 in o.delegates)this.on(t1, o.delegates[t1]);
                    return this;
                }
                once(t1, e1, i) {
                    if (void 0 === i) return super.once(t1, e1);
                    const o = this._createDelegatedListener(t1, e1, i);
                    for(const t1 in o.delegates)this.once(t1, o.delegates[t1]);
                    return this;
                }
                off(t1, e1, i) {
                    return void 0 === i ? super.off(t1, e1) : (this._delegatedListeners && this._delegatedListeners[t1] && ((o)=>{
                        const a = this._delegatedListeners[t1];
                        for(let t1 = 0; t1 < a.length; t1++){
                            const o = a[t1];
                            if (o.layer === e1 && o.listener === i) {
                                for(const t1 in o.delegates)this.off(t1, o.delegates[t1]);
                                return a.splice(t1, 1), this;
                            }
                        }
                    })(), this);
                }
                queryRenderedFeatures(e1, i) {
                    if (!this.style) return [];
                    let o;
                    if (void 0 !== i || void 0 === e1 || e1 instanceof t1.pointGeometry || Array.isArray(e1) || (i = e1, e1 = void 0), i = i || {}, (e1 = e1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ]) instanceof t1.pointGeometry || "number" == typeof e1[0]) o = [
                        t1.pointGeometry.convert(e1)
                    ];
                    else {
                        const i = t1.pointGeometry.convert(e1[0]), a = t1.pointGeometry.convert(e1[1]);
                        o = [
                            i,
                            new t1.pointGeometry(a.x, i.y),
                            a,
                            new t1.pointGeometry(i.x, a.y),
                            i
                        ];
                    }
                    return this.style.queryRenderedFeatures(o, i, this.transform);
                }
                querySourceFeatures(t1, e1) {
                    return this.style.querySourceFeatures(t1, e1);
                }
                setStyle(e1, i) {
                    return !1 !== (i = t1.extend({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e1 ? (this._diffStyle(e1, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e1, i));
                }
                setTransformRequest(t1) {
                    return this._requestManager.setTransformRequest(t1), this;
                }
                _getUIString(t1) {
                    const e1 = this._locale[t1];
                    if (null == e1) throw new Error(`Missing UI string '${t1}'`);
                    return e1;
                }
                _updateStyle(t1, e1) {
                    return this.style && (this.style.setEventedParent(null), this.style._remove()), t1 ? (this.style = new ee(this, e1 || {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), "string" == typeof t1 ? this.style.loadURL(t1) : this.style.loadJSON(t1), this) : (delete this.style, this);
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new ee(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                _diffStyle(e1, i) {
                    if ("string" == typeof e1) {
                        const o = this._requestManager.transformRequest(e1, t1.ResourceType.Style);
                        t1.getJSON(o, (e1, o)=>{
                            e1 ? this.fire(new t1.ErrorEvent(e1)) : o && this._updateDiff(o, i);
                        });
                    } else "object" == typeof e1 && this._updateDiff(e1, i);
                }
                _updateDiff(e1, i) {
                    try {
                        this.style.setState(e1) && this._update(!0);
                    } catch (o) {
                        t1.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(e1, i);
                    }
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : t1.warnOnce("There is no style added to the map.");
                }
                addSource(t1, e1) {
                    return this._lazyInitEmptyStyle(), this.style.addSource(t1, e1), this._update(!0);
                }
                isSourceLoaded(e1) {
                    const i = this.style && this.style.sourceCaches[e1];
                    if (void 0 !== i) return i.loaded();
                    this.fire(new t1.ErrorEvent(new Error(`There is no source with ID '${e1}'`)));
                }
                setTerrain(t1) {
                    return this.style.setTerrain(t1), this;
                }
                getTerrain() {
                    return this.style.terrain && this.style.terrain.options;
                }
                areTilesLoaded() {
                    const t1 = this.style && this.style.sourceCaches;
                    for(const e1 in t1){
                        const i = t1[e1]._tiles;
                        for(const t1 in i){
                            const e1 = i[t1];
                            if ("loaded" !== e1.state && "errored" !== e1.state) return !1;
                        }
                    }
                    return !0;
                }
                addSourceType(t1, e1, i) {
                    return this._lazyInitEmptyStyle(), this.style.addSourceType(t1, e1, i);
                }
                removeSource(t1) {
                    return this.style.removeSource(t1), this._update(!0);
                }
                getSource(t1) {
                    return this.style.getSource(t1);
                }
                addImage(e1, i, { pixelRatio: o = 1, sdf: a = !1, stretchX: r, stretchY: s, content: n } = {}) {
                    if (this._lazyInitEmptyStyle(), i instanceof HTMLImageElement || t1.isImageBitmap(i)) {
                        const { width: l, height: c, data: h } = t1.exported.getImageData(i);
                        this.style.addImage(e1, {
                            data: new t1.RGBAImage({
                                width: l,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: r,
                            stretchY: s,
                            content: n,
                            sdf: a,
                            version: 0
                        });
                    } else {
                        if (void 0 === i.width || void 0 === i.height) return this.fire(new t1.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        {
                            const { width: l, height: c, data: h } = i, u = i;
                            this.style.addImage(e1, {
                                data: new t1.RGBAImage({
                                    width: l,
                                    height: c
                                }, new Uint8Array(h)),
                                pixelRatio: o,
                                stretchX: r,
                                stretchY: s,
                                content: n,
                                sdf: a,
                                version: 0,
                                userImage: u
                            }), u.onAdd && u.onAdd(this, e1);
                        }
                    }
                }
                updateImage(e1, i) {
                    const o = this.style.getImage(e1);
                    if (!o) return this.fire(new t1.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const a = i instanceof HTMLImageElement || t1.isImageBitmap(i) ? t1.exported.getImageData(i) : i, { width: r, height: s, data: n } = a;
                    if (void 0 === r || void 0 === s) return this.fire(new t1.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    if (r !== o.data.width || s !== o.data.height) return this.fire(new t1.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                    const l = !(i instanceof HTMLImageElement || t1.isImageBitmap(i));
                    o.data.replace(n, l), this.style.updateImage(e1, o);
                }
                hasImage(e1) {
                    return e1 ? !!this.style.getImage(e1) : (this.fire(new t1.ErrorEvent(new Error("Missing required image id"))), !1);
                }
                removeImage(t1) {
                    this.style.removeImage(t1);
                }
                loadImage(e1, i) {
                    t1.getImage(this._requestManager.transformRequest(e1, t1.ResourceType.Image), i);
                }
                listImages() {
                    return this.style.listImages();
                }
                addLayer(t1, e1) {
                    return this._lazyInitEmptyStyle(), this.style.addLayer(t1, e1), this._update(!0);
                }
                moveLayer(t1, e1) {
                    return this.style.moveLayer(t1, e1), this._update(!0);
                }
                removeLayer(t1) {
                    return this.style.removeLayer(t1), this._update(!0);
                }
                getLayer(t1) {
                    return this.style.getLayer(t1);
                }
                setLayerZoomRange(t1, e1, i) {
                    return this.style.setLayerZoomRange(t1, e1, i), this._update(!0);
                }
                setFilter(t1, e1, i = {}) {
                    return this.style.setFilter(t1, e1, i), this._update(!0);
                }
                getFilter(t1) {
                    return this.style.getFilter(t1);
                }
                setPaintProperty(t1, e1, i, o = {}) {
                    return this.style.setPaintProperty(t1, e1, i, o), this._update(!0);
                }
                getPaintProperty(t1, e1) {
                    return this.style.getPaintProperty(t1, e1);
                }
                setLayoutProperty(t1, e1, i, o = {}) {
                    return this.style.setLayoutProperty(t1, e1, i, o), this._update(!0);
                }
                getLayoutProperty(t1, e1) {
                    return this.style.getLayoutProperty(t1, e1);
                }
                setLight(t1, e1 = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setLight(t1, e1), this._update(!0);
                }
                getLight() {
                    return this.style.getLight();
                }
                setFeatureState(t1, e1) {
                    return this.style.setFeatureState(t1, e1), this._update();
                }
                removeFeatureState(t1, e1) {
                    return this.style.removeFeatureState(t1, e1), this._update();
                }
                getFeatureState(t1) {
                    return this.style.getFeatureState(t1);
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                _containerDimensions() {
                    let t1 = 0, e1 = 0;
                    return this._container && (t1 = this._container.clientWidth || 400, e1 = this._container.clientHeight || 300), [
                        t1,
                        e1
                    ];
                }
                _setupContainer() {
                    const t1 = this._container;
                    t1.classList.add("maplibregl-map", "mapboxgl-map");
                    const e1 = this._canvasContainer = r.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", t1);
                    this._interactive && e1.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas mapboxgl-canvas", e1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
                    const i = this._containerDimensions();
                    this._resizeCanvas(i[0], i[1], this.getPixelRatio());
                    const o = this._controlContainer = r.create("div", "maplibregl-control-container mapboxgl-control-container", t1), a = this._controlPositions = {};
                    [
                        "top-left",
                        "top-right",
                        "bottom-left",
                        "bottom-right"
                    ].forEach((t1)=>{
                        a[t1] = r.create("div", `maplibregl-ctrl-${t1} mapboxgl-ctrl-${t1}`, o);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _setupCooperativeGestures() {
                    const t1 = this._container;
                    this._metaPress = !1, this._cooperativeGesturesScreen = r.create("div", "maplibregl-cooperative-gesture-screen", t1);
                    let e1 = "Control", i = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
                    0 === navigator.platform.indexOf("Mac") && (i = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use \u2318 + scroll to zoom the map", e1 = "Meta"), this._cooperativeGesturesScreen.innerHTML = `\n            <div class="maplibregl-desktop-message">${i}</div>\n            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>\n        `, document.addEventListener("keydown", (t1)=>{
                        t1.key === e1 && (this._metaPress = !0);
                    }), document.addEventListener("keyup", (t1)=>{
                        t1.key === e1 && (this._metaPress = !1);
                    }), this._canvasContainer.addEventListener("wheel", (t1)=>{
                        this._onCooperativeGesture(t1, this._metaPress, 1);
                    }, !1), this._canvasContainer.classList.remove("mapboxgl-touch-drag-pan", "maplibregl-touch-drag-pan");
                }
                _resizeCanvas(t1, e1, i) {
                    this._canvas.width = i * t1, this._canvas.height = i * e1, this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${e1}px`;
                }
                _setupPainter() {
                    const i = t1.extend({}, e1.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), o = this._canvas.getContext("webgl", i) || this._canvas.getContext("experimental-webgl", i);
                    o ? (this.painter = new Ji(o, this.transform), t1.exported$1.testSupport(o)) : this.fire(new t1.ErrorEvent(new Error("Failed to initialize WebGL")));
                }
                _contextLost(e1) {
                    e1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t1.Event("webglcontextlost", {
                        originalEvent: e1
                    }));
                }
                _contextRestored(e1) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new t1.Event("webglcontextrestored", {
                        originalEvent: e1
                    }));
                }
                _onMapScroll(t1) {
                    if (t1.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                _onCooperativeGesture(t1, e1, i) {
                    return !e1 && i < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(()=>{
                        this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
                    }, 100)), !1;
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                _update(t1) {
                    return this.style ? (this._styleDirty = this._styleDirty || t1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(t1) {
                    return this._update(), this._renderTaskQueue.add(t1);
                }
                _cancelRenderFrame(t1) {
                    this._renderTaskQueue.remove(t1);
                }
                _render(e1) {
                    let i, o = 0;
                    const a = this.painter.context.extTimerQuery;
                    if (this.listens("gpu-timing-frame") && (i = a.createQueryEXT(), a.beginQueryEXT(a.TIME_ELAPSED_EXT, i), o = t1.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e1), this._removed) return;
                    let r = !1;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const e1 = this.transform.zoom, i = t1.exported.now();
                        this.style.zoomHistory.update(e1, i);
                        const o = new t1.EvaluationParameters(e1, {
                            now: i,
                            fadeDuration: this._fadeDuration,
                            zoomHistory: this.style.zoomHistory,
                            transition: this.style.getTransition()
                        }), a = o.crossFadingFactor();
                        1 === a && a === this._crossFadingFactor || (r = !0, this._crossFadingFactor = a), this.style.update(o);
                    }
                    if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.style.terrain && this.style.terrain.sourceCache.update(this.transform, this.style.terrain), this.transform.updateElevation(this.style.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showOverdrawInspector: this._showOverdrawInspector,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: this._fadeDuration,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer")
                    }), this.fire(new t1.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, t1.PerformanceUtils.mark(t1.PerformanceMarkers.load), this.fire(new t1.Event("load"))), this.style && (this.style.hasTransitions() || r) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                        const e1 = t1.exported.now() - o;
                        a.endQueryEXT(a.TIME_ELAPSED_EXT, i), setTimeout(()=>{
                            const o = a.getQueryObjectEXT(i, a.QUERY_RESULT_EXT) / 1e6;
                            a.deleteQueryEXT(i), this.fire(new t1.Event("gpu-timing-frame", {
                                cpuTime: e1,
                                gpuTime: o
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const e1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(e1);
                            this.fire(new t1.Event("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    const s = this._sourcesDirty || this._styleDirty || this._placementDirty;
                    return s || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t1.Event("idle")), !this._loaded || this._fullyLoaded || s || (this._fullyLoaded = !0, t1.PerformanceUtils.mark(t1.PerformanceMarkers.fullLoad)), this;
                }
                redraw() {
                    return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const t1 of this._controls)t1.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && (removeEventListener("resize", this._onWindowResize, !1), removeEventListener("orientationchange", this._onWindowResize, !1), removeEventListener("online", this._onWindowOnline, !1));
                    const e1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    e1 && e1.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._cooperativeGestures && r.remove(this._cooperativeGesturesScreen), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), t1.PerformanceUtils.clearMetrics(), this._removed = !0, this.fire(new t1.Event("remove"));
                }
                triggerRepaint() {
                    this.style && !this._frame && (this._frame = t1.exported.frame((e1)=>{
                        t1.PerformanceUtils.frame(e1), this._frame = null, this._render(e1);
                    }));
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(t1) {
                    this._trackResize && this.resize({
                        originalEvent: t1
                    })._update();
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(t1) {
                    this._showTileBoundaries !== t1 && (this._showTileBoundaries = t1, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(t1) {
                    this._showPadding !== t1 && (this._showPadding = t1, this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(t1) {
                    this._showCollisionBoxes !== t1 && (this._showCollisionBoxes = t1, t1 ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(t1) {
                    this._showOverdrawInspector !== t1 && (this._showOverdrawInspector = t1, this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(t1) {
                    this._repaint !== t1 && (this._repaint = t1, this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(t1) {
                    this._vertices = t1, this._update();
                }
                _setCacheLimits(e1, i) {
                    t1.setCacheLimits(e1, i);
                }
                get version() {
                    return "2.4.0";
                }
            },
            NavigationControl: class {
                constructor(e1){
                    this.options = t1.extend({}, ra, e1), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t1)=>t1.preventDefault()), this.options.showZoom && (t1.bindAll([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", (t1)=>this._map.zoomIn({}, {
                            originalEvent: t1
                        })), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", (t1)=>this._map.zoomOut({}, {
                            originalEvent: t1
                        })), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (t1.bindAll([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", (t1)=>{
                        this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                            originalEvent: t1
                        }) : this._map.resetNorth({}, {
                            originalEvent: t1
                        });
                    }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const t1 = this._map.getZoom(), e1 = t1 === this._map.getMaxZoom(), i = t1 === this._map.getMinZoom();
                    this._zoomInButton.disabled = e1, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", e1.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());
                }
                _rotateCompassArrow() {
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
                    this._compassIcon.style.transform = t1;
                }
                onAdd(t1) {
                    return this._map = t1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new sa(this._map, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
                }
                _createButton(t1, e1) {
                    const i = r.create("button", t1, this._container);
                    return i.type = "button", i.addEventListener("click", e1), i;
                }
                _setButtonTitle(t1, e1) {
                    const i = this._map._getUIString(`NavigationControl.${e1}`);
                    t1.title = i, t1.setAttribute("aria-label", i);
                }
            },
            GeolocateControl: class extends t1.Evented {
                constructor(e1){
                    super(), this.options = t1.extend({}, ua, e1), t1.bindAll([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker"
                    ], this);
                }
                onAdd(t1) {
                    var e1;
                    return this._map = t1, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), e1 = this._setupUI, void 0 !== da ? e1(da) : void 0 !== window.navigator.permissions ? window.navigator.permissions.query({
                        name: "geolocation"
                    }).then((t1)=>{
                        da = "denied" !== t1.state, e1(da);
                    }) : (da = !!window.navigator.geolocation, e1(da)), this._container;
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ma = 0, _a = !1;
                }
                _isOutOfMapMaxBounds(t1) {
                    const e1 = this._map.getMaxBounds(), i = t1.coords;
                    return e1 && (i.longitude < e1.getWest() || i.longitude > e1.getEast() || i.latitude < e1.getSouth() || i.latitude > e1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "ACTIVE_ERROR":
                            break;
                        default:
                            throw new Error(`Unexpected watchState ${this._watchState}`);
                    }
                }
                _onSuccess(e1) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(e1)) return this._setErrorState(), this.fire(new t1.Event("outofmaxbounds", e1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = e1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`);
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e1), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t1.Event("geolocate", e1)), this._finish();
                    }
                }
                _updateCamera(e1) {
                    const i = new t1.LngLat(e1.coords.longitude, e1.coords.latitude), o = e1.coords.accuracy, a = this._map.getBearing(), r = t1.extend({
                        bearing: a
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), r, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(e1) {
                    if (e1) {
                        const i = new t1.LngLat(e1.coords.longitude, e1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map._container.clientHeight / 2, e1 = this._map.unproject([
                        0,
                        t1
                    ]), i = this._map.unproject([
                        1,
                        t1
                    ]), o = e1.distanceTo(i), a = Math.ceil(2 * this._accuracy / o);
                    this._circleElement.style.width = `${a}px`, this._circleElement.style.height = `${a}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _onError(e1) {
                    if (this._map) {
                        if (this.options.trackUserLocation) {
                            if (1 === e1.code) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.title = t1, this._geolocateButton.setAttribute("aria-label", t1), void 0 !== this._geolocationWatchID && this._clearWatch();
                            } else {
                                if (3 === e1.code && _a) return;
                                this._setErrorState();
                            }
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t1.Event("error", e1)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(e1) {
                    if (this._container.addEventListener("contextmenu", (t1)=>t1.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === e1) {
                        t1.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                        const e1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                        this._geolocateButton.disabled = !0, this._geolocateButton.title = e1, this._geolocateButton.setAttribute("aria-label", e1);
                    } else {
                        const t1 = this._map._getUIString("GeolocateControl.FindMyLocation");
                        this._geolocateButton.title = t1, this._geolocateButton.setAttribute("aria-label", t1);
                    }
                    this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new ha(this._dotElement), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ha({
                        element: this._circleElement,
                        pitchAlignment: "map"
                    }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (e1)=>{
                        e1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e1.originalEvent && "resize" === e1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this.fire(new t1.Event("trackuserlocationend")));
                    });
                }
                trigger() {
                    if (!this._setup) return t1.warnOnce("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new t1.Event("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                ma--, _a = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new t1.Event("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t1.Event("trackuserlocationstart"));
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`);
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                                break;
                            case "OFF":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`);
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let t1;
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ma++, ma > 1 ? (t1 = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, _a = !0) : (t1 = this.options.positionOptions, _a = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t1);
                        }
                    } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                    return !0;
                }
                _clearWatch() {
                    window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: ta,
            LogoControl: ea,
            ScaleControl: class {
                constructor(e1){
                    this.options = t1.extend({}, pa, e1), t1.bindAll([
                        "_onMove",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _onMove() {
                    fa(this._map, this._container, this.options);
                }
                onAdd(t1) {
                    return this._map = t1, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", t1.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
                }
                onRemove() {
                    r.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
                }
                setUnit(t1) {
                    this.options.unit = t1, fa(this._map, this._container, this.options);
                }
            },
            FullscreenControl: class {
                constructor(e1){
                    this._fullscreen = !1, e1 && e1.container && (e1.container instanceof HTMLElement ? this._container = e1.container : t1.warnOnce("Full screen control 'container' must be a DOM element.")), t1.bindAll([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
                }
                onAdd(e1) {
                    return this._map = e1, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t1.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const t1 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);
                    r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", t1).setAttribute("aria-hidden", "true"), t1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const t1 = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", t1), this._fullscreenButton.title = t1;
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            TerrainControl: class {
                constructor(e1){
                    this.options = e1, t1.bindAll([
                        "_toggleTerrain",
                        "_updateTerrainIcon"
                    ], this);
                }
                onAdd(t1) {
                    return this._map = t1, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain mapboxgl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
                }
                onRemove() {
                    r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
                }
                _toggleTerrain() {
                    this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
                }
                _updateTerrainIcon() {
                    this._terrainButton.classList.remove("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._map.style.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
                }
            },
            Popup: class extends t1.Evented {
                constructor(e1){
                    super(), this.options = t1.extend(Object.create(xa), e1), t1.bindAll([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseMove",
                        "_onMouseUp",
                        "_onDrag"
                    ], this);
                }
                addTo(e1) {
                    return this._map && this.remove(), this._map = e1, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t1.Event("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    return this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t1.Event("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(e1) {
                    return this._lngLat = t1.LngLat.convert(e1), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
                }
                trackPointer() {
                    return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(t1) {
                    return this.setDOMContent(document.createTextNode(t1));
                }
                setHTML(t1) {
                    const e1 = document.createDocumentFragment(), i = document.createElement("body");
                    let o;
                    for(i.innerHTML = t1; o = i.firstChild, o;)e1.appendChild(o);
                    return this.setDOMContent(e1);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(t1) {
                    return this.options.maxWidth = t1, this._update(), this;
                }
                setDOMContent(t1) {
                    if (this._content) for(; this._content.hasChildNodes();)this._content.firstChild && this._content.removeChild(this._content.firstChild);
                    else this._content = r.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);
                    return this._content.appendChild(t1), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
                }
                addClassName(t1) {
                    this._container && this._container.classList.add(t1);
                }
                removeClassName(t1) {
                    this._container && this._container.classList.remove(t1);
                }
                setOffset(t1) {
                    return this.options.offset = t1, this._update(), this;
                }
                toggleClassName(t1) {
                    if (this._container) return this._container.classList.toggle(t1);
                }
                _createCloseButton() {
                    this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
                }
                _onMouseUp(t1) {
                    this._update(t1.point);
                }
                _onMouseMove(t1) {
                    this._update(t1.point);
                }
                _onDrag(t1) {
                    this._update(t1.point);
                }
                _update(t1) {
                    if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
                    if (this._container || (this._container = r.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((t1)=>this._container.classList.add(t1)), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = na(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t1) return;
                    const e1 = this._pos = this._trackPointer && t1 ? t1 : this._map.project(this._lngLat);
                    let i = this.options.anchor;
                    const o = ya(this.options.offset);
                    if (!i) {
                        const t1 = this._container.offsetWidth, a = this._container.offsetHeight;
                        let r;
                        r = e1.y + o.bottom.y < a ? [
                            "top"
                        ] : e1.y > this._map.transform.height - a ? [
                            "bottom"
                        ] : [], e1.x < t1 / 2 ? r.push("left") : e1.x > this._map.transform.width - t1 / 2 && r.push("right"), i = 0 === r.length ? "bottom" : r.join("-");
                    }
                    const a = e1.add(o[i]).round();
                    r.setTransform(this._container, `${la[i]} translate(${a.x}px,${a.y}px)`), ca(this._container, i, "popup");
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const t1 = this._container.querySelector(va);
                    t1 && t1.focus();
                }
                _onClose() {
                    this.remove();
                }
            },
            Marker: ha,
            Style: ee,
            LngLat: t1.LngLat,
            LngLatBounds: t1.LngLatBounds,
            Point: t1.pointGeometry,
            MercatorCoordinate: t1.MercatorCoordinate,
            Evented: t1.Evented,
            AJAXError: t1.AJAXError,
            config: t1.config,
            CanvasSource: P,
            GeoJSONSource: C,
            ImageSource: D,
            RasterDEMTileSource: I,
            RasterTileSource: T,
            VectorTileSource: w,
            VideoSource: z,
            prewarm: function() {
                j().acquire(G);
            },
            clearPrewarmedResources: function() {
                const t1 = q;
                t1 && (t1.isPreloaded() && 1 === t1.numActive() ? (t1.release(G), q = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
            },
            get version () {
                return "2.4.0";
            },
            get workerCount () {
                return Z.workerCount;
            },
            set workerCount (t){
                Z.workerCount = t;
            },
            get maxParallelImageRequests () {
                return t1.config.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (e){
                t1.config.MAX_PARALLEL_IMAGE_REQUESTS = e;
            },
            clearStorage (e1) {
                t1.clearTileCache(e1);
            },
            workerUrl: "",
            addProtocol (e1, i) {
                t1.config.REGISTERED_PROTOCOLS[e1] = i;
            },
            removeProtocol (e1) {
                delete t1.config.REGISTERED_PROTOCOLS[e1];
            }
        };
        return Jo.extend(ba, {
            isSafari: t1.isSafari,
            getPerformanceMetrics: t1.PerformanceUtils.getPerformanceMetrics
        }), ba;
    });
    //
    var maplibregl$1 = maplibregl;
    return maplibregl$1;
});

},{}]},["8MOcE"], null, "parcelRequire716c")

//# sourceMappingURL=maplibre-gl.5826d357.js.map
