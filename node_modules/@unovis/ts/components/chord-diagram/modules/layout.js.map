{"version":3,"file":"layout.js","sources":["../../../../src/components/chord-diagram/modules/layout.ts"],"sourcesContent":["import { group, index } from 'd3-array'\nimport { HierarchyNode, hierarchy } from 'd3-hierarchy'\nimport { pie } from 'd3-shape'\n\n// Utils\nimport { getNumber, groupBy } from 'utils/data'\n\n// Types\nimport { NumericAccessor } from 'types/accessor'\n\n// Local Types\nimport { ChordNode, ChordRibbon, ChordLinkDatum, ChordHierarchyNode, ChordLeafNode } from '../types'\n\nfunction transformData <T> (node: HierarchyNode<T>): void {\n  const { height, depth } = node\n  if (height > 0) {\n    const d = node.data as unknown as [string, T[]]\n    const n = node as unknown as HierarchyNode<ChordHierarchyNode<T>>\n    n.data = { key: d[0], values: d[1], depth, height, ancestors: n.ancestors().map(d => d.data.key) }\n  }\n}\n\nexport function getHierarchyNodes<N> (\n  data: N[],\n  value: NumericAccessor<N>,\n  levels: string[] = []\n): HierarchyNode<ChordHierarchyNode<N>> {\n  const nodeLevels = levels.map(level => (d: N) => d[level as keyof N]) as unknown as [(d: N) => string]\n  const nestedData = levels.length ? group<N, string>(data, ...nodeLevels) : { key: 'root', children: data }\n\n  const root = hierarchy(nestedData)\n    .sum(d => getNumber(d as unknown as N, value))\n    .each(transformData)\n\n  return root as unknown as HierarchyNode<ChordHierarchyNode<N>>\n}\n\nexport function positionChildren<N> (node: ChordNode<N>, padding: number, scalingCoeff = 0.95): void {\n  if (!node.children) return\n\n  // We need to ensure levels with empty links still take up full space\n  const containsLinks = node.value > 0\n\n  const length = node.x1 - node.x0\n  const scaledLength = length * (node.y0 === 0 ? 1 : scalingCoeff)\n  const delta = length - scaledLength\n  const padAngle = containsLinks ? padding : scaledLength / node.children.length\n\n  const positions = pie<ChordNode<N>>()\n    .startAngle(node.x0 + delta / 2)\n    .endAngle(node.x1 - delta / 2)\n    .padAngle(padAngle)\n    .value(d => containsLinks ? d.value : 1)\n    .sort((a, b) => node.children.indexOf(a) - node.children.indexOf(b))(node.children)\n\n  node.children.forEach((child, i) => {\n    const x0 = positions[i].startAngle\n    const x1 = positions[i].endAngle\n    const childDelta = (x1 - x0) * (1 - scalingCoeff)\n    const xmid = (x0 + x1) / 2\n    child.x0 = containsLinks ? x0 + childDelta / 2 : xmid - padding / 2\n    child.x1 = containsLinks ? x1 - childDelta / 2 : xmid + padding / 2\n  })\n}\n\nexport function getRibbons<N> (data: ChordNode<N>, links: ChordLinkDatum<N>[], padding: number): ChordRibbon<N>[] {\n  type LinksArrayType = typeof links\n  const groupedBySource: Record<string, LinksArrayType> = groupBy(links, d => d.source._id)\n  const groupedByTarget: Record<string, LinksArrayType> = groupBy(links, d => d.target._id)\n\n  const leafNodes = data.leaves() as ChordLeafNode<N>[]\n  const leafNodesById: Map<string, ChordLeafNode<N>> = index(leafNodes, d => d.data._id)\n\n  const getNodesInRibbon = (\n    source: ChordLeafNode<N>,\n    target: ChordLeafNode<N>,\n    partitionHeight: number,\n    nodes: ChordNode<N>[] = []\n  ): ChordNode<N>[] => {\n    nodes[source.height] = source\n    nodes[partitionHeight * 2 - target.height] = target\n    if (source.parent && target.parent) getNodesInRibbon(source.parent, target.parent, partitionHeight, nodes)\n    return nodes\n  }\n  const calculatePoints = (links: LinksArrayType, type: 'in' | 'out', depth: number, maxDepth: number): void => {\n    links.forEach(link => {\n      if (!link._state.points) link._state.points = []\n\n      const sourceLeaf = leafNodesById.get(link.source._id)\n      const targetLeaf = leafNodesById.get(link.target._id)\n      const nodesInRibbon = getNodesInRibbon(\n        type === 'out' ? sourceLeaf : targetLeaf,\n        type === 'out' ? targetLeaf : sourceLeaf,\n        maxDepth\n      )\n      const currNode = nodesInRibbon[depth]\n      const len = currNode.x1 - currNode.x0 - padding\n      const x0 = currNode._prevX1 ?? (currNode.x0 + padding / 2)\n      const x1 = x0 + len * link._state.value / currNode.value\n      currNode._prevX1 = x1\n\n      const pointIdx = type === 'out' ? depth : maxDepth * 2 - 1 - depth\n      link._state.points[pointIdx] = { a0: x0, a1: x1, r: currNode.y1 }\n    })\n  }\n\n  leafNodes.forEach(leafNode => {\n    const outLinks = groupedBySource[leafNode.data._id] || []\n    const inLinks = groupedByTarget[leafNode.data._id] || []\n    for (let depth = 0; depth < leafNode.depth; depth += 1) {\n      calculatePoints(outLinks, 'out', depth, leafNode.depth)\n      calculatePoints(inLinks, 'in', depth, leafNode.depth)\n    }\n  })\n\n  return links.map(l => ({\n    source: leafNodesById.get(l.source._id),\n    target: leafNodesById.get(l.target._id),\n    data: l,\n    points: l._state.points,\n    _state: {},\n  }))\n}\n"],"names":[],"mappings":"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"}