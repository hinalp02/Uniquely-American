{"version":3,"file":"cross-count.js","sources":["../../lib/order/cross-count.js"],"sourcesContent":["import _forEach from 'lodash-es/forEach'\nimport _sortBy from 'lodash-es/sortBy'\nimport _flatten from 'lodash-es/flatten'\nimport _map from 'lodash-es/map'\nimport _zipObject from 'lodash-es/zipObject'\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount (g, layering) {\n  let cc = 0\n\n  for (let i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i])\n  }\n\n  return cc\n}\n\nfunction twoLayerCrossCount (g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = _zipObject(southLayer, _map(southLayer, function (v, i) {\n    return i\n  }))\n\n  const southEntries = _flatten(_map(northLayer, function (v) {\n    const outEdges = g.outEdges(v)\n\n    const pos = _map(outEdges, e => ({\n      pos: southPos[e.w],\n      weight: g.edge(e).weight\n    }))\n\n    const posSorted = _sortBy(pos, 'pos')\n\n    return posSorted\n  }), true) // Build the accumulator tree\n\n  let firstIndex = 1\n\n  while (firstIndex < southLayer.length) {\n    firstIndex <<= 1\n  }\n\n  const treeSize = 2 * firstIndex - 1\n  firstIndex -= 1\n\n  const tree = _map(new Array(treeSize), function () {\n    return 0\n  }) // Calculate the weighted crossings\n\n  let cc = 0\n\n  _forEach(southEntries.forEach(function (entry) {\n    let index = entry.pos + firstIndex\n    tree[index] += entry.weight\n    let weightSum = 0\n\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1]\n      }\n\n      index = index - 1 >> 1\n      tree[index] += entry.weight\n    }\n\n    cc += entry.weight * weightSum\n  }))\n\n  return cc\n}\n\nexport default crossCount\n"],"names":[],"mappings":";;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU,EAAE,CAAC,EAAE,QAAQ,EAAE;AAClC,EAAE,IAAI,EAAE,GAAG,EAAC;AACZ;AACA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;AAC5C,IAAI,EAAE,IAAI,kBAAkB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAC;AAC7D,GAAG;AACH;AACA,EAAE,OAAO,EAAE;AACX,CAAC;AACD;AACA,SAAS,kBAAkB,EAAE,CAAC,EAAE,UAAU,EAAE,UAAU,EAAE;AACxD;AACA;AACA;AACA,EAAE,MAAM,QAAQ,GAAG,UAAU,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE,CAAC,EAAE;AAC3E,IAAI,OAAO,CAAC;AACZ,GAAG,CAAC,EAAC;AACL;AACA,EAAE,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE;AAC9D,IAAI,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAC;AAClC;AACA,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK;AACrC,MAAM,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,MAAM,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM;AAC9B,KAAK,CAAC,EAAC;AACP;AACA,IAAI,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,EAAE,KAAK,EAAC;AACzC;AACA,IAAI,OAAO,SAAS;AACpB,GAAG,CAAC,EAAE,IAAI,EAAC;AACX;AACA,EAAE,IAAI,UAAU,GAAG,EAAC;AACpB;AACA,EAAE,OAAO,UAAU,GAAG,UAAU,CAAC,MAAM,EAAE;AACzC,IAAI,UAAU,KAAK,EAAC;AACpB,GAAG;AACH;AACA,EAAE,MAAM,QAAQ,GAAG,CAAC,GAAG,UAAU,GAAG,EAAC;AACrC,EAAE,UAAU,IAAI,EAAC;AACjB;AACA,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,YAAY;AACrD,IAAI,OAAO,CAAC;AACZ,GAAG,EAAC;AACJ;AACA,EAAE,IAAI,EAAE,GAAG,EAAC;AACZ;AACA,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,KAAK,EAAE;AACjD,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,GAAG,GAAG,WAAU;AACtC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,OAAM;AAC/B,IAAI,IAAI,SAAS,GAAG,EAAC;AACrB;AACA,IAAI,OAAO,KAAK,GAAG,CAAC,EAAE;AACtB,MAAM,IAAI,KAAK,GAAG,CAAC,EAAE;AACrB,QAAQ,SAAS,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,EAAC;AACpC,OAAO;AACP;AACA,MAAM,KAAK,GAAG,KAAK,GAAG,CAAC,IAAI,EAAC;AAC5B,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,OAAM;AACjC,KAAK;AACL;AACA,IAAI,EAAE,IAAI,KAAK,CAAC,MAAM,GAAG,UAAS;AAClC,GAAG,CAAC,EAAC;AACL;AACA,EAAE,OAAO,EAAE;AACX;;;;"}