{"version":3,"file":"network-simplex.js","sources":["../../lib/rank/network-simplex.js"],"sourcesContent":["import _minBy from 'lodash-es/minBy'\nimport _filter from 'lodash-es/filter'\nimport _find from 'lodash-es/find'\nimport _has from 'lodash-es/has'\nimport _forEach from 'lodash-es/forEach'\nimport { alg } from '@unovis/graphlibrary'\nimport feasibleTree from './feasible-tree'\nimport { slack, longestPath as initRank } from './util'\nimport { simplify } from '../util'\nconst {\n  preorder,\n  postorder\n} = alg // Expose some internals for testing purposes\n\nnetworkSimplex.initLowLimValues = initLowLimValues\nnetworkSimplex.initCutValues = initCutValues\nnetworkSimplex.calcCutValue = calcCutValue\nnetworkSimplex.leaveEdge = leaveEdge\nnetworkSimplex.enterEdge = enterEdge\nnetworkSimplex.exchangeEdges = exchangeEdges\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\n\nfunction networkSimplex (g) {\n  g = simplify(g)\n  initRank(g)\n  const t = feasibleTree(g)\n  initLowLimValues(t)\n  initCutValues(t, g)\n  let e\n  let f\n\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e)\n    exchangeEdges(t, g, e, f)\n  }\n}\n/*\n * Initializes cut values for all edges in the tree.\n */\n\nfunction initCutValues (t, g) {\n  let vs = postorder(t, t.nodes())\n  vs = vs.slice(0, vs.length - 1)\n\n  _forEach(vs, function (v) {\n    assignCutValue(t, g, v)\n  })\n}\n\nfunction assignCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child)\n}\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\n\nfunction calcCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent // True if the child is on the tail end of the edge in the directed graph\n\n  let childIsTail = true // The graph's view of the tree edge we're inspecting\n\n  let graphEdge = g.edge(child, parent) // The accumulated cut value for the edge between this node and its parent\n\n  let cutValue = 0\n\n  if (!graphEdge) {\n    childIsTail = false\n    graphEdge = g.edge(parent, child)\n  }\n\n  cutValue = graphEdge.weight\n\n  _forEach(g.nodeEdges(child), function (e) {\n    const isOutEdge = e.v === child\n    const other = isOutEdge ? e.w : e.v\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail\n      const otherWeight = g.edge(e).weight\n      cutValue += pointsToHead ? otherWeight : -otherWeight\n\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edge(child, other).cutvalue\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue\n      }\n    }\n  })\n\n  return cutValue\n}\n\nfunction initLowLimValues (tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0]\n  }\n\n  dfsAssignLowLim(tree, {}, 1, root)\n}\n\nfunction dfsAssignLowLim (tree, visited, nextLim, v, parent) {\n  const low = nextLim\n  const label = tree.node(v)\n  visited[v] = true\n\n  _forEach(tree.neighbors(v), function (w) {\n    if (!_has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v)\n    }\n  })\n\n  label.low = low\n  label.lim = nextLim++\n\n  if (parent) {\n    label.parent = parent\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent\n  }\n\n  return nextLim\n}\n\nfunction leaveEdge (tree) {\n  return _find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0\n  })\n}\n\nfunction enterEdge (t, g, edge) {\n  let v = edge.v\n  let w = edge.w // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n\n  if (!g.hasEdge(v, w)) {\n    v = edge.w\n    w = edge.v\n  }\n\n  const vLabel = t.node(v)\n  const wLabel = t.node(w)\n  let tailLabel = vLabel\n  let flip = false // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel\n    flip = true\n  }\n\n  const candidates = _filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel)\n  })\n\n  return _minBy(candidates, function (edge) {\n    return slack(g, edge)\n  })\n}\n\nfunction exchangeEdges (t, g, e, f) {\n  const v = e.v\n  const w = e.w\n  t.removeEdge(v, w)\n  t.setEdge(f.v, f.w, {})\n  initLowLimValues(t)\n  initCutValues(t, g)\n  updateRanks(t, g)\n}\n\nfunction updateRanks (t, g) {\n  const root = _find(t.nodes(), function (v) {\n    return !g.node(v).parent\n  })\n\n  let vs = preorder(t, root)\n  vs = vs.slice(1)\n\n  _forEach(vs, function (v) {\n    const parent = t.node(v).parent\n    let edge = g.edge(v, parent)\n    let flipped = false\n\n    if (!edge) {\n      edge = g.edge(parent, v)\n      flipped = true\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen)\n  })\n}\n/*\n * Returns true if the edge is in the tree.\n */\n\nfunction isTreeEdge (tree, u, v) {\n  return tree.hasEdge(u, v)\n}\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\n\nfunction isDescendant (tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim\n}\n\nexport default networkSimplex\n"],"names":["initRank"],"mappings":";;;;;;;;;;AASA,MAAM;AACN,EAAE,QAAQ;AACV,EAAE,SAAS;AACX,CAAC,GAAG,IAAG;AACP;AACA,cAAc,CAAC,gBAAgB,GAAG,iBAAgB;AAClD,cAAc,CAAC,aAAa,GAAG,cAAa;AAC5C,cAAc,CAAC,YAAY,GAAG,aAAY;AAC1C,cAAc,CAAC,SAAS,GAAG,UAAS;AACpC,cAAc,CAAC,SAAS,GAAG,UAAS;AACpC,cAAc,CAAC,aAAa,GAAG,cAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,EAAE,CAAC,EAAE;AAC5B,EAAE,CAAC,GAAG,QAAQ,CAAC,CAAC,EAAC;AACjB,EAAEA,WAAQ,CAAC,CAAC,EAAC;AACb,EAAE,MAAM,CAAC,GAAG,YAAY,CAAC,CAAC,EAAC;AAC3B,EAAE,gBAAgB,CAAC,CAAC,EAAC;AACrB,EAAE,aAAa,CAAC,CAAC,EAAE,CAAC,EAAC;AACrB,EAAE,IAAI,EAAC;AACP,EAAE,IAAI,EAAC;AACP;AACA,EAAE,QAAQ,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG;AAC7B,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC;AAC1B,IAAI,aAAa,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC;AAC7B,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,aAAa,EAAE,CAAC,EAAE,CAAC,EAAE;AAC9B,EAAE,IAAI,EAAE,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,EAAC;AAClC,EAAE,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,GAAG,CAAC,EAAC;AACjC;AACA,EAAE,QAAQ,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE;AAC5B,IAAI,cAAc,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC;AAC3B,GAAG,EAAC;AACJ,CAAC;AACD;AACA,SAAS,cAAc,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE;AACtC,EAAE,MAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAC;AAChC,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAM;AAChC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,QAAQ,GAAG,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAC;AAC5D,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE;AACpC,EAAE,MAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAC;AAChC,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAM;AAChC;AACA,EAAE,IAAI,WAAW,GAAG,KAAI;AACxB;AACA,EAAE,IAAI,SAAS,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,EAAC;AACvC;AACA,EAAE,IAAI,QAAQ,GAAG,EAAC;AAClB;AACA,EAAE,IAAI,CAAC,SAAS,EAAE;AAClB,IAAI,WAAW,GAAG,MAAK;AACvB,IAAI,SAAS,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAC;AACrC,GAAG;AACH;AACA,EAAE,QAAQ,GAAG,SAAS,CAAC,OAAM;AAC7B;AACA,EAAE,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,UAAU,CAAC,EAAE;AAC5C,IAAI,MAAM,SAAS,GAAG,CAAC,CAAC,CAAC,KAAK,MAAK;AACnC,IAAI,MAAM,KAAK,GAAG,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAC;AACvC;AACA,IAAI,IAAI,KAAK,KAAK,MAAM,EAAE;AAC1B,MAAM,MAAM,YAAY,GAAG,SAAS,KAAK,YAAW;AACpD,MAAM,MAAM,WAAW,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAM;AAC1C,MAAM,QAAQ,IAAI,YAAY,GAAG,WAAW,GAAG,CAAC,YAAW;AAC3D;AACA,MAAM,IAAI,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE;AACvC,QAAQ,MAAM,aAAa,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,SAAQ;AAC3D,QAAQ,QAAQ,IAAI,YAAY,GAAG,CAAC,aAAa,GAAG,cAAa;AACjE,OAAO;AACP,KAAK;AACL,GAAG,EAAC;AACJ;AACA,EAAE,OAAO,QAAQ;AACjB,CAAC;AACD;AACA,SAAS,gBAAgB,EAAE,IAAI,EAAE,IAAI,EAAE;AACvC,EAAE,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;AAC5B,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,EAAC;AAC1B,GAAG;AACH;AACA,EAAE,eAAe,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAC;AACpC,CAAC;AACD;AACA,SAAS,eAAe,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,EAAE,MAAM,EAAE;AAC7D,EAAE,MAAM,GAAG,GAAG,QAAO;AACrB,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,EAAC;AAC5B,EAAE,OAAO,CAAC,CAAC,CAAC,GAAG,KAAI;AACnB;AACA,EAAE,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE;AAC3C,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE;AAC3B,MAAM,OAAO,GAAG,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,EAAC;AAC7D,KAAK;AACL,GAAG,EAAC;AACJ;AACA,EAAE,KAAK,CAAC,GAAG,GAAG,IAAG;AACjB,EAAE,KAAK,CAAC,GAAG,GAAG,OAAO,GAAE;AACvB;AACA,EAAE,IAAI,MAAM,EAAE;AACd,IAAI,KAAK,CAAC,MAAM,GAAG,OAAM;AACzB,GAAG,MAAM;AACT;AACA,IAAI,OAAO,KAAK,CAAC,OAAM;AACvB,GAAG;AACH;AACA,EAAE,OAAO,OAAO;AAChB,CAAC;AACD;AACA,SAAS,SAAS,EAAE,IAAI,EAAE;AAC1B,EAAE,OAAO,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,UAAU,CAAC,EAAE;AAC1C,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC;AACpC,GAAG,CAAC;AACJ,CAAC;AACD;AACA,SAAS,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE;AAChC,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,EAAC;AAChB,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,EAAC;AAChB;AACA;AACA;AACA,EAAE,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;AACxB,IAAI,CAAC,GAAG,IAAI,CAAC,EAAC;AACd,IAAI,CAAC,GAAG,IAAI,CAAC,EAAC;AACd,GAAG;AACH;AACA,EAAE,MAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,EAAC;AAC1B,EAAE,MAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,EAAC;AAC1B,EAAE,IAAI,SAAS,GAAG,OAAM;AACxB,EAAE,IAAI,IAAI,GAAG,MAAK;AAClB;AACA;AACA,EAAE,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,EAAE;AAC/B,IAAI,SAAS,GAAG,OAAM;AACtB,IAAI,IAAI,GAAG,KAAI;AACf,GAAG;AACH;AACA,EAAE,MAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAU,IAAI,EAAE;AACxD,IAAI,OAAO,IAAI,KAAK,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,IAAI,IAAI,KAAK,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC;AACrH,GAAG,EAAC;AACJ;AACA,EAAE,OAAO,MAAM,CAAC,UAAU,EAAE,UAAU,IAAI,EAAE;AAC5C,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC;AACzB,GAAG,CAAC;AACJ,CAAC;AACD;AACA,SAAS,aAAa,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;AACpC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAC;AACf,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAC;AACf,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,EAAC;AACpB,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,EAAC;AACzB,EAAE,gBAAgB,CAAC,CAAC,EAAC;AACrB,EAAE,aAAa,CAAC,CAAC,EAAE,CAAC,EAAC;AACrB,EAAE,WAAW,CAAC,CAAC,EAAE,CAAC,EAAC;AACnB,CAAC;AACD;AACA,SAAS,WAAW,EAAE,CAAC,EAAE,CAAC,EAAE;AAC5B,EAAE,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAU,CAAC,EAAE;AAC7C,IAAI,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM;AAC5B,GAAG,EAAC;AACJ;AACA,EAAE,IAAI,EAAE,GAAG,QAAQ,CAAC,CAAC,EAAE,IAAI,EAAC;AAC5B,EAAE,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,EAAC;AAClB;AACA,EAAE,QAAQ,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE;AAC5B,IAAI,MAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAM;AACnC,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAC;AAChC,IAAI,IAAI,OAAO,GAAG,MAAK;AACvB;AACA,IAAI,IAAI,CAAC,IAAI,EAAE;AACf,MAAM,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAC;AAC9B,MAAM,OAAO,GAAG,KAAI;AACpB,KAAK;AACL;AACA,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,MAAM,EAAC;AACjF,GAAG,EAAC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,UAAU,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE;AACjC,EAAE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;AAC3B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE;AAChD,EAAE,OAAO,SAAS,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,SAAS,CAAC,GAAG;AACnE;;;;"}