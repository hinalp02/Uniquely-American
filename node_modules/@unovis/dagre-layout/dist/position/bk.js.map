{"version":3,"file":"bk.js","sources":["../../lib/position/bk.js"],"sourcesContent":["import _bind from 'lodash-es/bind'\nimport _merge from 'lodash-es/merge'\nimport _map from 'lodash-es/map'\nimport _mapValues from 'lodash-es/mapValues'\nimport _max from 'lodash-es/max'\nimport _min from 'lodash-es/min'\nimport _maxBy from 'lodash-es/maxBy'\nimport _toPairs from 'lodash-es/toPairs'\nimport _values from 'lodash-es/values'\nimport _minBy from 'lodash-es/minBy'\nimport _sortBy from 'lodash-es/sortBy'\nimport _has from 'lodash-es/has'\nimport _find from 'lodash-es/find'\nimport _range from 'lodash-es/range'\nimport _reduce from 'lodash-es/reduce'\nimport _forEach from 'lodash-es/forEach'\nimport _last from 'lodash-es/last'\nimport { Graph } from '@unovis/graphlibrary'\nimport util from '../util'\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\n\nfunction findType1Conflicts (g, layering) {\n  const conflicts = {}\n\n  function visitLayer (prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0 // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n\n    let scanPos = 0\n    const prevLayerLength = prevLayer.length\n\n    const lastNode = _last(layer)\n\n    _forEach(layer, function (v, i) {\n      const w = findOtherInnerSegmentNode(g, v)\n      const k1 = w ? g.node(w).order : prevLayerLength\n\n      if (w || v === lastNode) {\n        _forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _forEach(g.predecessors(scanNode), function (u) {\n            const uLabel = g.node(u)\n            const uPos = uLabel.order\n\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode)\n            }\n          })\n        })\n\n        scanPos = i + 1\n        k0 = k1\n      }\n    })\n\n    return layer\n  }\n\n  _reduce(layering, visitLayer)\n\n  return conflicts\n}\n\nfunction findType2Conflicts (g, layering) {\n  const conflicts = {}\n\n  function scan (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    let v\n\n    _forEach(_range(southPos, southEnd), function (i) {\n      v = south[i]\n\n      if (g.node(v).dummy) {\n        _forEach(g.predecessors(v), function (u) {\n          const uNode = g.node(u)\n\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v)\n          }\n        })\n      }\n    })\n  }\n\n  function visitLayer (north, south) {\n    let prevNorthPos = -1\n    let nextNorthPos\n    let southPos = 0\n\n    _forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        const predecessors = g.predecessors(v)\n\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos)\n          southPos = southLookahead\n          prevNorthPos = nextNorthPos\n        }\n      }\n\n      scan(south, southPos, south.length, nextNorthPos, north.length)\n    })\n\n    return south\n  }\n\n  _reduce(layering, visitLayer)\n\n  return conflicts\n}\n\nfunction findOtherInnerSegmentNode (g, v) {\n  if (g.node(v).dummy) {\n    return _find(g.predecessors(v), function (u) {\n      return g.node(u).dummy\n    })\n  }\n}\n\nfunction addConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n\n  let conflictsV = conflicts[v]\n\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {}\n  }\n\n  conflictsV[w] = true\n}\n\nfunction hasConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n\n  return _has(conflicts[v], w)\n}\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\n\nfunction verticalAlignment (g, layering, conflicts, neighborFn) {\n  const root = {}\n  const align = {}\n  const pos = {} // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n\n  _forEach(layering, function (layer) {\n    _forEach(layer, function (v, order) {\n      root[v] = v\n      align[v] = v\n      pos[v] = order\n    })\n  })\n\n  _forEach(layering, function (layer) {\n    let prevIdx = -1\n\n    _forEach(layer, function (v) {\n      let ws = neighborFn(v)\n\n      if (ws.length) {\n        ws = _sortBy(ws, function (w) {\n          return pos[w]\n        })\n        const mp = (ws.length - 1) / 2\n\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i]\n\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v\n            align[v] = root[v] = root[w]\n            prevIdx = pos[w]\n          }\n        }\n      }\n    })\n  })\n\n  return {\n    root: root,\n    align: align\n  }\n}\n\nfunction horizontalCompaction (g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs = {}\n  const blockG = buildBlockGraph(g, layering, root, reverseSep) // First pass, assign smallest coordinates via DFS\n\n  const visited = {}\n\n  function pass1 (v) {\n    if (!_has(visited, v)) {\n      visited[v] = true\n      xs[v] = _reduce(blockG.inEdges(v), function (max, e) {\n        pass1(e.v)\n        return Math.max(max, xs[e.v] + blockG.edge(e))\n      }, 0)\n    }\n  }\n\n  _forEach(blockG.nodes(), pass1)\n\n  const borderType = reverseSep ? 'borderLeft' : 'borderRight'\n\n  function pass2 (v) {\n    if (visited[v] !== 2) {\n      visited[v]++\n      const node = g.node(v)\n\n      const min = _reduce(blockG.outEdges(v), function (min, e) {\n        pass2(e.w)\n        return Math.min(min, xs[e.w] - blockG.edge(e))\n      }, Number.POSITIVE_INFINITY)\n\n      if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n        xs[v] = Math.max(xs[v], min)\n      }\n    }\n  }\n\n  _forEach(blockG.nodes(), pass2) // Assign x coordinates to all nodes\n\n  _forEach(align, function (v) {\n    xs[v] = xs[root[v]]\n  })\n\n  return xs\n}\n\nfunction buildBlockGraph (g, layering, root, reverseSep) {\n  const blockGraph = new Graph()\n  const graphLabel = g.graph()\n  const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep)\n\n  _forEach(layering, function (layer) {\n    let u\n\n    _forEach(layer, function (v) {\n      const vRoot = root[v]\n      blockGraph.setNode(vRoot)\n\n      if (u) {\n        const uRoot = root[u]\n        const prevMax = blockGraph.edge(uRoot, vRoot)\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0))\n      }\n\n      u = v\n    })\n  })\n\n  return blockGraph\n}\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\n\nfunction findSmallestWidthAlignment (g, xss) {\n  return _minBy(_values(xss), function (xs) {\n    const min = (_minBy(_toPairs(xs), pair => pair[1] - width(g, pair[0]) / 2) || ['k', 0])[1]\n    const max = (_maxBy(_toPairs(xs), pair => pair[1] + width(g, pair[0]) / 2) || ['k', 0])[1]\n    return max - min\n  })\n}\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\n\nfunction alignCoordinates (xss, alignTo) {\n  const alignToVals = _values(alignTo)\n\n  const alignToMin = _min(alignToVals)\n\n  const alignToMax = _max(alignToVals)\n\n  _forEach(['u', 'd'], function (vert) {\n    _forEach(['l', 'r'], function (horiz) {\n      const alignment = vert + horiz\n      const xs = xss[alignment]\n\n      if (xs === alignTo) {\n        return\n      }\n\n      const xsVals = _values(xs)\n\n      const delta = horiz === 'l' ? alignToMin - _min(xsVals) : alignToMax - _max(xsVals)\n\n      if (delta) {\n        xss[alignment] = _mapValues(xs, function (x) {\n          return x + delta\n        })\n      }\n    })\n  })\n}\n\nfunction balance (xss, align) {\n  return _mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v]\n    } else {\n      const xs = _sortBy(_map(xss, v))\n\n      return (xs[1] + xs[2]) / 2\n    }\n  })\n}\n\nexport function positionX (g) {\n  const layering = util.buildLayerMatrix(g)\n\n  const conflicts = _merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering))\n\n  const xss = {}\n  let adjustedLayering\n\n  _forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _values(layering).reverse()\n\n    _forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _map(adjustedLayering, function (inner) {\n          return _values(inner).reverse()\n        })\n      }\n\n      const neighborFn = _bind(vert === 'u' ? g.predecessors : g.successors, g)\n\n      const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn)\n      let xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === 'r')\n\n      if (horiz === 'r') {\n        xs = _mapValues(xs, function (x) {\n          return -x\n        })\n      }\n\n      xss[vert + horiz] = xs\n    })\n  })\n\n  const smallestWidth = findSmallestWidthAlignment(g, xss)\n  alignCoordinates(xss, smallestWidth)\n  return balance(xss, g.graph().align)\n}\n\nfunction sep (nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    const vLabel = g.node(v)\n    const wLabel = g.node(w)\n    let sum = 0\n    let delta\n    sum += vLabel.width / 2\n\n    if (_has(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = -vLabel.width / 2\n          break\n\n        case 'r':\n          delta = vLabel.width / 2\n          break\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n\n    delta = 0\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2\n    sum += wLabel.width / 2\n\n    if (_has(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = wLabel.width / 2\n          break\n\n        case 'r':\n          delta = -wLabel.width / 2\n          break\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n\n    delta = 0\n    return sum\n  }\n}\n\nfunction width (g, v) {\n  return g.node(v).width\n}\n\nexport default {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n}\n"],"names":[],"mappings":"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"}